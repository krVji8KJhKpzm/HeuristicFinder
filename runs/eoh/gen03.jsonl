{"gen": 3, "index": 0, "file": "gen03_cand000_llm_0_3.4210.py", "score": 3.4209696471518978, "gamma": -0.1, "code_hash": "d5014fe6247751116f6de4174accdec9f7c2eafdcfcbe2f724c5ad25941cb364", "algorithm": "Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.", "stats": {"mse": 0.18682559706115723, "rmse": 0.4322332669533399, "mse_tsp20": 0.18682559706115723, "rmse_tsp20": 0.4322332669533399, "mse_tsp50": 0.19572340977783204, "rmse_tsp50": 0.4424063853266949, "mse_tsp100": 0.2923147829833984, "rmse_tsp100": 0.5406614310114958, "mse_worst": 0.2923147829833984, "rmse_worst": 0.5406614310114958}, "stats_text": "mse=0.186826; rmse=0.432233; mse_tsp100=0.292315; mse_tsp20=0.186826; mse_tsp50=0.195723; mse_worst=0.292315; rmse_tsp100=0.540661; rmse_tsp20=0.432233; rmse_tsp50=0.442406; rmse_worst=0.540661"}
{"gen": 3, "index": 1, "file": "gen03_cand001_llm_0_3.4064.py", "score": 3.406448250786877, "gamma": -0.1, "code_hash": "a509be98760cefdd1fed21f2974aece62623fff8e8b93600894306f7a87ee209", "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.", "stats": {"mse": 0.19756102726745606, "rmse": 0.444478376602795, "mse_tsp20": 0.19756102726745606, "rmse_tsp20": 0.444478376602795, "mse_tsp50": 0.20184117449951172, "rmse_tsp50": 0.44926737528949473, "mse_tsp100": 0.29356089580078126, "rmse_tsp100": 0.5418126021059138, "mse_worst": 0.29356089580078126, "rmse_worst": 0.5418126021059138}, "stats_text": "mse=0.197561; rmse=0.444478; mse_tsp100=0.293561; mse_tsp20=0.197561; mse_tsp50=0.201841; mse_worst=0.293561; rmse_tsp100=0.541813; rmse_tsp20=0.444478; rmse_tsp50=0.449267; rmse_worst=0.541813"}
{"gen": 3, "index": 2, "file": "gen03_cand002_llm_0_3.3782.py", "score": 3.3781803516081297, "gamma": 1.0, "code_hash": "54055c1f192cd4960761c781d6f2bc50f9e6fcc45c0de48c9b7057e7a6b4b015", "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.", "stats": {"mse": 0.21352034575653075, "rmse": 0.4620826178904923, "mse_tsp20": 0.21352034575653075, "rmse_tsp20": 0.4620826178904923, "mse_tsp50": 0.20358135737304686, "rmse_tsp50": 0.4511999084364345, "mse_tsp100": 0.2960173513305664, "rmse_tsp100": 0.5440747663056672, "mse_worst": 0.2960173513305664, "rmse_worst": 0.5440747663056672}, "stats_text": "mse=0.21352; rmse=0.462083; mse_tsp100=0.296017; mse_tsp20=0.21352; mse_tsp50=0.203581; mse_worst=0.296017; rmse_tsp100=0.544075; rmse_tsp20=0.462083; rmse_tsp50=0.4512; rmse_worst=0.544075"}
{"gen": 3, "index": 3, "file": "gen03_cand003_llm_0_2.5272.py", "score": 2.527232641964477, "gamma": 0.1, "code_hash": "dc604ef673fe9a7e63912216f576b19094fd380b26a2e04c3e2c3d74e5ee3b99", "algorithm": "Estimate the future tour length by summing the average distance from each unvisited node to its k-nearest unvisited neighbors, plus the cost to connect the current and start nodes to this unvisited cluster.", "stats": {"mse": 0.39568972930908203, "rmse": 0.6290387343471641, "mse_tsp20": 0.39568972930908203, "rmse_tsp20": 0.6290387343471641, "mse_tsp50": 0.20146149614257813, "rmse_tsp50": 0.4488446236088588, "mse_tsp100": 0.17992913677978514, "rmse_tsp100": 0.42418054738493743, "mse_worst": 0.39568972930908203, "rmse_worst": 0.6290387343471641}, "stats_text": "mse=0.39569; rmse=0.629039; mse_tsp100=0.179929; mse_tsp20=0.39569; mse_tsp50=0.201461; mse_worst=0.39569; rmse_tsp100=0.424181; rmse_tsp20=0.629039; rmse_tsp50=0.448845; rmse_worst=0.629039"}
{"gen": 3, "index": 4, "file": "gen03_cand004_llm_0_2.4230.py", "score": 2.423034464838014, "gamma": -0.1, "code_hash": "1b3b0812ca98a6aa6a8fb459b2e47dca3884b0f5419dcd0d7504221710b3f7b9", "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.", "stats": {"mse": 0.2396109479522705, "rmse": 0.48950071292314834, "mse_tsp20": 0.2396109479522705, "rmse_tsp20": 0.48950071292314834, "mse_tsp50": 0.24980534642333985, "rmse_tsp50": 0.4998053085185669, "mse_tsp100": 0.41270564431152346, "rmse_tsp100": 0.6424217028646553, "mse_worst": 0.41270564431152346, "rmse_worst": 0.6424217028646553}, "stats_text": "mse=0.239611; rmse=0.489501; mse_tsp100=0.412706; mse_tsp20=0.239611; mse_tsp50=0.249805; mse_worst=0.412706; rmse_tsp100=0.642422; rmse_tsp20=0.489501; rmse_tsp50=0.499805; rmse_worst=0.642422"}
{"gen": 3, "index": 5, "file": "gen03_cand005_llm_0_0.7281.py", "score": 0.7280720372806312, "gamma": 0.1, "code_hash": "0cc2a43e13841f036b76914d86123d54dbc39c9e3e58d8eeb12c85a3cec64035", "algorithm": "auto} def phi(state): \"\"\" {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.", "stats": {"mse": 0.4083288623046875, "rmse": 0.6390061520084822, "mse_tsp20": 0.4083288623046875, "rmse_tsp20": 0.6390061520084822, "mse_tsp50": 0.7378879370117187, "rmse_tsp50": 0.8590040378320225, "mse_tsp100": 1.3734904635742187, "rmse_tsp100": 1.1719600947021271, "mse_worst": 1.3734904635742187, "rmse_worst": 1.1719600947021271}, "stats_text": "mse=0.408329; rmse=0.639006; mse_tsp100=1.37349; mse_tsp20=0.408329; mse_tsp50=0.737888; mse_worst=1.37349; rmse_tsp100=1.17196; rmse_tsp20=0.639006; rmse_tsp50=0.859004; rmse_worst=1.17196"}
{"gen": 3, "index": 6, "file": "gen03_cand006_llm_0_0.5100.py", "score": 0.5099670467875159, "gamma": 0.1, "code_hash": "c6aa769dbe2000ef83f865ad1a9c3185a3f1e99084e3c90a1ff0a0dfe96f6796", "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its nearest neighbor among the unvisited, current, and start nodes, plus the minimum cost to connect the current and start nodes into this set.", "stats": {"mse": 0.49089173599243163, "rmse": 0.7006366647503053, "mse_tsp20": 0.49089173599243163, "rmse_tsp20": 0.7006366647503053, "mse_tsp50": 1.0416986204589844, "rmse_tsp50": 1.0206363801369145, "mse_tsp100": 1.9609110163085937, "rmse_tsp100": 1.4003253251686172, "mse_worst": 1.9609110163085937, "rmse_worst": 1.4003253251686172}, "stats_text": "mse=0.490892; rmse=0.700637; mse_tsp100=1.96091; mse_tsp20=0.490892; mse_tsp50=1.0417; mse_worst=1.96091; rmse_tsp100=1.40033; rmse_tsp20=0.700637; rmse_tsp50=1.02064; rmse_worst=1.40033"}
{"gen": 3, "index": 7, "file": "gen03_cand007_llm_0_0.3754.py", "score": 0.3754282050779197, "gamma": -0.1, "code_hash": "f9ca596711c451807e7294379e191f66401b10e6ea8572da9b04c1ab8062bfab", "algorithm": "Estimate future tour length by finding the convex hull of unvisited nodes, adding the current and start nodes, and approximating the tour length of this reduced set.", "stats": {"mse": 2.6636251258544923, "rmse": 1.6320616182774756, "mse_tsp20": 2.6636251258544923, "rmse_tsp20": 1.6320616182774756, "mse_tsp50": 1.59096461484375, "rmse_tsp50": 1.2613344579625778, "mse_tsp100": 1.3190233102539062, "rmse_tsp100": 1.1484874009992039, "mse_worst": 2.6636251258544923, "rmse_worst": 1.6320616182774756}, "stats_text": "mse=2.66363; rmse=1.63206; mse_tsp100=1.31902; mse_tsp20=2.66363; mse_tsp50=1.59096; mse_worst=2.66363; rmse_tsp100=1.14849; rmse_tsp20=1.63206; rmse_tsp50=1.26133; rmse_worst=1.63206"}
{"gen": 3, "index": 8, "file": "gen03_cand008_llm_0_0.2543.py", "score": 0.2543256500584503, "gamma": 0.1, "code_hash": "b5692d3078bbaa95c8199d4acf4dfb8313a5b628da94d9fd8ac264f2af08cf33", "algorithm": "Estimate future tour length by calculating the convex hull area of unvisited nodes and scaling it by the average node density, adding costs to connect the current and start nodes to this hull.} def phi(state): \"\"\" Estimates future tour length using a convex hull-based geometric heuristic. The cost is the sum of three components: 1. An estimate of the sub-tour length for unvisited nodes, derived from the area of their convex hull. The intuition is that tour length scales with the square root of the area covered. This is scaled by node density. 2. The minimum cost to connect the current node to the convex hull. 3. The minimum cost to connect the start node to the convex hull, for the return trip. \"\"\" coords = state.all_node_coords() unvisited_mask = state.unvisited_mask() B, N, _ = coords.shape device = coords.device n_unvisited = unvisited_mask.sum(dim=1) is_terminal = (n_unvisited == 0) has_enough_nodes = (n_unvisited >= 3) # 1. Estimate sub-tour length for unvisited nodes using convex hull. # Create a copy of coords and mask out visited nodes for hull calculation. unvisited_coords = coords.clone() # Set visited nodes to a far-away point so they don't affect the hull. # A single point (e.g., origin) could cause issues if it's inside the hull. large_val = coords.abs().max() + 1.0 unvisited_coords.masked_fill_(~unvisited_mask.unsqueeze(-1), large_val) # Find the bottom-most, then left-most point to start Graham scan. # Using y-coord then x-coord as tie-breaker. sort_keys = torch.stack([unvisited_coords[..., 1], unvisited_coords[..., 0]], dim=-1) # A large value for masked nodes ensures they are sorted last. sort_keys.masked_fill_(~unvisited_mask.unsqueeze(-1), float('inf')) # Find the index of the start point for each batch item. start_pt_idx = torch.lexsort(dims=-1, keys=sort_keys.permute(2, 0, 1))[0] # Get coordinates of the start point. p0 = torch.gather(coords, 1, start_pt_idx.view(B, 1, 1).expand(-1, -1, 2)) # Calculate angles of all other points with respect to p0. # Subtract p0 to center the coordinate system. centered_coords = coords - p0 # Use atan2 for stable angle calculation. angles = torch.atan2(centered_coords[..., 1], centered_coords[..., 0]) # Mask out visited nodes and the start point itself. angles.masked_fill_(~unvisited_mask, float('inf')) angles.scatter_(1, start_pt_idx.unsqueeze(1), float('inf')) # Sort points by angle to get the hull vertices in order. # The sorted indices give the order of vertices in the convex hull. _, sorted_indices = torch.sort(angles, dim=1) # Gather the coordinates of the sorted unvisited points. sorted_unvisited_coords = torch.gather(coords, 1, sorted_indices.unsqueeze(-1).expand(-1, -1, 2)) # Prepend the starting point to form a closed polygon path. # Path: p0 -> sorted_p1 -> sorted_p2 ... -> p0 hull_path_coords = torch.cat([p0, sorted_unvisited_coords], dim=1) # Calculate polygon area using the shoelace formula. x, y = hull_path_coords[..., 0], hull_path_coords[..., 1] # This computes sum(x_i * y_{i+1} - x_{i+1", "stats": {"mse": 0.34320918159484864, "rmse": 0.5858405769446571, "mse_tsp20": 0.34320918159484864, "rmse_tsp20": 0.5858405769446571, "mse_tsp50": 1.331045243798828, "rmse_tsp50": 1.1537093411248902, "mse_tsp100": 3.931966751171875, "rmse_tsp100": 1.9829187454789656, "mse_worst": 3.931966751171875, "rmse_worst": 1.9829187454789656}, "stats_text": "mse=0.343209; rmse=0.585841; mse_tsp100=3.93197; mse_tsp20=0.343209; mse_tsp50=1.33105; mse_worst=3.93197; rmse_tsp100=1.98292; rmse_tsp20=0.585841; rmse_tsp50=1.15371; rmse_worst=1.98292"}
{"gen": 3, "index": 9, "file": "gen03_cand009_llm_0_0.1444.py", "score": 0.14442194401455405, "gamma": -0.1, "code_hash": "948da801474913ef9ed2db71f330b186f78363384b494b85e41c1da0b92ac1a8", "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The algorithm estimates the remaining tour length by multiplying the number of unvisited nodes by the average minimum distance from each unvisited node to any other unvisited node.", "stats": {"mse": 1.8778033940429688, "rmse": 1.3703296661909385, "mse_tsp20": 1.8778033940429688, "rmse_tsp20": 1.3703296661909385, "mse_tsp50": 3.856727740234375, "rmse_tsp50": 1.9638553256883193, "mse_tsp100": 6.9241555140625, "rmse_tsp100": 2.6313790137611304, "mse_worst": 6.9241555140625, "rmse_worst": 2.6313790137611304}, "stats_text": "mse=1.8778; rmse=1.37033; mse_tsp100=6.92416; mse_tsp20=1.8778; mse_tsp50=3.85673; mse_worst=6.92416; rmse_tsp100=2.63138; rmse_tsp20=1.37033; rmse_tsp50=1.96386; rmse_worst=2.63138"}
