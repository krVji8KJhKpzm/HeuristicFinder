{"score": 0.05769675402296268, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.", "code_hash": "df7489edeace72aa540d26fe77201af647d81f86388de9934a7284bd97b03348", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.}\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node = state.current_node_index().unsqueeze(-1).unsqueeze(-1).expand(-1, 1, dist_matrix.size(1))\n    # [B, 1, N]\n    current_distances = torch.gather(dist_matrix, 1, current_node)\n    # [B, N]\n    current_distances_squeezed = current_distances.squeeze(1)\n\n    # [B] -> [B, 1]\n    first_node = state.first_node_index().unsqueeze(-1)\n    # [B, 1]\n    dist_to_start = torch.gather(current_distances_squeezed, 1, first_node)\n\n    # For each unvisited node, find the minimum distance to any other node (including current)\n    # Create a mask that includes unvisited nodes and the current node as potential connection points\n    # [B, N]\n    connect_to_mask = unvisited_mask.clone()\n    # [B, N]\n    connect_to_mask.scatter_(1, state.current_node_index().unsqueeze(-1), True)\n    # [B, 1, N]\n    connect_to_mask_expanded = connect_to_mask.unsqueeze(1)\n\n    # Mask the distance matrix to only consider connections to valid nodes\n    # Set distances to invalid connection points to infinity\n    # [B, N, N]\n    masked_dist = dist_matrix.clone()\n    masked_dist[~connect_to_mask_expanded.expand_as(dist_matrix)] = torch.finfo(dist_matrix.dtype).max\n\n    # Find the minimum distance from each node to a valid connection point\n    # [B, N]\n    min_dist_to_connect, _ = torch.min(masked_dist, dim=2)\n\n    # Sum these minimum distances only for the unvisited nodes\n    # [B, N]\n    min_dist_to_connect.masked_fill_(~unvisited_mask, 0)\n    # [B]\n    sum_min_dists = torch.sum(min_dist_to_connect, dim=1)\n\n    # The total estimated cost is the sum of minimum connection costs for unvisited nodes\n    # plus the cost to return to the start node from the current node.\n    # [B]\n    value = sum_min_dists + dist_to_start.squeeze(1)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 4.035992338867188, "rmse": 2.0089779338925524, "mse_tsp20": 4.035992338867188, "rmse_tsp20": 2.0089779338925524, "mse_tsp50": 8.995781856640624, "rmse_tsp50": 2.9992968937136957, "mse_tsp100": 17.3319975609375, "rmse_tsp100": 4.163171574765745, "mse_worst": 17.3319975609375, "rmse_worst": 4.163171574765745}, "stats_text": "mse=4.03599; rmse=2.00898; mse_tsp100=17.332; mse_tsp20=4.03599; mse_tsp50=8.99578; mse_worst=17.332; rmse_tsp100=4.16317; rmse_tsp20=2.00898; rmse_tsp50=2.9993; rmse_worst=4.16317"}
{"score": 0.030135818936369817, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The algorithm estimates the remaining tour length by summing two components: the average distance from the current node to all unvisited nodes, and the average minimum distance from each unvisited node to another unvisited node, scaled by the number of remaining nodes to visit.", "code_hash": "0c563bef19de3f217d8b84ca5c62a92fac8dbc59fdd898899abbc565e6ea1f92", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The algorithm estimates the remaining tour length by summing two components: the average distance from the current node to all unvisited nodes, and the average minimum distance from each unvisited node to another unvisited node, scaled by the number of remaining nodes to visit.}\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    visited_mask = state.visited_mask()\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # Create a mask for terminal states where no nodes are unvisited\n    is_not_terminal = n_unvisited > 0\n    # Create a safe divisor to avoid division by zero for terminal states\n    safe_n_unvisited = torch.where(is_not_terminal, n_unvisited, torch.ones_like(n_unvisited))\n\n    # Component 1: Average distance from the current node to all unvisited nodes.\n    # [B, N]\n    current_to_all_dists = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    # [B]\n    current_to_unvisited_dists = torch.where(unvisited_mask, current_to_all_dists, torch.tensor(0.0, device=dist_matrix.device))\n    # [B]\n    avg_dist_to_unvisited = current_to_unvisited_dists.sum(dim=1) / safe_n_unvisited\n\n    # Component 2: Average of the minimum distances from each unvisited node to another unvisited node.\n    # This estimates the cost of the next step from any potential unvisited node.\n    # Mask out visited nodes in the distance matrix by setting their distances to a large value.\n    large_value = dist_matrix.max() + 1.0 if dist_matrix.numel() > 0 else 1e9\n    # [B, N, N]\n    unvisited_dist_matrix = dist_matrix.clone()\n    # Mask rows (from) corresponding to visited nodes\n    unvisited_dist_matrix[visited_mask, :] = large_value\n    # Mask columns (to) corresponding to visited nodes\n    unvisited_dist_matrix[:, visited_mask] = large_value\n    # Set diagonal to a large value to ignore self-loops\n    unvisited_dist_matrix.diagonal(dim1=-2, dim2=-1).fill_(large_value)\n\n    # [B, N]\n    min_dists_from_unvisited, _ = unvisited_dist_matrix.min(dim=2)\n    # Set distances from visited nodes to 0 so they don't contribute to the sum\n    min_dists_from_unvisited = torch.where(unvisited_mask, min_dists_from_unvisited, torch.tensor(0.0, device=dist_matrix.device))\n    # [B]\n    avg_min_dist_between_unvisited = min_dists_from_unvisited.sum(dim=1) / safe_n_unvisited\n\n    # Heuristic: The remaining tour length is roughly the number of remaining steps\n    # times the average cost of a step.\n    # We estimate the average step cost using the average minimum distance between unvisited nodes.\n    # We add the cost to get to the next node from the current one.\n    # n_unvisited already includes the step back to the start if it's unvisited.\n    # [B]\n    remaining_tour_length = avg_dist_to_unvisited + (n_unvisited - 1).clamp(min=0) * avg_min_dist_between_unvisited\n\n    # For terminal states, the future cost is zero.\n    # [B]\n    value = torch.where(is_not_terminal, remaining_tour_length, torch.tensor(0.0, device=dist_matrix.device))\n\n    return value.unsqueeze(-1)", "stats": {"mse": 12.401788290039063, "rmse": 3.5216172833002544, "mse_tsp20": 12.401788290039063, "rmse_tsp20": 3.5216172833002544, "mse_tsp50": 23.8361524796875, "rmse_tsp50": 4.8822282289634416, "mse_tsp100": 33.1831035390625, "rmse_tsp100": 5.760477717955561, "mse_worst": 33.1831035390625, "rmse_worst": 5.760477717955561}, "stats_text": "mse=12.4018; rmse=3.52162; mse_tsp100=33.1831; mse_tsp20=12.4018; mse_tsp50=23.8362; mse_worst=33.1831; rmse_tsp100=5.76048; rmse_tsp20=3.52162; rmse_tsp50=4.88223; rmse_worst=5.76048"}
{"score": 0.013692846885730149, "gamma": 0.1, "algorithm": "auto", "code_hash": "c56b73843f678df98a303431c2ce030b166c3f27684f9e1488fd86edf87774e0", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP.\n    The value is composed of three main parts:\n    1. The expected distance from the current node to the next unvisited node.\n    2. The expected total distance for the tour among the remaining unvisited nodes.\n    3. The expected distance from the last unvisited node back to the start node.\n    This provides a heuristic for the remaining path length.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # Get batch size and number of nodes\n    B, N, _ = state.all_node_coords().shape\n    device = state.all_node_coords().device\n\n    # Get masks for visited and unvisited nodes\n    unvisited_mask = state.unvisited_mask()  # [B, N]\n    visited_mask = state.visited_mask()      # [B, N]\n\n    # Count the number of unvisited nodes\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited <= 1) # If 0 or 1 unvisited, the tour is effectively done or in the last step.\n\n    # 1. Distance from the current node to all unvisited nodes\n    dist_matrix = state.distance_matrix()  # [B, N, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N) # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1) # [B, N]\n\n    # Mask out distances to already visited nodes\n    dist_from_current_to_unvisited = dist_from_current.masked_fill(visited_mask, float('inf'))\n    \n    # Heuristic for the next step: average distance to an unvisited node\n    # Use a small epsilon to avoid division by zero\n    avg_dist_to_next = dist_from_current_to_unvisited.nan_to_num(posinf=0.0).sum(dim=1, keepdim=True) / torch.clamp(num_unvisited, min=1.0)\n\n    # 2. Heuristic for the tour among remaining unvisited nodes\n    # For each unvisited node, find its minimum distance to another unvisited node\n    unvisited_to_unvisited_mask = unvisited_mask.unsqueeze(2) & unvisited_mask.unsqueeze(1) # [B, N, N]\n    dist_unvisited = dist_matrix.masked_fill(~unvisited_to_unvisited_mask, float('inf'))\n    \n    # Set diagonal to infinity to find min distance to *another* unvisited node\n    dist_unvisited.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n    \n    # Find the minimum distance from each unvisited node to any other unvisited node\n    min_dist_per_unvisited_node, _ = torch.min(dist_unvisited, dim=2) # [B, N]\n    \n    # Sum these minimum distances and average them to get a per-node cost estimate\n    total_min_dist = min_dist_per_unvisited_node.nan_to_num(posinf=0.0).sum(dim=1, keepdim=True) # [B, 1]\n    avg_min_dist_unvisited = total_min_dist / torch.clamp(num_unvisited, min=1.0)\n    \n    # Scale by the number of remaining steps (num_unvisited - 1)\n    # This approximates a nearest-neighbor heuristic for the remaining sub-tour\n    remaining_subtour_cost = avg_min_dist_unvisited * torch.clamp(num_unvisited - 1, min=0.0)\n\n    # 3. Heuristic for returning to the start node from the last unvisited node\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N) # [B, 1, N]\n    dist_to_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1) # [B, N]\n    \n    # Average distance from any unvisited node back to the start\n    dist_unvisited_to_start = dist_to_start.masked_fill(visited_mask, 0.0)\n    avg_dist_to_start = dist_unvisited_to_start.sum(dim=1, keepdim=True) / torch.clamp(num_unvisited, min=1.0)\n    \n    # Combine the components\n    # The total estimated future cost is the sum of the three parts.\n    # We use num_unvisited > 1 as a condition for adding the subtour and start-return costs.\n    # When num_unvisited == 1, the only remaining action is to return to start.\n    # When num_unvisited == 0, the tour is done, cost is 0.\n    \n    # If only one node left, cost is just dist from current to it, plus dist from it to start\n    last_step_mask = (num_unvisited == 1.0)\n    last_unvisited_idx = unvisited_mask.long().argmax(dim=1, keepdim=True) # [B, 1]\n    last_unvisited_idx_exp = last_unvisited_idx.unsqueeze(2) # [B, 1, 1]\n    \n    dist_curr_to_last = torch.gather(dist_from_current, 1, last_unvisited_idx) # [B, 1]\n    dist_last_to_start = torch.gather(dist_to_start, 1, last_unvisited_idx) # [B, 1]\n    last_step_cost = dist_curr_to_last + dist_last_to_start\n    \n    # Calculate the full heuristic\n    value = avg_dist_to_next + remaining_subtour_cost + avg_dist_to_start\n    \n    # Apply special case for the last step\n    value = torch.where(last_step_mask, last_step_cost, value)\n\n    # If the episode is done (or about to be), the future cost is 0.\n    # This ensures terminal consistency.\n    value = value.masked_fill(is_done, 0.0)\n    \n    # Return as a negative value because the environment uses negative rewards (path length)\n    return -value", "stats": {"mse": 22.51568820703125, "rmse": 4.745069884314798, "mse_tsp20": 22.51568820703125, "rmse_tsp20": 4.745069884314798, "mse_tsp50": 42.503790928125, "rmse_tsp50": 6.519493149634027, "mse_tsp100": 73.0308319625, "rmse_tsp100": 8.545807858973896, "mse_worst": 73.0308319625, "rmse_worst": 8.545807858973896}, "stats_text": "mse=22.5157; rmse=4.74507; mse_tsp100=73.0308; mse_tsp20=22.5157; mse_tsp50=42.5038; mse_worst=73.0308; rmse_tsp100=8.54581; rmse_tsp20=4.74507; rmse_tsp50=6.51949; rmse_worst=8.54581"}
{"score": 0.01237136463050766, "gamma": 0.1, "algorithm": "auto", "code_hash": "c07ac942e284504a00f1c059c1e12455fbe237ea11bed1e024492af1fe9e495e", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP.\n    It's the sum of two components:\n    1. A cost related to the remaining sub-tour of unvisited nodes.\n    2. A cost for connecting the current partial tour to the remaining sub-tour.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    num_unvisited = unvisited_mask.float().sum(dim=1)\n\n    # Handle terminal state: if no nodes are unvisited, the future cost is zero.\n    is_terminal = (num_unvisited == 0)\n\n    # 1. Estimate the cost of the sub-tour connecting the unvisited nodes.\n    # For each unvisited node, find the minimum distance to another unvisited node.\n    # [B, N, N], set distances to/from visited nodes to infinity\n    unvisited_dist = dist_matrix.clone()\n    unvisited_dist_mask = ~(unvisited_mask.unsqueeze(2) & unvisited_mask.unsqueeze(1))\n    unvisited_dist[unvisited_dist_mask] = float('inf')\n\n    # Set diagonal to infinity to find min distance to *another* unvisited node\n    unvisited_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n\n    # [B, N], min distance from each unvisited node to any other unvisited node\n    min_dist_per_node, _ = torch.min(unvisited_dist, dim=2)\n    # Zero out distances for visited nodes\n    min_dist_per_node[~unvisited_mask] = 0.0\n    # [B], sum of these minimum distances\n    subtour_cost = min_dist_per_node.sum(dim=1)\n\n    # 2. Estimate the cost to connect the current path to the unvisited sub-tour.\n    # Find the distance from the current node to the nearest unvisited node.\n    # [B]\n    current_node = state.current_node_index()\n    # [B, N], distances from the current node\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n\n    # [B, N], set distances to visited nodes to infinity\n    dist_from_current_to_unvisited = dist_from_current.clone()\n    dist_from_current_to_unvisited[~unvisited_mask] = float('inf')\n    # [B], min distance to an unvisited node\n    connection_cost, _ = torch.min(dist_from_current_to_unvisited, dim=1)\n    # If terminal, connection_cost is inf; set to 0.\n    connection_cost = torch.nan_to_num(connection_cost, posinf=0.0)\n\n    # Scaling factor to account for the increasing complexity/length with more nodes\n    # Use log1p to handle num_unvisited=0 gracefully (log1p(0)=0) and smooth the scaling\n    scaling_factor = torch.log1p(num_unvisited)\n\n    # Combine the components\n    # The heuristic is a scaled sum of the sub-tour cost and the connection cost.\n    value = (subtour_cost + connection_cost) * scaling_factor\n\n    # Ensure terminal state has a value of 0\n    value[is_terminal] = 0.0\n\n    # The value represents a cost-to-go, so it should be negative for reward shaping.\n    # We return a negative value as V(s) is typically negated in shaping: r' = r + gamma*V(s') - V(s).\n    # Since tour length is a cost (negative reward), V(s) should be positive.\n    return value.unsqueeze(-1)", "stats": {"mse": 5.878291572265625, "rmse": 2.4245188331431096, "mse_tsp20": 5.878291572265625, "rmse_tsp20": 2.4245188331431096, "mse_tsp50": 26.82017915625, "rmse_tsp50": 5.178820247532251, "mse_tsp100": 80.83182655, "rmse_tsp100": 8.99065217601037, "mse_worst": 80.83182655, "rmse_worst": 8.99065217601037}, "stats_text": "mse=5.87829; rmse=2.42452; mse_tsp100=80.8318; mse_tsp20=5.87829; mse_tsp50=26.8202; mse_worst=80.8318; rmse_tsp100=8.99065; rmse_tsp20=2.42452; rmse_tsp50=5.17882; rmse_worst=8.99065"}
{"score": 0.0028222236375838395, "gamma": 1.0, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP. Args: state (TSPStateView): The current state of the TSP environment. Returns: torch.Tensor: A scalar tensor of shape [B, 1] representing the estimated future tour length. \"\"\" # {The algorithm estimates future tour length by combining three components: the average distance from the current node to unvisited nodes, the average distance from the start node back to unvisited nodes, and the expected path length within the remaining unvisited nodes based on their average pairwise distance.", "code_hash": "20b90a53a5ad12b5e48dade46876d784234cacd827017f98aa9fb4ff37d2e088", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n\n    Returns:\n        torch.Tensor: A scalar tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # {The algorithm estimates future tour length by combining three components: the average distance from the current node to unvisited nodes, the average distance from the start node back to unvisited nodes, and the expected path length within the remaining unvisited nodes based on their average pairwise distance.}\n    \n    # Get state information\n    dist_matrix = state.distance_matrix()  # [B, N, N]\n    unvisited_mask = state.unvisited_mask()  # [B, N]\n    current_node = state.current_node_index()  # [B]\n    first_node = state.first_node_index()  # [B]\n    \n    # Useful dimensions and counts\n    B, N = dist_matrix.shape[:2]\n    device = dist_matrix.device\n    \n    # Number of unvisited nodes, handle division by zero\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True).float()  # [B, 1]\n    is_done = (num_unvisited <= 1e-9) # [B,1]\n\n    # 1. Cost from current node to the next unvisited node\n    # Gather distances from the current node to all other nodes\n    current_idx_exp = current_node.view(B, 1, 1).expand(-1, 1, N) # [B,1,N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_idx_exp).squeeze(1)  # [B, N]\n    \n    # Mask to keep only distances to unvisited nodes\n    dist_from_current_to_unvisited = dist_from_current * unvisited_mask\n    \n    # Average distance from current to unvisited (cost to connect to the remaining subgraph)\n    # Using a safe division\n    sum_dist_curr_unvisited = dist_from_current_to_unvisited.sum(dim=1, keepdim=True) # [B,1]\n    avg_dist_curr_unvisited = sum_dist_curr_unvisited / torch.clamp(num_unvisited, min=1.0) # [B,1]\n    \n    # 2. Cost from the last unvisited node back to the start node\n    # Gather distances from the start node to all other nodes\n    first_idx_exp = first_node.view(B, 1, 1).expand(-1, 1, N) # [B,1,N]\n    dist_from_start = torch.gather(dist_matrix, 1, first_idx_exp).squeeze(1) # [B, N]\n    \n    # Mask to keep only distances to unvisited nodes\n    dist_from_start_to_unvisited = dist_from_start * unvisited_mask\n    \n    # Average distance from start to unvisited (cost to close the loop)\n    sum_dist_start_unvisited = dist_from_start_to_unvisited.sum(dim=1, keepdim=True) # [B,1]\n    avg_dist_start_unvisited = sum_dist_start_unvisited / torch.clamp(num_unvisited, min=1.0) # [B,1]\n\n    # 3. Estimated cost of the tour within the unvisited nodes\n    # Create a mask for pairs of unvisited nodes\n    unvisited_mask_2d = unvisited_mask.unsqueeze(2) * unvisited_mask.unsqueeze(1)  # [B, N, N]\n    \n    # Sum of distances between all pairs of unvisited nodes\n    sum_dist_unvisited_pairs = (dist_matrix * unvisited_mask_2d).sum(dim=(1, 2), keepdim=True) # [B,1,1]\n    sum_dist_unvisited_pairs = sum_dist_unvisited_pairs.squeeze(-1) # [B,1]\n    \n    # Number of pairs of unvisited nodes\n    num_pairs = num_unvisited * (num_unvisited - 1) # [B,1]\n    \n    # Average distance between any two unvisited nodes\n    avg_inter_unvisited_dist = sum_dist_unvisited_pairs / torch.clamp(num_pairs, min=1.0) # [B,1]\n    \n    # The MST/tour length is roughly proportional to (N-1) * avg_edge_length\n    # We use (num_unvisited - 1) as the scaling factor.\n    internal_tour_cost = avg_inter_unvisited_dist * torch.clamp(num_unvisited - 1, min=0.0) # [B,1]\n\n    # Combine the three components\n    # The total future cost is the sum of these three estimates.\n    # We use a small scaling factor on the internal cost to keep it moderate.\n    value = avg_dist_curr_unvisited + avg_dist_start_unvisited + 0.8 * internal_tour_cost # [B,1]\n    \n    # For terminal states, the future cost is zero.\n    final_value = torch.where(is_done, torch.zeros_like(value), value)\n    \n    return final_value", "stats": {"mse": 9.33898097998047, "rmse": 3.0559746366716576, "mse_tsp20": 9.33898097998047, "rmse_tsp20": 3.0559746366716576, "mse_tsp50": 79.23632165, "rmse_tsp50": 8.90147862155496, "mse_tsp100": 354.3305309625, "rmse_tsp100": 18.82366943405297, "mse_worst": 354.3305309625, "rmse_worst": 18.82366943405297}, "stats_text": "mse=9.33898; rmse=3.05597; mse_tsp100=354.331; mse_tsp20=9.33898; mse_tsp50=79.2363; mse_worst=354.331; rmse_tsp100=18.8237; rmse_tsp20=3.05597; rmse_tsp50=8.90148; rmse_worst=18.8237"}
{"score": 0.0009115116258871784, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The potential function estimates the remaining tour length by combining the average distance from the current node to all unvisited nodes with the expected length of the tour connecting those unvisited nodes, which is approximated by scaling the average inter-node distance by the number of remaining nodes.", "code_hash": "47134c722c880296b0d968fcab1d94cb65813f4788c1e5c2dc1acd2812dffb54", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The potential function estimates the remaining tour length by combining the average distance from the current node to all unvisited nodes with the expected length of the tour connecting those unvisited nodes, which is approximated by scaling the average inter-node distance by the number of remaining nodes.}\n    Args:\n        state: A TSPStateView object providing access to the environment state.\n    Returns:\n        A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N], True for unvisited\n    unvisited_mask = state.unvisited_mask()\n    # [B], index of the current node\n    current_node_idx = state.current_node_index()\n    # [B, 1, 1] for broadcasting\n    current_node_idx_b = current_node_idx.unsqueeze(-1).unsqueeze(-1)\n    # [B, 1, N]\n    current_node_idx_b_expanded = current_node_idx_b.expand(-1, 1, dist_matrix.shape[2])\n\n    # --- Term 1: Expected distance to the next node ---\n    # [B, N], distances from current node to all other nodes\n    dists_from_current = torch.gather(dist_matrix, 1, current_node_idx_b_expanded).squeeze(1)\n    # Apply mask to consider only unvisited nodes\n    dists_from_current_to_unvisited = dists_from_current.masked_fill(~unvisited_mask, 0.0)\n    # [B], number of unvisited nodes\n    num_unvisited = unvisited_mask.float().sum(dim=1)\n    # Avoid division by zero for terminal states\n    num_unvisited_safe = torch.max(num_unvisited, torch.ones_like(num_unvisited))\n    # [B], average distance from current to unvisited nodes\n    avg_dist_to_next = dists_from_current_to_unvisited.sum(dim=1) / num_unvisited_safe\n    # Set to 0 if no nodes are unvisited (terminal state)\n    avg_dist_to_next = avg_dist_to_next.masked_fill(num_unvisited == 0, 0.0)\n\n    # --- Term 2: Expected length of the remaining tour among unvisited nodes ---\n    # [B, N, N] -> [B, N, N], mask out distances involving visited nodes\n    unvisited_mask_2d = unvisited_mask.unsqueeze(2) & unvisited_mask.unsqueeze(1)\n    unvisited_dists = dist_matrix.masked_fill(~unvisited_mask_2d, 0.0)\n    # [B], sum of all distances between unvisited nodes\n    sum_unvisited_dists = unvisited_dists.sum(dim=(1, 2))\n    # [B], number of pairs of unvisited nodes\n    num_pairs = num_unvisited * (num_unvisited - 1.0).clamp(min=0.0)\n    num_pairs_safe = torch.max(num_pairs, torch.ones_like(num_pairs))\n    # [B], average distance between any two unvisited nodes\n    avg_inter_unvisited_dist = sum_unvisited_dists / num_pairs_safe\n    # Scale by the number of remaining edges to form the rest of the tour\n    # A simple heuristic: (N_unvisited - 1) edges needed.\n    remaining_tour_len_est = avg_inter_unvisited_dist * (num_unvisited - 1.0).clamp(min=0.0)\n\n    # --- Combine terms ---\n    # The total estimated future cost is the sum of the two components.\n    # The negative sign is because the environment uses negative rewards (costs).\n    value = - (avg_dist_to_next + remaining_tour_len_est)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 70.7539018125, "rmse": 8.411533856110905, "mse_tsp20": 70.7539018125, "rmse_tsp20": 8.411533856110905, "mse_tsp50": 326.047080275, "rmse_tsp50": 18.056773805832535, "mse_tsp100": 1097.07871145, "rmse_tsp100": 33.12217854323595, "mse_worst": 1097.07871145, "rmse_worst": 33.12217854323595}, "stats_text": "mse=70.7539; rmse=8.41153; mse_tsp100=1097.08; mse_tsp20=70.7539; mse_tsp50=326.047; mse_worst=1097.08; rmse_tsp100=33.1222; rmse_tsp20=8.41153; rmse_tsp50=18.0568; rmse_worst=33.1222"}
{"score": 0.0008882724062440662, "gamma": 1.0, "algorithm": "auto", "code_hash": "ed09708794992a726ec22800dace99f18abcd13ae79deddbf39361787530f72b", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (value) for a TSP state.\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N], True for unvisited\n    unvisited_mask = state.unvisited_mask()\n    # [B], index of current node\n    current_node = state.current_node_index()\n    # [B], index of first node\n    start_node = state.first_node_index()\n\n    # Number of unvisited nodes, [B]\n    num_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # Mask to prevent division by zero for terminal states\n    is_not_terminal = num_unvisited > 0\n    # Create a safe divisor, [B]\n    safe_num_unvisited = torch.where(is_not_terminal, num_unvisited, torch.ones_like(num_unvisited))\n\n    # --- Component 1: Cost from current node to the \"center\" of unvisited nodes ---\n    # [B, 1, N]\n    current_node_expanded = current_node.unsqueeze(1).unsqueeze(2).expand(-1, 1, dist_matrix.size(2))\n    # [B, N], distances from current node to all other nodes\n    dist_from_current = dist_matrix.gather(1, current_node_expanded).squeeze(1)\n    # Mask out distances to already visited nodes\n    dist_from_current_to_unvisited = dist_from_current * unvisited_mask\n    # [B], average distance from current to unvisited\n    avg_dist_to_unvisited = dist_from_current_to_unvisited.sum(dim=1) / safe_num_unvisited\n\n    # --- Component 2: Estimated cost to traverse remaining unvisited nodes ---\n    # Create a mask for pairs of unvisited nodes [B, N, N]\n    unvisited_pairs_mask = unvisited_mask.unsqueeze(2) & unvisited_mask.unsqueeze(1)\n    # Mask out diagonal and visited nodes\n    unvisited_pairs_mask.diagonal(dim1=-2, dim2=-1).fill_(False)\n    # [B, N, N], distances only between unvisited nodes\n    unvisited_dist = dist_matrix * unvisited_pairs_mask\n    # [B], sum of distances between all unique pairs of unvisited nodes\n    sum_pairwise_unvisited_dist = unvisited_dist.sum(dim=(1, 2)) / 2.0\n    # [B], number of pairs of unvisited nodes\n    num_unvisited_pairs = num_unvisited * (num_unvisited - 1) / 2.0\n    safe_num_unvisited_pairs = torch.where(num_unvisited_pairs > 0, num_unvisited_pairs, torch.ones_like(num_unvisited_pairs))\n    # [B], average distance between unvisited nodes\n    avg_pairwise_unvisited_dist = sum_pairwise_unvisited_dist / safe_num_unvisited_pairs\n    # Scale by (num_unvisited - 1) to approximate a path through them\n    internal_tour_cost = avg_pairwise_unvisited_dist * torch.clamp(num_unvisited - 1, min=0)\n\n    # --- Component 3: Cost to return to the start from the \"last\" unvisited node ---\n    # [B, 1, N]\n    start_node_expanded = start_node.unsqueeze(1).unsqueeze(2).expand(-1, 1, dist_matrix.size(2))\n    # [B, N], distances from start node to all other nodes\n    dist_from_start = dist_matrix.gather(1, start_node_expanded).squeeze(1)\n    # Mask out distances to already visited nodes\n    dist_from_start_to_unvisited = dist_from_start * unvisited_mask\n    # [B], average distance from start to unvisited\n    avg_dist_from_start = dist_from_start_to_unvisited.sum(dim=1) / safe_num_unvisited\n\n    # Combine components\n    # The total estimated cost is the sum of the three parts.\n    # We use a negative sign because value is typically anti-correlated with cost.\n    # The logic is: travel to the unvisited cluster, travel within it, then return home.\n    total_cost = avg_dist_to_unvisited + internal_tour_cost + avg_dist_from_start\n\n    # For terminal states (num_unvisited == 0), the future cost is 0.\n    # For the penultimate state (num_unvisited == 1), the cost is dist(current, last_node) + dist(last_node, start).\n    # Let's check the penultimate case: num_unvisited=1.\n    # avg_dist_to_unvisited = dist(current, last_node)\n    # internal_tour_cost = 0\n    # avg_dist_from_start = dist(start, last_node)\n    # This seems reasonable.\n    final_value = -total_cost * is_not_terminal\n\n    return final_value.unsqueeze(-1)", "stats": {"mse": 78.20185086328125, "rmse": 8.843181037572467, "mse_tsp20": 78.20185086328125, "rmse_tsp20": 8.843181037572467, "mse_tsp50": 341.7625521625, "rmse_tsp50": 18.486821039932746, "mse_tsp100": 1125.78077735, "rmse_tsp100": 33.55265678526814, "mse_worst": 1125.78077735, "rmse_worst": 33.55265678526814}, "stats_text": "mse=78.2019; rmse=8.84318; mse_tsp100=1125.78; mse_tsp20=78.2019; mse_tsp50=341.763; mse_worst=1125.78; rmse_tsp100=33.5527; rmse_tsp20=8.84318; rmse_tsp50=18.4868; rmse_worst=33.5527"}
{"score": 0.0007997825226245871, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {My algorithm estimates the future cost by summing three components: the average distance from the current node to all unvisited nodes, the expected tour length for the remaining unvisited nodes, and the distance from the current node back to the starting node.", "code_hash": "da7fdc9bb032d1f5335892b71ec67a7e33e1be96c889b1bb71d5c01fa854e005", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {My algorithm estimates the future cost by summing three components: the average distance from the current node to all unvisited nodes, the expected tour length for the remaining unvisited nodes, and the distance from the current node back to the starting node.}\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar potential value for each state in the batch, shape [B, 1].\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    \n    # Number of unvisited nodes, [B]\n    num_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n    \n    # Avoid division by zero for terminal states where num_unvisited is 0\n    is_not_terminal = num_unvisited > 0\n    \n    # Component 1: Expected distance to the next node\n    # Distance from the current node to all other nodes: [B, N]\n    dist_from_current = dist_matrix.gather(1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    \n    # Masked average distance to unvisited nodes\n    masked_dist_from_current = dist_from_current * unvisited_mask\n    sum_dist_to_unvisited = masked_dist_from_current.sum(dim=1)\n    # [B]\n    avg_dist_to_next = torch.zeros_like(sum_dist_to_unvisited)\n    avg_dist_to_next[is_not_terminal] = sum_dist_to_unvisited[is_not_terminal] / num_unvisited[is_not_terminal]\n    \n    # Component 2: Estimated length of the tour through remaining unvisited nodes\n    # Use average inter-node distance as a proxy for edge length\n    # To make it permutation invariant and stable, calculate avg distance over all nodes\n    total_dist_sum = dist_matrix.sum(dim=(1, 2))\n    N = dist_matrix.size(1)\n    # Average distance between any two distinct nodes\n    avg_inter_node_dist = total_dist_sum / (N * (N - 1))\n    \n    # Estimated remaining tour length is (num_unvisited - 1) edges\n    # [B]\n    remaining_tour_len = (num_unvisited - 1).clamp(min=0) * avg_inter_node_dist\n    \n    # Component 3: Estimated cost to return to start from the *last* unvisited node\n    # We approximate this by the distance from the *current* node to the start node.\n    # This is a simplification but captures the closing cost.\n    # [B]\n    dist_to_start = dist_matrix.gather(1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1).gather(1, start_node.view(-1, 1)).squeeze(1)\n    \n    # Combine components, only for non-terminal states\n    # For terminal states, the future cost is 0.\n    value = torch.zeros_like(num_unvisited)\n    value[is_not_terminal] = avg_dist_to_next[is_not_terminal] + remaining_tour_len[is_not_terminal] + dist_to_start[is_not_terminal]\n    \n    # The potential should be negative because we are minimizing tour length (maximizing negative length)\n    return -value.unsqueeze(1)", "stats": {"mse": 80.944675265625, "rmse": 8.99692587863349, "mse_tsp20": 80.944675265625, "rmse_tsp20": 8.99692587863349, "mse_tsp50": 365.0893084125, "rmse_tsp50": 19.10731033956637, "mse_tsp100": 1250.3399008, "rmse_tsp100": 35.3601456558086, "mse_worst": 1250.3399008, "rmse_worst": 35.3601456558086}, "stats_text": "mse=80.9447; rmse=8.99693; mse_tsp100=1250.34; mse_tsp20=80.9447; mse_tsp50=365.089; mse_worst=1250.34; rmse_tsp100=35.3601; rmse_tsp20=8.99693; rmse_tsp50=19.1073; rmse_worst=35.3601"}
{"score": 4.25466936187738e-05, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {My algorithm approximates the future tour length by summing two components: the average distance from the current node to all unvisited nodes, and the expected length of the remaining sub-tour among unvisited nodes, which is estimated as the product of the remaining number of edges and the average inter-node distance within the unvisited set.", "code_hash": "110b52ce4be499b2e570598accb70428a11c0a3e4c7a503ec60bdbf0b645105b", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {My algorithm approximates the future tour length by summing two components: the average distance from the current node to all unvisited nodes, and the expected length of the remaining sub-tour among unvisited nodes, which is estimated as the product of the remaining number of edges and the average inter-node distance within the unvisited set.}\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, 1]\n    num_unvisited = unvisited_mask.float().sum(dim=1, keepdim=True)\n    # [B] -> [B, 1, 1] for broadcasting\n    current_node_idx = state.current_node_index().view(-1, 1, 1)\n\n    # 1. Cost from current node to the next unvisited node\n    # [B, 1, N]\n    dists_from_current = torch.gather(dist_matrix, 1, current_node_idx.expand(-1, 1, dist_matrix.size(2)))\n    # [B, 1, N] -> [B, N]\n    dists_from_current = dists_from_current.squeeze(1)\n    # Zero out distances to visited nodes\n    dists_to_unvisited = dists_from_current * unvisited_mask.float()\n    # Sum of distances to unvisited nodes [B, 1]\n    sum_dists_to_unvisited = dists_to_unvisited.sum(dim=1, keepdim=True)\n    # Average distance to an unvisited node [B, 1]\n    # Add a small epsilon to avoid division by zero when num_unvisited is 0\n    avg_dist_to_next = sum_dists_to_unvisited / torch.clamp(num_unvisited, min=1.0)\n\n    # 2. Cost of the remaining sub-tour among unvisited nodes\n    # [B, N, N] -> [B, N, N], mask rows\n    unvisited_rows = dist_matrix * unvisited_mask.float().unsqueeze(2)\n    # [B, N, N] -> [B, N, N], mask columns\n    unvisited_submatrix = unvisited_rows * unvisited_mask.float().unsqueeze(1)\n    # Sum of all distances in the submatrix [B, 1]\n    sum_inter_unvisited_dists = unvisited_submatrix.sum(dim=[1, 2], keepdim=True)\n    # Number of pairs in the unvisited set: N_unvisited * (N_unvisited - 1)\n    num_pairs = num_unvisited * (num_unvisited - 1.0)\n    # Average distance between any two unvisited nodes [B, 1]\n    # Add epsilon to avoid division by zero\n    avg_inter_unvisited_dist = sum_inter_unvisited_dists / torch.clamp(num_pairs, min=1.0)\n\n    # The remaining tour length is roughly (num_unvisited - 1) edges.\n    # We use num_unvisited as a simple approximation for the number of edges.\n    remaining_subtour_len = avg_inter_unvisited_dist * torch.clamp(num_unvisited - 1.0, min=0.0)\n\n    # Total estimated future cost\n    # For a completed tour, num_unvisited is 0, so both terms become 0.\n    value = avg_dist_to_next + remaining_subtour_len\n\n    # The potential should be negative because we are minimizing length (maximizing negative length)\n    return -value", "stats": {"mse": 399.8715980703125, "rmse": 19.996789694106212, "mse_tsp20": 399.8715980703125, "rmse_tsp20": 19.996789694106212, "mse_tsp50": 4516.3885538875, "rmse_tsp50": 67.20408137819831, "mse_tsp100": 23503.588997071874, "rmse_tsp100": 153.30880273836814, "mse_worst": 23503.588997071874, "rmse_worst": 153.30880273836814}, "stats_text": "mse=399.872; rmse=19.9968; mse_tsp100=23503.6; mse_tsp20=399.872; mse_tsp50=4516.39; mse_worst=23503.6; rmse_tsp100=153.309; rmse_tsp20=19.9968; rmse_tsp50=67.2041; rmse_worst=153.309"}
{"score": 0.11230624864292459, "gamma": -0.1, "algorithm": "Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.", "code_hash": "0e7601ed649dfde68fc9175671d4df815cf1f6e8088ee79de00b3b2d9f6dd931", "code": "# THOUGHT: {Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on the geometric properties of unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes using the area of their convex hull.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n    This combines a geometric heuristic for the bulk of the path with connection costs.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n\n    # 1. Approximate sub-tour length using convex hull area of unvisited nodes\n    # A heuristic for tour length is related to the square root of the area of the convex hull.\n    # We use a simplified proxy: the area of the bounding box of unvisited nodes.\n\n    # Mask coordinates of visited nodes to exclude them from min/max calculations\n    # [B, N, 2]\n    masked_coords = coords.clone()\n    # Use a large value for visited nodes so they don't affect min, and a small value for max\n    large_val = torch.finfo(coords.dtype).max\n    small_val = torch.finfo(coords.dtype).min\n    # [B, N, 1]\n    unvisited_mask_exp = unvisited_mask.unsqueeze(-1)\n    masked_coords.masked_fill_(~unvisited_mask_exp, large_val)\n    min_coords, _ = torch.min(masked_coords, dim=1)  # [B, 2]\n\n    masked_coords = coords.clone()\n    masked_coords.masked_fill_(~unvisited_mask_exp, small_val)\n    max_coords, _ = torch.max(masked_coords, dim=1)  # [B, 2]\n\n    # Calculate width and height of the bounding box\n    # [B, 2]\n    span = max_coords - min_coords\n    # Clamp to avoid negative span if only one node is left\n    span = torch.clamp(span, min=0.0)\n    # [B]\n    area = span[:, 0] * span[:, 1]\n    # Heuristic for tour length: k * sqrt(Area * num_unvisited), k is an empirical factor\n    # For a unit square with N points, E[tour_len] ~ beta * sqrt(N), and Area=1.\n    # We use a simplified form: sqrt(Area) as a proxy for the spatial scale.\n    # The sum of two sides of the bounding box is a reasonable perimeter proxy.\n    subtour_cost = span[:, 0] + span[:, 1]\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, torch.finfo(dist_from_current.dtype).max)\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop)\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, torch.finfo(dist_from_start.dtype).max)\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Combine the components\n    # [B]\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n    \n    # Handle edge case where only one unvisited node remains\n    # The cost is just from current -> last_unvisited -> start\n    is_last_step = (num_unvisited.squeeze(-1) == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step]\n\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix[is_last_step, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix[is_last_step, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step] = last_step_cost\n\n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set if num_unvisited=0) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.9090601949462891, "rmse": 0.9534464824762264, "mse_tsp20": 0.9090601949462891, "rmse_tsp20": 0.9534464824762264, "mse_tsp50": 3.432229481640625, "rmse_tsp50": 1.852627723435182, "mse_tsp100": 8.904224048828125, "rmse_tsp100": 2.9839946462465585, "mse_worst": 8.904224048828125, "rmse_worst": 2.9839946462465585}, "stats_text": "mse=0.90906; rmse=0.953446; mse_tsp100=8.90422; mse_tsp20=0.90906; mse_tsp50=3.43223; mse_worst=8.90422; rmse_tsp100=2.98399; rmse_tsp20=0.953446; rmse_tsp50=1.85263; rmse_worst=2.98399"}
{"score": 0.05769675402296268, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.", "code_hash": "df7489edeace72aa540d26fe77201af647d81f86388de9934a7284bd97b03348", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.}\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node = state.current_node_index().unsqueeze(-1).unsqueeze(-1).expand(-1, 1, dist_matrix.size(1))\n    # [B, 1, N]\n    current_distances = torch.gather(dist_matrix, 1, current_node)\n    # [B, N]\n    current_distances_squeezed = current_distances.squeeze(1)\n\n    # [B] -> [B, 1]\n    first_node = state.first_node_index().unsqueeze(-1)\n    # [B, 1]\n    dist_to_start = torch.gather(current_distances_squeezed, 1, first_node)\n\n    # For each unvisited node, find the minimum distance to any other node (including current)\n    # Create a mask that includes unvisited nodes and the current node as potential connection points\n    # [B, N]\n    connect_to_mask = unvisited_mask.clone()\n    # [B, N]\n    connect_to_mask.scatter_(1, state.current_node_index().unsqueeze(-1), True)\n    # [B, 1, N]\n    connect_to_mask_expanded = connect_to_mask.unsqueeze(1)\n\n    # Mask the distance matrix to only consider connections to valid nodes\n    # Set distances to invalid connection points to infinity\n    # [B, N, N]\n    masked_dist = dist_matrix.clone()\n    masked_dist[~connect_to_mask_expanded.expand_as(dist_matrix)] = torch.finfo(dist_matrix.dtype).max\n\n    # Find the minimum distance from each node to a valid connection point\n    # [B, N]\n    min_dist_to_connect, _ = torch.min(masked_dist, dim=2)\n\n    # Sum these minimum distances only for the unvisited nodes\n    # [B, N]\n    min_dist_to_connect.masked_fill_(~unvisited_mask, 0)\n    # [B]\n    sum_min_dists = torch.sum(min_dist_to_connect, dim=1)\n\n    # The total estimated cost is the sum of minimum connection costs for unvisited nodes\n    # plus the cost to return to the start node from the current node.\n    # [B]\n    value = sum_min_dists + dist_to_start.squeeze(1)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 4.035992338867188, "rmse": 2.0089779338925524, "mse_tsp20": 4.035992338867188, "rmse_tsp20": 2.0089779338925524, "mse_tsp50": 8.995781856640624, "rmse_tsp50": 2.9992968937136957, "mse_tsp100": 17.3319975609375, "rmse_tsp100": 4.163171574765745, "mse_worst": 17.3319975609375, "rmse_worst": 4.163171574765745}, "stats_text": "mse=4.03599; rmse=2.00898; mse_tsp100=17.332; mse_tsp20=4.03599; mse_tsp50=8.99578; mse_worst=17.332; rmse_tsp100=4.16317; rmse_tsp20=2.00898; rmse_tsp50=2.9993; rmse_worst=4.16317"}
{"score": 0.030135818936369817, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The algorithm estimates the remaining tour length by summing two components: the average distance from the current node to all unvisited nodes, and the average minimum distance from each unvisited node to another unvisited node, scaled by the number of remaining nodes to visit.", "code_hash": "0c563bef19de3f217d8b84ca5c62a92fac8dbc59fdd898899abbc565e6ea1f92", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The algorithm estimates the remaining tour length by summing two components: the average distance from the current node to all unvisited nodes, and the average minimum distance from each unvisited node to another unvisited node, scaled by the number of remaining nodes to visit.}\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    visited_mask = state.visited_mask()\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # Create a mask for terminal states where no nodes are unvisited\n    is_not_terminal = n_unvisited > 0\n    # Create a safe divisor to avoid division by zero for terminal states\n    safe_n_unvisited = torch.where(is_not_terminal, n_unvisited, torch.ones_like(n_unvisited))\n\n    # Component 1: Average distance from the current node to all unvisited nodes.\n    # [B, N]\n    current_to_all_dists = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    # [B]\n    current_to_unvisited_dists = torch.where(unvisited_mask, current_to_all_dists, torch.tensor(0.0, device=dist_matrix.device))\n    # [B]\n    avg_dist_to_unvisited = current_to_unvisited_dists.sum(dim=1) / safe_n_unvisited\n\n    # Component 2: Average of the minimum distances from each unvisited node to another unvisited node.\n    # This estimates the cost of the next step from any potential unvisited node.\n    # Mask out visited nodes in the distance matrix by setting their distances to a large value.\n    large_value = dist_matrix.max() + 1.0 if dist_matrix.numel() > 0 else 1e9\n    # [B, N, N]\n    unvisited_dist_matrix = dist_matrix.clone()\n    # Mask rows (from) corresponding to visited nodes\n    unvisited_dist_matrix[visited_mask, :] = large_value\n    # Mask columns (to) corresponding to visited nodes\n    unvisited_dist_matrix[:, visited_mask] = large_value\n    # Set diagonal to a large value to ignore self-loops\n    unvisited_dist_matrix.diagonal(dim1=-2, dim2=-1).fill_(large_value)\n\n    # [B, N]\n    min_dists_from_unvisited, _ = unvisited_dist_matrix.min(dim=2)\n    # Set distances from visited nodes to 0 so they don't contribute to the sum\n    min_dists_from_unvisited = torch.where(unvisited_mask, min_dists_from_unvisited, torch.tensor(0.0, device=dist_matrix.device))\n    # [B]\n    avg_min_dist_between_unvisited = min_dists_from_unvisited.sum(dim=1) / safe_n_unvisited\n\n    # Heuristic: The remaining tour length is roughly the number of remaining steps\n    # times the average cost of a step.\n    # We estimate the average step cost using the average minimum distance between unvisited nodes.\n    # We add the cost to get to the next node from the current one.\n    # n_unvisited already includes the step back to the start if it's unvisited.\n    # [B]\n    remaining_tour_length = avg_dist_to_unvisited + (n_unvisited - 1).clamp(min=0) * avg_min_dist_between_unvisited\n\n    # For terminal states, the future cost is zero.\n    # [B]\n    value = torch.where(is_not_terminal, remaining_tour_length, torch.tensor(0.0, device=dist_matrix.device))\n\n    return value.unsqueeze(-1)", "stats": {"mse": 12.401788290039063, "rmse": 3.5216172833002544, "mse_tsp20": 12.401788290039063, "rmse_tsp20": 3.5216172833002544, "mse_tsp50": 23.8361524796875, "rmse_tsp50": 4.8822282289634416, "mse_tsp100": 33.1831035390625, "rmse_tsp100": 5.760477717955561, "mse_worst": 33.1831035390625, "rmse_worst": 5.760477717955561}, "stats_text": "mse=12.4018; rmse=3.52162; mse_tsp100=33.1831; mse_tsp20=12.4018; mse_tsp50=23.8362; mse_worst=33.1831; rmse_tsp100=5.76048; rmse_tsp20=3.52162; rmse_tsp50=4.88223; rmse_worst=5.76048"}
{"score": 0.0162410203458143, "gamma": -0.1, "algorithm": "Estimate the future tour length by calculating the cost of a convex hull around unvisited nodes, plus the costs to connect the current and start nodes to this hull.", "code_hash": "4fd7044f0a2792e1506701c0b8d639b18640f0383c6f3aa38f4a2283890d4310", "code": "# THOUGHT: {Estimate the future tour length by calculating the cost of a convex hull around unvisited nodes, plus the costs to connect the current and start nodes to this hull.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP using a convex hull heuristic.\n    The value is composed of three parts:\n    1. The perimeter of the convex hull of the unvisited nodes, which serves as a lower bound for the sub-tour length.\n    2. The minimum distance from the current node to any unvisited node (cost to enter the sub-tour).\n    3. The minimum distance from the start node to any unvisited node (cost to return from the sub-tour).\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, 1]\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)\n\n    # 1. Calculate the convex hull perimeter for unvisited nodes\n    # For stability, replace coordinates of visited nodes with a far-away point\n    # so they don't interfere with the convex hull of unvisited nodes.\n    # A large value like 1e9 should be outside any practical TSP coordinate range.\n    large_val = torch.full_like(coords, 1e9)\n    # [B, N, 2]\n    unvisited_coords = torch.where(unvisited_mask.unsqueeze(-1), coords, large_val)\n\n    # Find the min/max x/y coordinates among unvisited nodes to approximate the hull size\n    # This avoids complex hull algorithms and is differentiable.\n    # [B, 1]\n    min_x = torch.min(unvisited_coords[..., 0], dim=1, keepdim=True).values\n    max_x = torch.max(unvisited_coords[..., 0].masked_fill_(~unvisited_mask, -1e9), dim=1, keepdim=True).values\n    min_y = torch.min(unvisited_coords[..., 1], dim=1, keepdim=True).values\n    max_y = torch.max(unvisited_coords[..., 1].masked_fill_(~unvisited_mask, -1e9), dim=1, keepdim=True).values\n\n    # Approximate perimeter of the bounding box as a proxy for convex hull perimeter\n    # [B, 1]\n    hull_perimeter = 2 * ((max_x - min_x) + (max_y - min_y))\n    # Handle cases with 0 or 1 unvisited nodes where hull is undefined or zero\n    hull_perimeter = hull_perimeter.masked_fill(num_unvisited <= 1, 0.0)\n\n    # 2. Calculate connection costs to the unvisited set\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(-1, 1, 1).expand(-1, 1, dist_matrix.size(1))\n    start_node_idx = state.first_node_index().view(-1, 1, 1).expand(-1, 1, dist_matrix.size(1))\n\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n\n    # Find minimum distance to any unvisited node\n    # [B, 1]\n    min_dist_to_unvisited = torch.min(dist_from_current.masked_fill(~unvisited_mask, float('inf')), dim=1, keepdim=True).values\n    min_dist_from_unvisited_to_start = torch.min(dist_from_start.masked_fill(~unvisited_mask, float('inf')), dim=1, keepdim=True).values\n\n    # Handle terminal states where no unvisited nodes exist\n    min_dist_to_unvisited = min_dist_to_unvisited.nan_to_num(posinf=0.0)\n    min_dist_from_unvisited_to_start = min_dist_from_unvisited_to_start.nan_to_num(posinf=0.0)\n\n    # Total estimated future cost\n    value = hull_perimeter + min_dist_to_unvisited + min_dist_from_unvisited_to_start\n\n    # Special case for the last step: cost is simply from current to last, then to start\n    is_last_step = (num_unvisited == 1)\n    if is_last_step.any():\n        # [B, 1]\n        last_unvisited_idx = unvisited_mask.long().argmax(dim=1, keepdim=True)\n        # [B, 1]\n        dist_curr_to_last = torch.gather(dist_from_current, 1, last_unvisited_idx)\n        dist_last_to_start = torch.gather(dist_from_start, 1, last_unvisited_idx)\n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value = torch.where(is_last_step, last_step_cost, value)\n\n    # If the tour is done, future cost is zero.\n    is_done = (num_unvisited == 0)\n    value = value.masked_fill(is_done, 0.0)\n\n    return -value", "stats": {"mse": 28.49783874609375, "rmse": 5.338336702203576, "mse_tsp20": 28.49783874609375, "rmse_tsp20": 5.338336702203576, "mse_tsp50": 42.679790340625, "rmse_tsp50": 6.532977142208979, "mse_tsp100": 61.57248613125, "rmse_tsp100": 7.846813756630777, "mse_worst": 61.57248613125, "rmse_worst": 7.846813756630777}, "stats_text": "mse=28.4978; rmse=5.33834; mse_tsp100=61.5725; mse_tsp20=28.4978; mse_tsp50=42.6798; mse_worst=61.5725; rmse_tsp100=7.84681; rmse_tsp20=5.33834; rmse_tsp50=6.53298; rmse_worst=7.84681"}
{"score": 0.013692846885730149, "gamma": 0.1, "algorithm": "auto", "code_hash": "c56b73843f678df98a303431c2ce030b166c3f27684f9e1488fd86edf87774e0", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP.\n    The value is composed of three main parts:\n    1. The expected distance from the current node to the next unvisited node.\n    2. The expected total distance for the tour among the remaining unvisited nodes.\n    3. The expected distance from the last unvisited node back to the start node.\n    This provides a heuristic for the remaining path length.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # Get batch size and number of nodes\n    B, N, _ = state.all_node_coords().shape\n    device = state.all_node_coords().device\n\n    # Get masks for visited and unvisited nodes\n    unvisited_mask = state.unvisited_mask()  # [B, N]\n    visited_mask = state.visited_mask()      # [B, N]\n\n    # Count the number of unvisited nodes\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited <= 1) # If 0 or 1 unvisited, the tour is effectively done or in the last step.\n\n    # 1. Distance from the current node to all unvisited nodes\n    dist_matrix = state.distance_matrix()  # [B, N, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N) # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1) # [B, N]\n\n    # Mask out distances to already visited nodes\n    dist_from_current_to_unvisited = dist_from_current.masked_fill(visited_mask, float('inf'))\n    \n    # Heuristic for the next step: average distance to an unvisited node\n    # Use a small epsilon to avoid division by zero\n    avg_dist_to_next = dist_from_current_to_unvisited.nan_to_num(posinf=0.0).sum(dim=1, keepdim=True) / torch.clamp(num_unvisited, min=1.0)\n\n    # 2. Heuristic for the tour among remaining unvisited nodes\n    # For each unvisited node, find its minimum distance to another unvisited node\n    unvisited_to_unvisited_mask = unvisited_mask.unsqueeze(2) & unvisited_mask.unsqueeze(1) # [B, N, N]\n    dist_unvisited = dist_matrix.masked_fill(~unvisited_to_unvisited_mask, float('inf'))\n    \n    # Set diagonal to infinity to find min distance to *another* unvisited node\n    dist_unvisited.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n    \n    # Find the minimum distance from each unvisited node to any other unvisited node\n    min_dist_per_unvisited_node, _ = torch.min(dist_unvisited, dim=2) # [B, N]\n    \n    # Sum these minimum distances and average them to get a per-node cost estimate\n    total_min_dist = min_dist_per_unvisited_node.nan_to_num(posinf=0.0).sum(dim=1, keepdim=True) # [B, 1]\n    avg_min_dist_unvisited = total_min_dist / torch.clamp(num_unvisited, min=1.0)\n    \n    # Scale by the number of remaining steps (num_unvisited - 1)\n    # This approximates a nearest-neighbor heuristic for the remaining sub-tour\n    remaining_subtour_cost = avg_min_dist_unvisited * torch.clamp(num_unvisited - 1, min=0.0)\n\n    # 3. Heuristic for returning to the start node from the last unvisited node\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N) # [B, 1, N]\n    dist_to_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1) # [B, N]\n    \n    # Average distance from any unvisited node back to the start\n    dist_unvisited_to_start = dist_to_start.masked_fill(visited_mask, 0.0)\n    avg_dist_to_start = dist_unvisited_to_start.sum(dim=1, keepdim=True) / torch.clamp(num_unvisited, min=1.0)\n    \n    # Combine the components\n    # The total estimated future cost is the sum of the three parts.\n    # We use num_unvisited > 1 as a condition for adding the subtour and start-return costs.\n    # When num_unvisited == 1, the only remaining action is to return to start.\n    # When num_unvisited == 0, the tour is done, cost is 0.\n    \n    # If only one node left, cost is just dist from current to it, plus dist from it to start\n    last_step_mask = (num_unvisited == 1.0)\n    last_unvisited_idx = unvisited_mask.long().argmax(dim=1, keepdim=True) # [B, 1]\n    last_unvisited_idx_exp = last_unvisited_idx.unsqueeze(2) # [B, 1, 1]\n    \n    dist_curr_to_last = torch.gather(dist_from_current, 1, last_unvisited_idx) # [B, 1]\n    dist_last_to_start = torch.gather(dist_to_start, 1, last_unvisited_idx) # [B, 1]\n    last_step_cost = dist_curr_to_last + dist_last_to_start\n    \n    # Calculate the full heuristic\n    value = avg_dist_to_next + remaining_subtour_cost + avg_dist_to_start\n    \n    # Apply special case for the last step\n    value = torch.where(last_step_mask, last_step_cost, value)\n\n    # If the episode is done (or about to be), the future cost is 0.\n    # This ensures terminal consistency.\n    value = value.masked_fill(is_done, 0.0)\n    \n    # Return as a negative value because the environment uses negative rewards (path length)\n    return -value", "stats": {"mse": 22.51568820703125, "rmse": 4.745069884314798, "mse_tsp20": 22.51568820703125, "rmse_tsp20": 4.745069884314798, "mse_tsp50": 42.503790928125, "rmse_tsp50": 6.519493149634027, "mse_tsp100": 73.0308319625, "rmse_tsp100": 8.545807858973896, "mse_worst": 73.0308319625, "rmse_worst": 8.545807858973896}, "stats_text": "mse=22.5157; rmse=4.74507; mse_tsp100=73.0308; mse_tsp20=22.5157; mse_tsp50=42.5038; mse_worst=73.0308; rmse_tsp100=8.54581; rmse_tsp20=4.74507; rmse_tsp50=6.51949; rmse_worst=8.54581"}
{"score": 0.01237136463050766, "gamma": 0.1, "algorithm": "auto", "code_hash": "c07ac942e284504a00f1c059c1e12455fbe237ea11bed1e024492af1fe9e495e", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP.\n    It's the sum of two components:\n    1. A cost related to the remaining sub-tour of unvisited nodes.\n    2. A cost for connecting the current partial tour to the remaining sub-tour.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    num_unvisited = unvisited_mask.float().sum(dim=1)\n\n    # Handle terminal state: if no nodes are unvisited, the future cost is zero.\n    is_terminal = (num_unvisited == 0)\n\n    # 1. Estimate the cost of the sub-tour connecting the unvisited nodes.\n    # For each unvisited node, find the minimum distance to another unvisited node.\n    # [B, N, N], set distances to/from visited nodes to infinity\n    unvisited_dist = dist_matrix.clone()\n    unvisited_dist_mask = ~(unvisited_mask.unsqueeze(2) & unvisited_mask.unsqueeze(1))\n    unvisited_dist[unvisited_dist_mask] = float('inf')\n\n    # Set diagonal to infinity to find min distance to *another* unvisited node\n    unvisited_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n\n    # [B, N], min distance from each unvisited node to any other unvisited node\n    min_dist_per_node, _ = torch.min(unvisited_dist, dim=2)\n    # Zero out distances for visited nodes\n    min_dist_per_node[~unvisited_mask] = 0.0\n    # [B], sum of these minimum distances\n    subtour_cost = min_dist_per_node.sum(dim=1)\n\n    # 2. Estimate the cost to connect the current path to the unvisited sub-tour.\n    # Find the distance from the current node to the nearest unvisited node.\n    # [B]\n    current_node = state.current_node_index()\n    # [B, N], distances from the current node\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n\n    # [B, N], set distances to visited nodes to infinity\n    dist_from_current_to_unvisited = dist_from_current.clone()\n    dist_from_current_to_unvisited[~unvisited_mask] = float('inf')\n    # [B], min distance to an unvisited node\n    connection_cost, _ = torch.min(dist_from_current_to_unvisited, dim=1)\n    # If terminal, connection_cost is inf; set to 0.\n    connection_cost = torch.nan_to_num(connection_cost, posinf=0.0)\n\n    # Scaling factor to account for the increasing complexity/length with more nodes\n    # Use log1p to handle num_unvisited=0 gracefully (log1p(0)=0) and smooth the scaling\n    scaling_factor = torch.log1p(num_unvisited)\n\n    # Combine the components\n    # The heuristic is a scaled sum of the sub-tour cost and the connection cost.\n    value = (subtour_cost + connection_cost) * scaling_factor\n\n    # Ensure terminal state has a value of 0\n    value[is_terminal] = 0.0\n\n    # The value represents a cost-to-go, so it should be negative for reward shaping.\n    # We return a negative value as V(s) is typically negated in shaping: r' = r + gamma*V(s') - V(s).\n    # Since tour length is a cost (negative reward), V(s) should be positive.\n    return value.unsqueeze(-1)", "stats": {"mse": 5.878291572265625, "rmse": 2.4245188331431096, "mse_tsp20": 5.878291572265625, "rmse_tsp20": 2.4245188331431096, "mse_tsp50": 26.82017915625, "rmse_tsp50": 5.178820247532251, "mse_tsp100": 80.83182655, "rmse_tsp100": 8.99065217601037, "mse_worst": 80.83182655, "rmse_worst": 8.99065217601037}, "stats_text": "mse=5.87829; rmse=2.42452; mse_tsp100=80.8318; mse_tsp20=5.87829; mse_tsp50=26.8202; mse_worst=80.8318; rmse_tsp100=8.99065; rmse_tsp20=2.42452; rmse_tsp50=5.17882; rmse_worst=8.99065"}
{"score": 0.0028222236375838395, "gamma": 1.0, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP. Args: state (TSPStateView): The current state of the TSP environment. Returns: torch.Tensor: A scalar tensor of shape [B, 1] representing the estimated future tour length. \"\"\" # {The algorithm estimates future tour length by combining three components: the average distance from the current node to unvisited nodes, the average distance from the start node back to unvisited nodes, and the expected path length within the remaining unvisited nodes based on their average pairwise distance.", "code_hash": "20b90a53a5ad12b5e48dade46876d784234cacd827017f98aa9fb4ff37d2e088", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n\n    Returns:\n        torch.Tensor: A scalar tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # {The algorithm estimates future tour length by combining three components: the average distance from the current node to unvisited nodes, the average distance from the start node back to unvisited nodes, and the expected path length within the remaining unvisited nodes based on their average pairwise distance.}\n    \n    # Get state information\n    dist_matrix = state.distance_matrix()  # [B, N, N]\n    unvisited_mask = state.unvisited_mask()  # [B, N]\n    current_node = state.current_node_index()  # [B]\n    first_node = state.first_node_index()  # [B]\n    \n    # Useful dimensions and counts\n    B, N = dist_matrix.shape[:2]\n    device = dist_matrix.device\n    \n    # Number of unvisited nodes, handle division by zero\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True).float()  # [B, 1]\n    is_done = (num_unvisited <= 1e-9) # [B,1]\n\n    # 1. Cost from current node to the next unvisited node\n    # Gather distances from the current node to all other nodes\n    current_idx_exp = current_node.view(B, 1, 1).expand(-1, 1, N) # [B,1,N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_idx_exp).squeeze(1)  # [B, N]\n    \n    # Mask to keep only distances to unvisited nodes\n    dist_from_current_to_unvisited = dist_from_current * unvisited_mask\n    \n    # Average distance from current to unvisited (cost to connect to the remaining subgraph)\n    # Using a safe division\n    sum_dist_curr_unvisited = dist_from_current_to_unvisited.sum(dim=1, keepdim=True) # [B,1]\n    avg_dist_curr_unvisited = sum_dist_curr_unvisited / torch.clamp(num_unvisited, min=1.0) # [B,1]\n    \n    # 2. Cost from the last unvisited node back to the start node\n    # Gather distances from the start node to all other nodes\n    first_idx_exp = first_node.view(B, 1, 1).expand(-1, 1, N) # [B,1,N]\n    dist_from_start = torch.gather(dist_matrix, 1, first_idx_exp).squeeze(1) # [B, N]\n    \n    # Mask to keep only distances to unvisited nodes\n    dist_from_start_to_unvisited = dist_from_start * unvisited_mask\n    \n    # Average distance from start to unvisited (cost to close the loop)\n    sum_dist_start_unvisited = dist_from_start_to_unvisited.sum(dim=1, keepdim=True) # [B,1]\n    avg_dist_start_unvisited = sum_dist_start_unvisited / torch.clamp(num_unvisited, min=1.0) # [B,1]\n\n    # 3. Estimated cost of the tour within the unvisited nodes\n    # Create a mask for pairs of unvisited nodes\n    unvisited_mask_2d = unvisited_mask.unsqueeze(2) * unvisited_mask.unsqueeze(1)  # [B, N, N]\n    \n    # Sum of distances between all pairs of unvisited nodes\n    sum_dist_unvisited_pairs = (dist_matrix * unvisited_mask_2d).sum(dim=(1, 2), keepdim=True) # [B,1,1]\n    sum_dist_unvisited_pairs = sum_dist_unvisited_pairs.squeeze(-1) # [B,1]\n    \n    # Number of pairs of unvisited nodes\n    num_pairs = num_unvisited * (num_unvisited - 1) # [B,1]\n    \n    # Average distance between any two unvisited nodes\n    avg_inter_unvisited_dist = sum_dist_unvisited_pairs / torch.clamp(num_pairs, min=1.0) # [B,1]\n    \n    # The MST/tour length is roughly proportional to (N-1) * avg_edge_length\n    # We use (num_unvisited - 1) as the scaling factor.\n    internal_tour_cost = avg_inter_unvisited_dist * torch.clamp(num_unvisited - 1, min=0.0) # [B,1]\n\n    # Combine the three components\n    # The total future cost is the sum of these three estimates.\n    # We use a small scaling factor on the internal cost to keep it moderate.\n    value = avg_dist_curr_unvisited + avg_dist_start_unvisited + 0.8 * internal_tour_cost # [B,1]\n    \n    # For terminal states, the future cost is zero.\n    final_value = torch.where(is_done, torch.zeros_like(value), value)\n    \n    return final_value", "stats": {"mse": 9.33898097998047, "rmse": 3.0559746366716576, "mse_tsp20": 9.33898097998047, "rmse_tsp20": 3.0559746366716576, "mse_tsp50": 79.23632165, "rmse_tsp50": 8.90147862155496, "mse_tsp100": 354.3305309625, "rmse_tsp100": 18.82366943405297, "mse_worst": 354.3305309625, "rmse_worst": 18.82366943405297}, "stats_text": "mse=9.33898; rmse=3.05597; mse_tsp100=354.331; mse_tsp20=9.33898; mse_tsp50=79.2363; mse_worst=354.331; rmse_tsp100=18.8237; rmse_tsp20=3.05597; rmse_tsp50=8.90148; rmse_worst=18.8237"}
{"score": 0.0009115116258871784, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The potential function estimates the remaining tour length by combining the average distance from the current node to all unvisited nodes with the expected length of the tour connecting those unvisited nodes, which is approximated by scaling the average inter-node distance by the number of remaining nodes.", "code_hash": "47134c722c880296b0d968fcab1d94cb65813f4788c1e5c2dc1acd2812dffb54", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The potential function estimates the remaining tour length by combining the average distance from the current node to all unvisited nodes with the expected length of the tour connecting those unvisited nodes, which is approximated by scaling the average inter-node distance by the number of remaining nodes.}\n    Args:\n        state: A TSPStateView object providing access to the environment state.\n    Returns:\n        A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N], True for unvisited\n    unvisited_mask = state.unvisited_mask()\n    # [B], index of the current node\n    current_node_idx = state.current_node_index()\n    # [B, 1, 1] for broadcasting\n    current_node_idx_b = current_node_idx.unsqueeze(-1).unsqueeze(-1)\n    # [B, 1, N]\n    current_node_idx_b_expanded = current_node_idx_b.expand(-1, 1, dist_matrix.shape[2])\n\n    # --- Term 1: Expected distance to the next node ---\n    # [B, N], distances from current node to all other nodes\n    dists_from_current = torch.gather(dist_matrix, 1, current_node_idx_b_expanded).squeeze(1)\n    # Apply mask to consider only unvisited nodes\n    dists_from_current_to_unvisited = dists_from_current.masked_fill(~unvisited_mask, 0.0)\n    # [B], number of unvisited nodes\n    num_unvisited = unvisited_mask.float().sum(dim=1)\n    # Avoid division by zero for terminal states\n    num_unvisited_safe = torch.max(num_unvisited, torch.ones_like(num_unvisited))\n    # [B], average distance from current to unvisited nodes\n    avg_dist_to_next = dists_from_current_to_unvisited.sum(dim=1) / num_unvisited_safe\n    # Set to 0 if no nodes are unvisited (terminal state)\n    avg_dist_to_next = avg_dist_to_next.masked_fill(num_unvisited == 0, 0.0)\n\n    # --- Term 2: Expected length of the remaining tour among unvisited nodes ---\n    # [B, N, N] -> [B, N, N], mask out distances involving visited nodes\n    unvisited_mask_2d = unvisited_mask.unsqueeze(2) & unvisited_mask.unsqueeze(1)\n    unvisited_dists = dist_matrix.masked_fill(~unvisited_mask_2d, 0.0)\n    # [B], sum of all distances between unvisited nodes\n    sum_unvisited_dists = unvisited_dists.sum(dim=(1, 2))\n    # [B], number of pairs of unvisited nodes\n    num_pairs = num_unvisited * (num_unvisited - 1.0).clamp(min=0.0)\n    num_pairs_safe = torch.max(num_pairs, torch.ones_like(num_pairs))\n    # [B], average distance between any two unvisited nodes\n    avg_inter_unvisited_dist = sum_unvisited_dists / num_pairs_safe\n    # Scale by the number of remaining edges to form the rest of the tour\n    # A simple heuristic: (N_unvisited - 1) edges needed.\n    remaining_tour_len_est = avg_inter_unvisited_dist * (num_unvisited - 1.0).clamp(min=0.0)\n\n    # --- Combine terms ---\n    # The total estimated future cost is the sum of the two components.\n    # The negative sign is because the environment uses negative rewards (costs).\n    value = - (avg_dist_to_next + remaining_tour_len_est)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 70.7539018125, "rmse": 8.411533856110905, "mse_tsp20": 70.7539018125, "rmse_tsp20": 8.411533856110905, "mse_tsp50": 326.047080275, "rmse_tsp50": 18.056773805832535, "mse_tsp100": 1097.07871145, "rmse_tsp100": 33.12217854323595, "mse_worst": 1097.07871145, "rmse_worst": 33.12217854323595}, "stats_text": "mse=70.7539; rmse=8.41153; mse_tsp100=1097.08; mse_tsp20=70.7539; mse_tsp50=326.047; mse_worst=1097.08; rmse_tsp100=33.1222; rmse_tsp20=8.41153; rmse_tsp50=18.0568; rmse_worst=33.1222"}
{"score": 0.0008882724062440662, "gamma": 1.0, "algorithm": "auto", "code_hash": "ed09708794992a726ec22800dace99f18abcd13ae79deddbf39361787530f72b", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (value) for a TSP state.\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N], True for unvisited\n    unvisited_mask = state.unvisited_mask()\n    # [B], index of current node\n    current_node = state.current_node_index()\n    # [B], index of first node\n    start_node = state.first_node_index()\n\n    # Number of unvisited nodes, [B]\n    num_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # Mask to prevent division by zero for terminal states\n    is_not_terminal = num_unvisited > 0\n    # Create a safe divisor, [B]\n    safe_num_unvisited = torch.where(is_not_terminal, num_unvisited, torch.ones_like(num_unvisited))\n\n    # --- Component 1: Cost from current node to the \"center\" of unvisited nodes ---\n    # [B, 1, N]\n    current_node_expanded = current_node.unsqueeze(1).unsqueeze(2).expand(-1, 1, dist_matrix.size(2))\n    # [B, N], distances from current node to all other nodes\n    dist_from_current = dist_matrix.gather(1, current_node_expanded).squeeze(1)\n    # Mask out distances to already visited nodes\n    dist_from_current_to_unvisited = dist_from_current * unvisited_mask\n    # [B], average distance from current to unvisited\n    avg_dist_to_unvisited = dist_from_current_to_unvisited.sum(dim=1) / safe_num_unvisited\n\n    # --- Component 2: Estimated cost to traverse remaining unvisited nodes ---\n    # Create a mask for pairs of unvisited nodes [B, N, N]\n    unvisited_pairs_mask = unvisited_mask.unsqueeze(2) & unvisited_mask.unsqueeze(1)\n    # Mask out diagonal and visited nodes\n    unvisited_pairs_mask.diagonal(dim1=-2, dim2=-1).fill_(False)\n    # [B, N, N], distances only between unvisited nodes\n    unvisited_dist = dist_matrix * unvisited_pairs_mask\n    # [B], sum of distances between all unique pairs of unvisited nodes\n    sum_pairwise_unvisited_dist = unvisited_dist.sum(dim=(1, 2)) / 2.0\n    # [B], number of pairs of unvisited nodes\n    num_unvisited_pairs = num_unvisited * (num_unvisited - 1) / 2.0\n    safe_num_unvisited_pairs = torch.where(num_unvisited_pairs > 0, num_unvisited_pairs, torch.ones_like(num_unvisited_pairs))\n    # [B], average distance between unvisited nodes\n    avg_pairwise_unvisited_dist = sum_pairwise_unvisited_dist / safe_num_unvisited_pairs\n    # Scale by (num_unvisited - 1) to approximate a path through them\n    internal_tour_cost = avg_pairwise_unvisited_dist * torch.clamp(num_unvisited - 1, min=0)\n\n    # --- Component 3: Cost to return to the start from the \"last\" unvisited node ---\n    # [B, 1, N]\n    start_node_expanded = start_node.unsqueeze(1).unsqueeze(2).expand(-1, 1, dist_matrix.size(2))\n    # [B, N], distances from start node to all other nodes\n    dist_from_start = dist_matrix.gather(1, start_node_expanded).squeeze(1)\n    # Mask out distances to already visited nodes\n    dist_from_start_to_unvisited = dist_from_start * unvisited_mask\n    # [B], average distance from start to unvisited\n    avg_dist_from_start = dist_from_start_to_unvisited.sum(dim=1) / safe_num_unvisited\n\n    # Combine components\n    # The total estimated cost is the sum of the three parts.\n    # We use a negative sign because value is typically anti-correlated with cost.\n    # The logic is: travel to the unvisited cluster, travel within it, then return home.\n    total_cost = avg_dist_to_unvisited + internal_tour_cost + avg_dist_from_start\n\n    # For terminal states (num_unvisited == 0), the future cost is 0.\n    # For the penultimate state (num_unvisited == 1), the cost is dist(current, last_node) + dist(last_node, start).\n    # Let's check the penultimate case: num_unvisited=1.\n    # avg_dist_to_unvisited = dist(current, last_node)\n    # internal_tour_cost = 0\n    # avg_dist_from_start = dist(start, last_node)\n    # This seems reasonable.\n    final_value = -total_cost * is_not_terminal\n\n    return final_value.unsqueeze(-1)", "stats": {"mse": 78.20185086328125, "rmse": 8.843181037572467, "mse_tsp20": 78.20185086328125, "rmse_tsp20": 8.843181037572467, "mse_tsp50": 341.7625521625, "rmse_tsp50": 18.486821039932746, "mse_tsp100": 1125.78077735, "rmse_tsp100": 33.55265678526814, "mse_worst": 1125.78077735, "rmse_worst": 33.55265678526814}, "stats_text": "mse=78.2019; rmse=8.84318; mse_tsp100=1125.78; mse_tsp20=78.2019; mse_tsp50=341.763; mse_worst=1125.78; rmse_tsp100=33.5527; rmse_tsp20=8.84318; rmse_tsp50=18.4868; rmse_worst=33.5527"}
{"score": 0.0007997825226245871, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {My algorithm estimates the future cost by summing three components: the average distance from the current node to all unvisited nodes, the expected tour length for the remaining unvisited nodes, and the distance from the current node back to the starting node.", "code_hash": "da7fdc9bb032d1f5335892b71ec67a7e33e1be96c889b1bb71d5c01fa854e005", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {My algorithm estimates the future cost by summing three components: the average distance from the current node to all unvisited nodes, the expected tour length for the remaining unvisited nodes, and the distance from the current node back to the starting node.}\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar potential value for each state in the batch, shape [B, 1].\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    \n    # Number of unvisited nodes, [B]\n    num_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n    \n    # Avoid division by zero for terminal states where num_unvisited is 0\n    is_not_terminal = num_unvisited > 0\n    \n    # Component 1: Expected distance to the next node\n    # Distance from the current node to all other nodes: [B, N]\n    dist_from_current = dist_matrix.gather(1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    \n    # Masked average distance to unvisited nodes\n    masked_dist_from_current = dist_from_current * unvisited_mask\n    sum_dist_to_unvisited = masked_dist_from_current.sum(dim=1)\n    # [B]\n    avg_dist_to_next = torch.zeros_like(sum_dist_to_unvisited)\n    avg_dist_to_next[is_not_terminal] = sum_dist_to_unvisited[is_not_terminal] / num_unvisited[is_not_terminal]\n    \n    # Component 2: Estimated length of the tour through remaining unvisited nodes\n    # Use average inter-node distance as a proxy for edge length\n    # To make it permutation invariant and stable, calculate avg distance over all nodes\n    total_dist_sum = dist_matrix.sum(dim=(1, 2))\n    N = dist_matrix.size(1)\n    # Average distance between any two distinct nodes\n    avg_inter_node_dist = total_dist_sum / (N * (N - 1))\n    \n    # Estimated remaining tour length is (num_unvisited - 1) edges\n    # [B]\n    remaining_tour_len = (num_unvisited - 1).clamp(min=0) * avg_inter_node_dist\n    \n    # Component 3: Estimated cost to return to start from the *last* unvisited node\n    # We approximate this by the distance from the *current* node to the start node.\n    # This is a simplification but captures the closing cost.\n    # [B]\n    dist_to_start = dist_matrix.gather(1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1).gather(1, start_node.view(-1, 1)).squeeze(1)\n    \n    # Combine components, only for non-terminal states\n    # For terminal states, the future cost is 0.\n    value = torch.zeros_like(num_unvisited)\n    value[is_not_terminal] = avg_dist_to_next[is_not_terminal] + remaining_tour_len[is_not_terminal] + dist_to_start[is_not_terminal]\n    \n    # The potential should be negative because we are minimizing tour length (maximizing negative length)\n    return -value.unsqueeze(1)", "stats": {"mse": 80.944675265625, "rmse": 8.99692587863349, "mse_tsp20": 80.944675265625, "rmse_tsp20": 8.99692587863349, "mse_tsp50": 365.0893084125, "rmse_tsp50": 19.10731033956637, "mse_tsp100": 1250.3399008, "rmse_tsp100": 35.3601456558086, "mse_worst": 1250.3399008, "rmse_worst": 35.3601456558086}, "stats_text": "mse=80.9447; rmse=8.99693; mse_tsp100=1250.34; mse_tsp20=80.9447; mse_tsp50=365.089; mse_worst=1250.34; rmse_tsp100=35.3601; rmse_tsp20=8.99693; rmse_tsp50=19.1073; rmse_worst=35.3601"}
{"score": 3.4209696471518978, "gamma": -0.1, "algorithm": "Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.", "code_hash": "d5014fe6247751116f6de4174accdec9f7c2eafdcfcbe2f724c5ad25941cb364", "code": "# THOUGHT: {Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length using a Minimum Spanning Tree (MST) based heuristic.\n    The cost is the sum of three components:\n    1. The cost of the MST of the subgraph formed by the unvisited nodes. This provides a\n       tight lower bound on the optimal sub-tour length for these nodes.\n    2. The minimum cost to connect the current node to the set of unvisited nodes.\n    3. The minimum cost to connect the start node to the set of unvisited nodes,\n       which is necessary for closing the tour.\n    \n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n    \n    # 1. Calculate the cost of the MST on the unvisited nodes.\n    # Prim's algorithm for dense graphs.\n    # We will compute this only for batches where there are unvisited nodes.\n    # [B, N]\n    min_cost = torch.full((B, N), float('inf'), device=device)\n    # [B, N]\n    visited_in_mst = torch.zeros_like(unvisited_mask)\n    # [B]\n    mst_cost = torch.zeros(B, device=device)\n    \n    # Initialize Prim's: pick the first unvisited node as the starting point for the MST.\n    # Find the index of the first 'True' in unvisited_mask for each batch item.\n    first_unvisited_idx = torch.argmax(unvisited_mask.int(), dim=1)\n    \n    # Set the min_cost for the starting node of the MST to 0.\n    # This ensures it's the first one picked.\n    min_cost.scatter_(1, first_unvisited_idx.unsqueeze(1), 0)\n    \n    # Mask min_cost for nodes that are already visited in the main tour.\n    min_cost.masked_fill_(~unvisited_mask, float('inf'))\n\n    # Prim's algorithm loop executed in a parallelized way over N-1 steps.\n    # This is a fixed-iteration loop, avoiding dynamic Python loops.\n    for _ in range(N):\n        # Find the node `u` with the minimum cost that is unvisited in the MST.\n        # [B, 1]\n        u_idx = torch.argmin(min_cost, dim=1, keepdim=True)\n        # [B]\n        u_cost = torch.gather(min_cost, 1, u_idx).squeeze(1)\n        \n        # Add its cost to the total MST cost, handling inf for disconnected components.\n        mst_cost += torch.where(u_cost == float('inf'), 0, u_cost)\n        \n        # Mark `u` as visited in the MST and remove it from consideration.\n        visited_in_mst.scatter_(1, u_idx, True)\n        min_cost.scatter_(1, u_idx, float('inf'))\n\n        # Update min_costs for neighbors of `u`.\n        # [B, N]\n        dist_from_u = torch.gather(dist_matrix, 1, u_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        \n        # Update only if the new path through `u` is shorter and the neighbor is unvisited in MST.\n        # We also need to ensure the neighbor is part of the unvisited set for the main tour.\n        update_mask = (dist_from_u < min_cost) & ~visited_in_mst & unvisited_mask\n        min_cost[update_mask] = dist_from_u[update_mask]\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    # Mask distances to already visited nodes.\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop).\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Total estimated cost\n    # For the case with only one unvisited node, MST cost is 0. The formula becomes\n    # dist(current -> last) + dist(start -> last), which is correct.\n    value = mst_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # For terminal states, future cost is 0.\n    value.masked_fill_(is_terminal, 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0.\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.18682559706115723, "rmse": 0.4322332669533399, "mse_tsp20": 0.18682559706115723, "rmse_tsp20": 0.4322332669533399, "mse_tsp50": 0.19572340977783204, "rmse_tsp50": 0.4424063853266949, "mse_tsp100": 0.2923147829833984, "rmse_tsp100": 0.5406614310114958, "mse_worst": 0.2923147829833984, "rmse_worst": 0.5406614310114958}, "stats_text": "mse=0.186826; rmse=0.432233; mse_tsp100=0.292315; mse_tsp20=0.186826; mse_tsp50=0.195723; mse_worst=0.292315; rmse_tsp100=0.540661; rmse_tsp20=0.432233; rmse_tsp50=0.442406; rmse_worst=0.540661"}
{"score": 2.423034464838014, "gamma": -0.1, "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.", "code_hash": "1b3b0812ca98a6aa6a8fb459b2e47dca3884b0f5419dcd0d7504221710b3f7b9", "code": "# THOUGHT: {Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length by approximating a path through unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes. For each unvisited node,\n       we find the distance to its two nearest neighbors among the other unvisited nodes.\n       The sum of these distances, averaged over all unvisited nodes, provides an estimate\n       of the local path cost. This is scaled by the number of unvisited nodes.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n    is_last_step = (num_unvisited == 1)\n    is_penultimate = (num_unvisited == 2)\n\n    # 1. Approximate sub-tour length through unvisited nodes\n    # Create a distance matrix only considering unvisited nodes.\n    # We set distances to/from visited nodes to infinity.\n    unvisited_dist = dist_matrix.clone()\n    inf = torch.finfo(dist_matrix.dtype).max\n    # Mask rows (from) and columns (to) corresponding to visited nodes\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), inf)\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), inf)\n\n    # For each unvisited node, find the distances to its two nearest unvisited neighbors.\n    # We use k=3 because the node itself is included with distance 0.\n    # [B, N, 3]\n    k = min(3, N) # handle N < 3 case\n    topk_dists, _ = torch.topk(unvisited_dist, k, dim=2, largest=False)\n\n    # The first value (k=0) is always 0 (distance to self), so we take k=1 and k=2.\n    # Sum of distances to two nearest neighbors for each node.\n    # If less than 3 unvisited nodes, some of these will be inf.\n    if k > 2:\n        two_nn_dist_sum = topk_dists[:, :, 1] + topk_dists[:, :, 2] # [B, N]\n    elif k > 1:\n        two_nn_dist_sum = topk_dists[:, :, 1] # [B, N]\n    else:\n        two_nn_dist_sum = torch.zeros_like(unvisited_mask, dtype=dist_matrix.dtype)\n\n\n    # Mask out the sums for visited nodes\n    two_nn_dist_sum.masked_fill_(~unvisited_mask, 0.0)\n\n    # The sum of these distances over all unvisited nodes, divided by 2 (since each edge is counted twice),\n    # approximates the MST length, which is a lower bound on the tour length.\n    # We use the sum directly as a heuristic.\n    subtour_cost = torch.sum(two_nn_dist_sum, dim=1) / 2.0\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    # [B]\n    min_dist_to_unvisited = torch.min(dist_from_current.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # 3. Cost to connect the start node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    # [B]\n    min_dist_from_start = torch.min(dist_from_start.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # Combine the components\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # Handle edge cases where subtour_cost is not well-defined\n    # If only two unvisited nodes, cost is current->A->B->start or current->B->A->start\n    if torch.any(is_penultimate):\n      # [B_pen, 2]\n      unvisited_indices = unvisited_mask[is_penultimate.squeeze(-1)].long().nonzero(as_tuple=False)[:, 1].view(-1, 2)\n      node_a_idx, node_b_idx = unvisited_indices[:, 0], unvisited_indices[:, 1]\n      \n      current_node_pen = state.current_node_index()[is_penultimate.squeeze(-1)]\n      start_node_pen = state.first_node_index()[is_penultimate.squeeze(-1)]\n      dist_matrix_pen = dist_matrix[is_penultimate.squeeze(-1)]\n\n      dist_curr_a = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_a_idx]\n      dist_curr_b = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_b_idx]\n      dist_a_b = dist_matrix_pen[torch.arange(len(node_a_idx)), node_a_idx, node_b_idx]\n      dist_a_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_a_idx, start_node_pen]\n      dist_b_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_b_idx, start_node_pen]\n      \n      cost1 = dist_curr_a + dist_a_b + dist_b_start\n      cost2 = dist_curr_b + dist_a_b + dist_a_start\n      penultimate_cost = torch.min(cost1, cost2)\n      value[is_penultimate.squeeze(-1)] = penultimate_cost\n\n    # If only one unvisited node, cost is current -> last -> start\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step.squeeze(-1)].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_from_current[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        dist_last_to_start = torch.gather(dist_from_start[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step.squeeze(-1)] = last_step_cost\n    \n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.2396109479522705, "rmse": 0.48950071292314834, "mse_tsp20": 0.2396109479522705, "rmse_tsp20": 0.48950071292314834, "mse_tsp50": 0.24980534642333985, "rmse_tsp50": 0.4998053085185669, "mse_tsp100": 0.41270564431152346, "rmse_tsp100": 0.6424217028646553, "mse_worst": 0.41270564431152346, "rmse_worst": 0.6424217028646553}, "stats_text": "mse=0.239611; rmse=0.489501; mse_tsp100=0.412706; mse_tsp20=0.239611; mse_tsp50=0.249805; mse_worst=0.412706; rmse_tsp100=0.642422; rmse_tsp20=0.489501; rmse_tsp50=0.499805; rmse_worst=0.642422"}
{"score": 0.11230624864292459, "gamma": -0.1, "algorithm": "Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.", "code_hash": "0e7601ed649dfde68fc9175671d4df815cf1f6e8088ee79de00b3b2d9f6dd931", "code": "# THOUGHT: {Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on the geometric properties of unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes using the area of their convex hull.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n    This combines a geometric heuristic for the bulk of the path with connection costs.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n\n    # 1. Approximate sub-tour length using convex hull area of unvisited nodes\n    # A heuristic for tour length is related to the square root of the area of the convex hull.\n    # We use a simplified proxy: the area of the bounding box of unvisited nodes.\n\n    # Mask coordinates of visited nodes to exclude them from min/max calculations\n    # [B, N, 2]\n    masked_coords = coords.clone()\n    # Use a large value for visited nodes so they don't affect min, and a small value for max\n    large_val = torch.finfo(coords.dtype).max\n    small_val = torch.finfo(coords.dtype).min\n    # [B, N, 1]\n    unvisited_mask_exp = unvisited_mask.unsqueeze(-1)\n    masked_coords.masked_fill_(~unvisited_mask_exp, large_val)\n    min_coords, _ = torch.min(masked_coords, dim=1)  # [B, 2]\n\n    masked_coords = coords.clone()\n    masked_coords.masked_fill_(~unvisited_mask_exp, small_val)\n    max_coords, _ = torch.max(masked_coords, dim=1)  # [B, 2]\n\n    # Calculate width and height of the bounding box\n    # [B, 2]\n    span = max_coords - min_coords\n    # Clamp to avoid negative span if only one node is left\n    span = torch.clamp(span, min=0.0)\n    # [B]\n    area = span[:, 0] * span[:, 1]\n    # Heuristic for tour length: k * sqrt(Area * num_unvisited), k is an empirical factor\n    # For a unit square with N points, E[tour_len] ~ beta * sqrt(N), and Area=1.\n    # We use a simplified form: sqrt(Area) as a proxy for the spatial scale.\n    # The sum of two sides of the bounding box is a reasonable perimeter proxy.\n    subtour_cost = span[:, 0] + span[:, 1]\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, torch.finfo(dist_from_current.dtype).max)\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop)\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, torch.finfo(dist_from_start.dtype).max)\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Combine the components\n    # [B]\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n    \n    # Handle edge case where only one unvisited node remains\n    # The cost is just from current -> last_unvisited -> start\n    is_last_step = (num_unvisited.squeeze(-1) == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step]\n\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix[is_last_step, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix[is_last_step, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step] = last_step_cost\n\n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set if num_unvisited=0) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.9090601949462891, "rmse": 0.9534464824762264, "mse_tsp20": 0.9090601949462891, "rmse_tsp20": 0.9534464824762264, "mse_tsp50": 3.432229481640625, "rmse_tsp50": 1.852627723435182, "mse_tsp100": 8.904224048828125, "rmse_tsp100": 2.9839946462465585, "mse_worst": 8.904224048828125, "rmse_worst": 2.9839946462465585}, "stats_text": "mse=0.90906; rmse=0.953446; mse_tsp100=8.90422; mse_tsp20=0.90906; mse_tsp50=3.43223; mse_worst=8.90422; rmse_tsp100=2.98399; rmse_tsp20=0.953446; rmse_tsp50=1.85263; rmse_worst=2.98399"}
{"score": 0.05769675402296268, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.", "code_hash": "df7489edeace72aa540d26fe77201af647d81f86388de9934a7284bd97b03348", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.}\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node = state.current_node_index().unsqueeze(-1).unsqueeze(-1).expand(-1, 1, dist_matrix.size(1))\n    # [B, 1, N]\n    current_distances = torch.gather(dist_matrix, 1, current_node)\n    # [B, N]\n    current_distances_squeezed = current_distances.squeeze(1)\n\n    # [B] -> [B, 1]\n    first_node = state.first_node_index().unsqueeze(-1)\n    # [B, 1]\n    dist_to_start = torch.gather(current_distances_squeezed, 1, first_node)\n\n    # For each unvisited node, find the minimum distance to any other node (including current)\n    # Create a mask that includes unvisited nodes and the current node as potential connection points\n    # [B, N]\n    connect_to_mask = unvisited_mask.clone()\n    # [B, N]\n    connect_to_mask.scatter_(1, state.current_node_index().unsqueeze(-1), True)\n    # [B, 1, N]\n    connect_to_mask_expanded = connect_to_mask.unsqueeze(1)\n\n    # Mask the distance matrix to only consider connections to valid nodes\n    # Set distances to invalid connection points to infinity\n    # [B, N, N]\n    masked_dist = dist_matrix.clone()\n    masked_dist[~connect_to_mask_expanded.expand_as(dist_matrix)] = torch.finfo(dist_matrix.dtype).max\n\n    # Find the minimum distance from each node to a valid connection point\n    # [B, N]\n    min_dist_to_connect, _ = torch.min(masked_dist, dim=2)\n\n    # Sum these minimum distances only for the unvisited nodes\n    # [B, N]\n    min_dist_to_connect.masked_fill_(~unvisited_mask, 0)\n    # [B]\n    sum_min_dists = torch.sum(min_dist_to_connect, dim=1)\n\n    # The total estimated cost is the sum of minimum connection costs for unvisited nodes\n    # plus the cost to return to the start node from the current node.\n    # [B]\n    value = sum_min_dists + dist_to_start.squeeze(1)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 4.035992338867188, "rmse": 2.0089779338925524, "mse_tsp20": 4.035992338867188, "rmse_tsp20": 2.0089779338925524, "mse_tsp50": 8.995781856640624, "rmse_tsp50": 2.9992968937136957, "mse_tsp100": 17.3319975609375, "rmse_tsp100": 4.163171574765745, "mse_worst": 17.3319975609375, "rmse_worst": 4.163171574765745}, "stats_text": "mse=4.03599; rmse=2.00898; mse_tsp100=17.332; mse_tsp20=4.03599; mse_tsp50=8.99578; mse_worst=17.332; rmse_tsp100=4.16317; rmse_tsp20=2.00898; rmse_tsp50=2.9993; rmse_worst=4.16317"}
{"score": 0.030135818936369817, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The algorithm estimates the remaining tour length by summing two components: the average distance from the current node to all unvisited nodes, and the average minimum distance from each unvisited node to another unvisited node, scaled by the number of remaining nodes to visit.", "code_hash": "0c563bef19de3f217d8b84ca5c62a92fac8dbc59fdd898899abbc565e6ea1f92", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The algorithm estimates the remaining tour length by summing two components: the average distance from the current node to all unvisited nodes, and the average minimum distance from each unvisited node to another unvisited node, scaled by the number of remaining nodes to visit.}\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    visited_mask = state.visited_mask()\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # Create a mask for terminal states where no nodes are unvisited\n    is_not_terminal = n_unvisited > 0\n    # Create a safe divisor to avoid division by zero for terminal states\n    safe_n_unvisited = torch.where(is_not_terminal, n_unvisited, torch.ones_like(n_unvisited))\n\n    # Component 1: Average distance from the current node to all unvisited nodes.\n    # [B, N]\n    current_to_all_dists = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    # [B]\n    current_to_unvisited_dists = torch.where(unvisited_mask, current_to_all_dists, torch.tensor(0.0, device=dist_matrix.device))\n    # [B]\n    avg_dist_to_unvisited = current_to_unvisited_dists.sum(dim=1) / safe_n_unvisited\n\n    # Component 2: Average of the minimum distances from each unvisited node to another unvisited node.\n    # This estimates the cost of the next step from any potential unvisited node.\n    # Mask out visited nodes in the distance matrix by setting their distances to a large value.\n    large_value = dist_matrix.max() + 1.0 if dist_matrix.numel() > 0 else 1e9\n    # [B, N, N]\n    unvisited_dist_matrix = dist_matrix.clone()\n    # Mask rows (from) corresponding to visited nodes\n    unvisited_dist_matrix[visited_mask, :] = large_value\n    # Mask columns (to) corresponding to visited nodes\n    unvisited_dist_matrix[:, visited_mask] = large_value\n    # Set diagonal to a large value to ignore self-loops\n    unvisited_dist_matrix.diagonal(dim1=-2, dim2=-1).fill_(large_value)\n\n    # [B, N]\n    min_dists_from_unvisited, _ = unvisited_dist_matrix.min(dim=2)\n    # Set distances from visited nodes to 0 so they don't contribute to the sum\n    min_dists_from_unvisited = torch.where(unvisited_mask, min_dists_from_unvisited, torch.tensor(0.0, device=dist_matrix.device))\n    # [B]\n    avg_min_dist_between_unvisited = min_dists_from_unvisited.sum(dim=1) / safe_n_unvisited\n\n    # Heuristic: The remaining tour length is roughly the number of remaining steps\n    # times the average cost of a step.\n    # We estimate the average step cost using the average minimum distance between unvisited nodes.\n    # We add the cost to get to the next node from the current one.\n    # n_unvisited already includes the step back to the start if it's unvisited.\n    # [B]\n    remaining_tour_length = avg_dist_to_unvisited + (n_unvisited - 1).clamp(min=0) * avg_min_dist_between_unvisited\n\n    # For terminal states, the future cost is zero.\n    # [B]\n    value = torch.where(is_not_terminal, remaining_tour_length, torch.tensor(0.0, device=dist_matrix.device))\n\n    return value.unsqueeze(-1)", "stats": {"mse": 12.401788290039063, "rmse": 3.5216172833002544, "mse_tsp20": 12.401788290039063, "rmse_tsp20": 3.5216172833002544, "mse_tsp50": 23.8361524796875, "rmse_tsp50": 4.8822282289634416, "mse_tsp100": 33.1831035390625, "rmse_tsp100": 5.760477717955561, "mse_worst": 33.1831035390625, "rmse_worst": 5.760477717955561}, "stats_text": "mse=12.4018; rmse=3.52162; mse_tsp100=33.1831; mse_tsp20=12.4018; mse_tsp50=23.8362; mse_worst=33.1831; rmse_tsp100=5.76048; rmse_tsp20=3.52162; rmse_tsp50=4.88223; rmse_worst=5.76048"}
{"score": 0.0162410203458143, "gamma": -0.1, "algorithm": "Estimate the future tour length by calculating the cost of a convex hull around unvisited nodes, plus the costs to connect the current and start nodes to this hull.", "code_hash": "4fd7044f0a2792e1506701c0b8d639b18640f0383c6f3aa38f4a2283890d4310", "code": "# THOUGHT: {Estimate the future tour length by calculating the cost of a convex hull around unvisited nodes, plus the costs to connect the current and start nodes to this hull.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP using a convex hull heuristic.\n    The value is composed of three parts:\n    1. The perimeter of the convex hull of the unvisited nodes, which serves as a lower bound for the sub-tour length.\n    2. The minimum distance from the current node to any unvisited node (cost to enter the sub-tour).\n    3. The minimum distance from the start node to any unvisited node (cost to return from the sub-tour).\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, 1]\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)\n\n    # 1. Calculate the convex hull perimeter for unvisited nodes\n    # For stability, replace coordinates of visited nodes with a far-away point\n    # so they don't interfere with the convex hull of unvisited nodes.\n    # A large value like 1e9 should be outside any practical TSP coordinate range.\n    large_val = torch.full_like(coords, 1e9)\n    # [B, N, 2]\n    unvisited_coords = torch.where(unvisited_mask.unsqueeze(-1), coords, large_val)\n\n    # Find the min/max x/y coordinates among unvisited nodes to approximate the hull size\n    # This avoids complex hull algorithms and is differentiable.\n    # [B, 1]\n    min_x = torch.min(unvisited_coords[..., 0], dim=1, keepdim=True).values\n    max_x = torch.max(unvisited_coords[..., 0].masked_fill_(~unvisited_mask, -1e9), dim=1, keepdim=True).values\n    min_y = torch.min(unvisited_coords[..., 1], dim=1, keepdim=True).values\n    max_y = torch.max(unvisited_coords[..., 1].masked_fill_(~unvisited_mask, -1e9), dim=1, keepdim=True).values\n\n    # Approximate perimeter of the bounding box as a proxy for convex hull perimeter\n    # [B, 1]\n    hull_perimeter = 2 * ((max_x - min_x) + (max_y - min_y))\n    # Handle cases with 0 or 1 unvisited nodes where hull is undefined or zero\n    hull_perimeter = hull_perimeter.masked_fill(num_unvisited <= 1, 0.0)\n\n    # 2. Calculate connection costs to the unvisited set\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(-1, 1, 1).expand(-1, 1, dist_matrix.size(1))\n    start_node_idx = state.first_node_index().view(-1, 1, 1).expand(-1, 1, dist_matrix.size(1))\n\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n\n    # Find minimum distance to any unvisited node\n    # [B, 1]\n    min_dist_to_unvisited = torch.min(dist_from_current.masked_fill(~unvisited_mask, float('inf')), dim=1, keepdim=True).values\n    min_dist_from_unvisited_to_start = torch.min(dist_from_start.masked_fill(~unvisited_mask, float('inf')), dim=1, keepdim=True).values\n\n    # Handle terminal states where no unvisited nodes exist\n    min_dist_to_unvisited = min_dist_to_unvisited.nan_to_num(posinf=0.0)\n    min_dist_from_unvisited_to_start = min_dist_from_unvisited_to_start.nan_to_num(posinf=0.0)\n\n    # Total estimated future cost\n    value = hull_perimeter + min_dist_to_unvisited + min_dist_from_unvisited_to_start\n\n    # Special case for the last step: cost is simply from current to last, then to start\n    is_last_step = (num_unvisited == 1)\n    if is_last_step.any():\n        # [B, 1]\n        last_unvisited_idx = unvisited_mask.long().argmax(dim=1, keepdim=True)\n        # [B, 1]\n        dist_curr_to_last = torch.gather(dist_from_current, 1, last_unvisited_idx)\n        dist_last_to_start = torch.gather(dist_from_start, 1, last_unvisited_idx)\n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value = torch.where(is_last_step, last_step_cost, value)\n\n    # If the tour is done, future cost is zero.\n    is_done = (num_unvisited == 0)\n    value = value.masked_fill(is_done, 0.0)\n\n    return -value", "stats": {"mse": 28.49783874609375, "rmse": 5.338336702203576, "mse_tsp20": 28.49783874609375, "rmse_tsp20": 5.338336702203576, "mse_tsp50": 42.679790340625, "rmse_tsp50": 6.532977142208979, "mse_tsp100": 61.57248613125, "rmse_tsp100": 7.846813756630777, "mse_worst": 61.57248613125, "rmse_worst": 7.846813756630777}, "stats_text": "mse=28.4978; rmse=5.33834; mse_tsp100=61.5725; mse_tsp20=28.4978; mse_tsp50=42.6798; mse_worst=61.5725; rmse_tsp100=7.84681; rmse_tsp20=5.33834; rmse_tsp50=6.53298; rmse_worst=7.84681"}
{"score": 0.013692846885730149, "gamma": 0.1, "algorithm": "auto", "code_hash": "c56b73843f678df98a303431c2ce030b166c3f27684f9e1488fd86edf87774e0", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP.\n    The value is composed of three main parts:\n    1. The expected distance from the current node to the next unvisited node.\n    2. The expected total distance for the tour among the remaining unvisited nodes.\n    3. The expected distance from the last unvisited node back to the start node.\n    This provides a heuristic for the remaining path length.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # Get batch size and number of nodes\n    B, N, _ = state.all_node_coords().shape\n    device = state.all_node_coords().device\n\n    # Get masks for visited and unvisited nodes\n    unvisited_mask = state.unvisited_mask()  # [B, N]\n    visited_mask = state.visited_mask()      # [B, N]\n\n    # Count the number of unvisited nodes\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited <= 1) # If 0 or 1 unvisited, the tour is effectively done or in the last step.\n\n    # 1. Distance from the current node to all unvisited nodes\n    dist_matrix = state.distance_matrix()  # [B, N, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N) # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1) # [B, N]\n\n    # Mask out distances to already visited nodes\n    dist_from_current_to_unvisited = dist_from_current.masked_fill(visited_mask, float('inf'))\n    \n    # Heuristic for the next step: average distance to an unvisited node\n    # Use a small epsilon to avoid division by zero\n    avg_dist_to_next = dist_from_current_to_unvisited.nan_to_num(posinf=0.0).sum(dim=1, keepdim=True) / torch.clamp(num_unvisited, min=1.0)\n\n    # 2. Heuristic for the tour among remaining unvisited nodes\n    # For each unvisited node, find its minimum distance to another unvisited node\n    unvisited_to_unvisited_mask = unvisited_mask.unsqueeze(2) & unvisited_mask.unsqueeze(1) # [B, N, N]\n    dist_unvisited = dist_matrix.masked_fill(~unvisited_to_unvisited_mask, float('inf'))\n    \n    # Set diagonal to infinity to find min distance to *another* unvisited node\n    dist_unvisited.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n    \n    # Find the minimum distance from each unvisited node to any other unvisited node\n    min_dist_per_unvisited_node, _ = torch.min(dist_unvisited, dim=2) # [B, N]\n    \n    # Sum these minimum distances and average them to get a per-node cost estimate\n    total_min_dist = min_dist_per_unvisited_node.nan_to_num(posinf=0.0).sum(dim=1, keepdim=True) # [B, 1]\n    avg_min_dist_unvisited = total_min_dist / torch.clamp(num_unvisited, min=1.0)\n    \n    # Scale by the number of remaining steps (num_unvisited - 1)\n    # This approximates a nearest-neighbor heuristic for the remaining sub-tour\n    remaining_subtour_cost = avg_min_dist_unvisited * torch.clamp(num_unvisited - 1, min=0.0)\n\n    # 3. Heuristic for returning to the start node from the last unvisited node\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N) # [B, 1, N]\n    dist_to_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1) # [B, N]\n    \n    # Average distance from any unvisited node back to the start\n    dist_unvisited_to_start = dist_to_start.masked_fill(visited_mask, 0.0)\n    avg_dist_to_start = dist_unvisited_to_start.sum(dim=1, keepdim=True) / torch.clamp(num_unvisited, min=1.0)\n    \n    # Combine the components\n    # The total estimated future cost is the sum of the three parts.\n    # We use num_unvisited > 1 as a condition for adding the subtour and start-return costs.\n    # When num_unvisited == 1, the only remaining action is to return to start.\n    # When num_unvisited == 0, the tour is done, cost is 0.\n    \n    # If only one node left, cost is just dist from current to it, plus dist from it to start\n    last_step_mask = (num_unvisited == 1.0)\n    last_unvisited_idx = unvisited_mask.long().argmax(dim=1, keepdim=True) # [B, 1]\n    last_unvisited_idx_exp = last_unvisited_idx.unsqueeze(2) # [B, 1, 1]\n    \n    dist_curr_to_last = torch.gather(dist_from_current, 1, last_unvisited_idx) # [B, 1]\n    dist_last_to_start = torch.gather(dist_to_start, 1, last_unvisited_idx) # [B, 1]\n    last_step_cost = dist_curr_to_last + dist_last_to_start\n    \n    # Calculate the full heuristic\n    value = avg_dist_to_next + remaining_subtour_cost + avg_dist_to_start\n    \n    # Apply special case for the last step\n    value = torch.where(last_step_mask, last_step_cost, value)\n\n    # If the episode is done (or about to be), the future cost is 0.\n    # This ensures terminal consistency.\n    value = value.masked_fill(is_done, 0.0)\n    \n    # Return as a negative value because the environment uses negative rewards (path length)\n    return -value", "stats": {"mse": 22.51568820703125, "rmse": 4.745069884314798, "mse_tsp20": 22.51568820703125, "rmse_tsp20": 4.745069884314798, "mse_tsp50": 42.503790928125, "rmse_tsp50": 6.519493149634027, "mse_tsp100": 73.0308319625, "rmse_tsp100": 8.545807858973896, "mse_worst": 73.0308319625, "rmse_worst": 8.545807858973896}, "stats_text": "mse=22.5157; rmse=4.74507; mse_tsp100=73.0308; mse_tsp20=22.5157; mse_tsp50=42.5038; mse_worst=73.0308; rmse_tsp100=8.54581; rmse_tsp20=4.74507; rmse_tsp50=6.51949; rmse_worst=8.54581"}
{"score": 0.013379277095224842, "gamma": 0.1, "algorithm": "Estimate the future tour length by summing, for each unvisited node, half the distance to its two nearest unvisited neighbors, plus the costs to connect the current and start nodes into this estimated sub-tour.", "code_hash": "6a5852e5d396822bcba2058559cc394425eefcabcf728af2a303c083fd70961e", "code": "# THOUGHT: {Estimate the future tour length by summing, for each unvisited node, half the distance to its two nearest unvisited neighbors, plus the costs to connect the current and start nodes into this estimated sub-tour.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP using a nearest-neighbor heuristic on the unvisited subgraph.\n    The value is composed of three parts:\n    1. An estimation of the sub-tour length through unvisited nodes. For each unvisited node, we find its two nearest\n       unvisited neighbors and add half the distance to each (approximating one incoming and one outgoing edge).\n    2. The minimum distance from the current node to any unvisited node (cost to enter the sub-tour).\n    3. The minimum distance from the start node to any unvisited node (cost to return from the sub-tour).\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, 1]\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)\n\n    # 1. Estimate the sub-tour length through unvisited nodes\n    # Create a distance matrix masked to only show distances between unvisited nodes\n    # [B, N, 1]\n    unvisited_from = unvisited_mask.unsqueeze(-1)\n    # [B, 1, N]\n    unvisited_to = unvisited_mask.unsqueeze(-2)\n    # [B, N, N]\n    unvisited_dist = dist_matrix.masked_fill(~(unvisited_from & unvisited_to), float('inf'))\n    # Set diagonal to infinity to avoid picking a node as its own neighbor\n    unvisited_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n\n    # Find the two nearest unvisited neighbors for each unvisited node\n    # [B, N, 2]\n    k_smallest_dists, _ = torch.topk(unvisited_dist, k=2, dim=-1, largest=False)\n\n    # Sum of distances to the two nearest unvisited neighbors, for unvisited nodes only\n    # [B, N]\n    sum_2_nn_dists = k_smallest_dists.sum(dim=-1)\n    # Zero out distances for nodes that are already visited\n    sum_2_nn_dists.masked_fill_(~unvisited_mask, 0.0)\n    # We take the sum over all nodes and divide by 2, as each edge (i,j) is counted twice (once for i, once for j).\n    # This is equivalent to summing (d1+d2)/2 for each node.\n    # [B, 1]\n    subtour_estimate = sum_2_nn_dists.sum(dim=-1, keepdim=True) * 0.5\n    # Handle cases with < 2 unvisited nodes where topk(2) is not meaningful\n    subtour_estimate = subtour_estimate.masked_fill(num_unvisited < 2, 0.0)\n\n    # 2. & 3. Calculate connection costs from current and start nodes to the unvisited set\n    # [B] -> [B, 1]\n    current_node_idx = state.current_node_index().unsqueeze(-1)\n    start_node_idx = state.first_node_index().unsqueeze(-1)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx.unsqueeze(-1).expand(-1, -1, dist_matrix.size(-1))).squeeze(1)\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx.unsqueeze(-1).expand(-1, -1, dist_matrix.size(-1))).squeeze(1)\n\n    # Find minimum distance to any unvisited node\n    # [B, 1]\n    min_dist_to_unvisited = torch.min(dist_from_current.masked_fill(~unvisited_mask, float('inf')), dim=1, keepdim=True).values\n    min_dist_from_unvisited_to_start = torch.min(dist_from_start.masked_fill(~unvisited_mask, float('inf')), dim=1, keepdim=True).values\n    \n    # Handle terminal states where no unvisited nodes exist\n    min_dist_to_unvisited = min_dist_to_unvisited.nan_to_num(posinf=0.0)\n    min_dist_from_unvisited_to_start = min_dist_from_unvisited_to_start.nan_to_num(posinf=0.0)\n\n    # Total estimated future cost\n    value = subtour_estimate + min_dist_to_unvisited + min_dist_from_unvisited_to_start\n\n    # If the tour is done (num_unvisited == 0), future cost is zero.\n    # This is handled naturally by the components becoming 0.\n    # If only one node is left, subtour_estimate is 0, and the cost is curr->last + last->start.\n    # This is also handled naturally.\n\n    return -value", "stats": {"mse": 21.7091130703125, "rmse": 4.6593039255142505, "mse_tsp20": 21.7091130703125, "rmse_tsp20": 4.6593039255142505, "mse_tsp50": 41.8858065, "rmse_tsp50": 6.471924481945073, "mse_tsp100": 74.7424537875, "rmse_tsp100": 8.645371813143724, "mse_worst": 74.7424537875, "rmse_worst": 8.645371813143724}, "stats_text": "mse=21.7091; rmse=4.6593; mse_tsp100=74.7425; mse_tsp20=21.7091; mse_tsp50=41.8858; mse_worst=74.7425; rmse_tsp100=8.64537; rmse_tsp20=4.6593; rmse_tsp50=6.47192; rmse_worst=8.64537"}
{"score": 0.01237136463050766, "gamma": 0.1, "algorithm": "auto", "code_hash": "c07ac942e284504a00f1c059c1e12455fbe237ea11bed1e024492af1fe9e495e", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP.\n    It's the sum of two components:\n    1. A cost related to the remaining sub-tour of unvisited nodes.\n    2. A cost for connecting the current partial tour to the remaining sub-tour.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    num_unvisited = unvisited_mask.float().sum(dim=1)\n\n    # Handle terminal state: if no nodes are unvisited, the future cost is zero.\n    is_terminal = (num_unvisited == 0)\n\n    # 1. Estimate the cost of the sub-tour connecting the unvisited nodes.\n    # For each unvisited node, find the minimum distance to another unvisited node.\n    # [B, N, N], set distances to/from visited nodes to infinity\n    unvisited_dist = dist_matrix.clone()\n    unvisited_dist_mask = ~(unvisited_mask.unsqueeze(2) & unvisited_mask.unsqueeze(1))\n    unvisited_dist[unvisited_dist_mask] = float('inf')\n\n    # Set diagonal to infinity to find min distance to *another* unvisited node\n    unvisited_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n\n    # [B, N], min distance from each unvisited node to any other unvisited node\n    min_dist_per_node, _ = torch.min(unvisited_dist, dim=2)\n    # Zero out distances for visited nodes\n    min_dist_per_node[~unvisited_mask] = 0.0\n    # [B], sum of these minimum distances\n    subtour_cost = min_dist_per_node.sum(dim=1)\n\n    # 2. Estimate the cost to connect the current path to the unvisited sub-tour.\n    # Find the distance from the current node to the nearest unvisited node.\n    # [B]\n    current_node = state.current_node_index()\n    # [B, N], distances from the current node\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n\n    # [B, N], set distances to visited nodes to infinity\n    dist_from_current_to_unvisited = dist_from_current.clone()\n    dist_from_current_to_unvisited[~unvisited_mask] = float('inf')\n    # [B], min distance to an unvisited node\n    connection_cost, _ = torch.min(dist_from_current_to_unvisited, dim=1)\n    # If terminal, connection_cost is inf; set to 0.\n    connection_cost = torch.nan_to_num(connection_cost, posinf=0.0)\n\n    # Scaling factor to account for the increasing complexity/length with more nodes\n    # Use log1p to handle num_unvisited=0 gracefully (log1p(0)=0) and smooth the scaling\n    scaling_factor = torch.log1p(num_unvisited)\n\n    # Combine the components\n    # The heuristic is a scaled sum of the sub-tour cost and the connection cost.\n    value = (subtour_cost + connection_cost) * scaling_factor\n\n    # Ensure terminal state has a value of 0\n    value[is_terminal] = 0.0\n\n    # The value represents a cost-to-go, so it should be negative for reward shaping.\n    # We return a negative value as V(s) is typically negated in shaping: r' = r + gamma*V(s') - V(s).\n    # Since tour length is a cost (negative reward), V(s) should be positive.\n    return value.unsqueeze(-1)", "stats": {"mse": 5.878291572265625, "rmse": 2.4245188331431096, "mse_tsp20": 5.878291572265625, "rmse_tsp20": 2.4245188331431096, "mse_tsp50": 26.82017915625, "rmse_tsp50": 5.178820247532251, "mse_tsp100": 80.83182655, "rmse_tsp100": 8.99065217601037, "mse_worst": 80.83182655, "rmse_worst": 8.99065217601037}, "stats_text": "mse=5.87829; rmse=2.42452; mse_tsp100=80.8318; mse_tsp20=5.87829; mse_tsp50=26.8202; mse_worst=80.8318; rmse_tsp100=8.99065; rmse_tsp20=2.42452; rmse_tsp50=5.17882; rmse_worst=8.99065"}
{"score": 0.003069790601467315, "gamma": -0.1, "algorithm": "Estimate future tour length by summing the minimum cost to connect each unvisited node to the convex hull of the current tour and adding the cost to return to the start from the current node.", "code_hash": "a610a2e6373c687890e46243aea5f2e1110d3d54cda996b0f647293c35dfc5b9", "code": "# THOUGHT: {Estimate future tour length by summing the minimum cost to connect each unvisited node to the convex hull of the current tour and adding the cost to return to the start from the current node.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length by combining geometric and graph-based heuristics.\n    The value is composed of three main parts:\n    1. For each unvisited node, find the minimum distance to the convex hull of the already visited nodes.\n       This estimates the cost of inserting each remaining node into the existing tour.\n    2. Sum these minimum insertion costs over all unvisited nodes.\n    3. Add the direct distance from the current node back to the starting node to account for closing the tour.\n    This approach models the expansion of the current tour to include all remaining nodes.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, N]\n    visited_mask = ~unvisited_mask\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal states where no nodes are unvisited\n    is_done = torch.all(~unvisited_mask, dim=1)\n\n    # 1. For each unvisited node, find its minimum connection cost to the set of visited nodes.\n    # We can represent the connection cost as the minimum distance from an unvisited node\n    # to any of the already visited nodes.\n\n    # [B, N, N] -> [B, N, N]\n    # Create a distance matrix where rows are unvisited nodes and columns are visited nodes.\n    # Distances to unvisited columns are set to infinity.\n    masked_dist = dist_matrix.clone()\n    # [B, 1, N]\n    visited_mask_exp = visited_mask.unsqueeze(1)\n    # Set distances to non-visited nodes to infinity, so min finds the closest visited node.\n    masked_dist.masked_fill_(~visited_mask_exp.expand_as(dist_matrix), torch.finfo(dist_matrix.dtype).max)\n\n    # [B, N]\n    # For each node (row index), find the minimum distance to any visited node (column index).\n    min_dist_to_visited, _ = torch.min(masked_dist, dim=2)\n\n    # 2. Sum these minimum connection costs, but only for the nodes that are currently unvisited.\n    # For nodes already visited, their future connection cost is zero.\n    min_dist_to_visited.masked_fill_(visited_mask, 0)\n    # [B]\n    sum_of_min_dists = torch.sum(min_dist_to_visited, dim=1)\n\n    # 3. Add the cost to return to the start from the current location.\n    # This is the cost of closing the final loop.\n    # [B]\n    current_node_idx = state.current_node_index()\n    # [B]\n    start_node_idx = state.first_node_index()\n    # [B]\n    dist_to_start = dist_matrix[torch.arange(B, device=device), current_node_idx, start_node_idx]\n\n    # Total estimated future cost\n    # [B]\n    value = sum_of_min_dists + dist_to_start\n\n    # If the tour is done, the future cost is zero.\n    value.masked_fill_(is_done, 0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 8.908200888671875, "rmse": 2.9846609336190726, "mse_tsp20": 8.908200888671875, "rmse_tsp20": 2.9846609336190726, "mse_tsp50": 51.9263250625, "rmse_tsp50": 7.2059923024174815, "mse_tsp100": 325.755118125, "rmse_tsp100": 18.04868743496324, "mse_worst": 325.755118125, "rmse_worst": 18.04868743496324}, "stats_text": "mse=8.9082; rmse=2.98466; mse_tsp100=325.755; mse_tsp20=8.9082; mse_tsp50=51.9263; mse_worst=325.755; rmse_tsp100=18.0487; rmse_tsp20=2.98466; rmse_tsp50=7.20599; rmse_worst=18.0487"}
{"score": 3.4209696471518978, "gamma": -0.1, "algorithm": "Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.", "code_hash": "d5014fe6247751116f6de4174accdec9f7c2eafdcfcbe2f724c5ad25941cb364", "code": "# THOUGHT: {Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length using a Minimum Spanning Tree (MST) based heuristic.\n    The cost is the sum of three components:\n    1. The cost of the MST of the subgraph formed by the unvisited nodes. This provides a\n       tight lower bound on the optimal sub-tour length for these nodes.\n    2. The minimum cost to connect the current node to the set of unvisited nodes.\n    3. The minimum cost to connect the start node to the set of unvisited nodes,\n       which is necessary for closing the tour.\n    \n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n    \n    # 1. Calculate the cost of the MST on the unvisited nodes.\n    # Prim's algorithm for dense graphs.\n    # We will compute this only for batches where there are unvisited nodes.\n    # [B, N]\n    min_cost = torch.full((B, N), float('inf'), device=device)\n    # [B, N]\n    visited_in_mst = torch.zeros_like(unvisited_mask)\n    # [B]\n    mst_cost = torch.zeros(B, device=device)\n    \n    # Initialize Prim's: pick the first unvisited node as the starting point for the MST.\n    # Find the index of the first 'True' in unvisited_mask for each batch item.\n    first_unvisited_idx = torch.argmax(unvisited_mask.int(), dim=1)\n    \n    # Set the min_cost for the starting node of the MST to 0.\n    # This ensures it's the first one picked.\n    min_cost.scatter_(1, first_unvisited_idx.unsqueeze(1), 0)\n    \n    # Mask min_cost for nodes that are already visited in the main tour.\n    min_cost.masked_fill_(~unvisited_mask, float('inf'))\n\n    # Prim's algorithm loop executed in a parallelized way over N-1 steps.\n    # This is a fixed-iteration loop, avoiding dynamic Python loops.\n    for _ in range(N):\n        # Find the node `u` with the minimum cost that is unvisited in the MST.\n        # [B, 1]\n        u_idx = torch.argmin(min_cost, dim=1, keepdim=True)\n        # [B]\n        u_cost = torch.gather(min_cost, 1, u_idx).squeeze(1)\n        \n        # Add its cost to the total MST cost, handling inf for disconnected components.\n        mst_cost += torch.where(u_cost == float('inf'), 0, u_cost)\n        \n        # Mark `u` as visited in the MST and remove it from consideration.\n        visited_in_mst.scatter_(1, u_idx, True)\n        min_cost.scatter_(1, u_idx, float('inf'))\n\n        # Update min_costs for neighbors of `u`.\n        # [B, N]\n        dist_from_u = torch.gather(dist_matrix, 1, u_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        \n        # Update only if the new path through `u` is shorter and the neighbor is unvisited in MST.\n        # We also need to ensure the neighbor is part of the unvisited set for the main tour.\n        update_mask = (dist_from_u < min_cost) & ~visited_in_mst & unvisited_mask\n        min_cost[update_mask] = dist_from_u[update_mask]\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    # Mask distances to already visited nodes.\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop).\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Total estimated cost\n    # For the case with only one unvisited node, MST cost is 0. The formula becomes\n    # dist(current -> last) + dist(start -> last), which is correct.\n    value = mst_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # For terminal states, future cost is 0.\n    value.masked_fill_(is_terminal, 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0.\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.18682559706115723, "rmse": 0.4322332669533399, "mse_tsp20": 0.18682559706115723, "rmse_tsp20": 0.4322332669533399, "mse_tsp50": 0.19572340977783204, "rmse_tsp50": 0.4424063853266949, "mse_tsp100": 0.2923147829833984, "rmse_tsp100": 0.5406614310114958, "mse_worst": 0.2923147829833984, "rmse_worst": 0.5406614310114958}, "stats_text": "mse=0.186826; rmse=0.432233; mse_tsp100=0.292315; mse_tsp20=0.186826; mse_tsp50=0.195723; mse_worst=0.292315; rmse_tsp100=0.540661; rmse_tsp20=0.432233; rmse_tsp50=0.442406; rmse_worst=0.540661"}
{"score": 2.423034464838014, "gamma": -0.1, "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.", "code_hash": "1b3b0812ca98a6aa6a8fb459b2e47dca3884b0f5419dcd0d7504221710b3f7b9", "code": "# THOUGHT: {Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length by approximating a path through unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes. For each unvisited node,\n       we find the distance to its two nearest neighbors among the other unvisited nodes.\n       The sum of these distances, averaged over all unvisited nodes, provides an estimate\n       of the local path cost. This is scaled by the number of unvisited nodes.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n    is_last_step = (num_unvisited == 1)\n    is_penultimate = (num_unvisited == 2)\n\n    # 1. Approximate sub-tour length through unvisited nodes\n    # Create a distance matrix only considering unvisited nodes.\n    # We set distances to/from visited nodes to infinity.\n    unvisited_dist = dist_matrix.clone()\n    inf = torch.finfo(dist_matrix.dtype).max\n    # Mask rows (from) and columns (to) corresponding to visited nodes\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), inf)\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), inf)\n\n    # For each unvisited node, find the distances to its two nearest unvisited neighbors.\n    # We use k=3 because the node itself is included with distance 0.\n    # [B, N, 3]\n    k = min(3, N) # handle N < 3 case\n    topk_dists, _ = torch.topk(unvisited_dist, k, dim=2, largest=False)\n\n    # The first value (k=0) is always 0 (distance to self), so we take k=1 and k=2.\n    # Sum of distances to two nearest neighbors for each node.\n    # If less than 3 unvisited nodes, some of these will be inf.\n    if k > 2:\n        two_nn_dist_sum = topk_dists[:, :, 1] + topk_dists[:, :, 2] # [B, N]\n    elif k > 1:\n        two_nn_dist_sum = topk_dists[:, :, 1] # [B, N]\n    else:\n        two_nn_dist_sum = torch.zeros_like(unvisited_mask, dtype=dist_matrix.dtype)\n\n\n    # Mask out the sums for visited nodes\n    two_nn_dist_sum.masked_fill_(~unvisited_mask, 0.0)\n\n    # The sum of these distances over all unvisited nodes, divided by 2 (since each edge is counted twice),\n    # approximates the MST length, which is a lower bound on the tour length.\n    # We use the sum directly as a heuristic.\n    subtour_cost = torch.sum(two_nn_dist_sum, dim=1) / 2.0\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    # [B]\n    min_dist_to_unvisited = torch.min(dist_from_current.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # 3. Cost to connect the start node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    # [B]\n    min_dist_from_start = torch.min(dist_from_start.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # Combine the components\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # Handle edge cases where subtour_cost is not well-defined\n    # If only two unvisited nodes, cost is current->A->B->start or current->B->A->start\n    if torch.any(is_penultimate):\n      # [B_pen, 2]\n      unvisited_indices = unvisited_mask[is_penultimate.squeeze(-1)].long().nonzero(as_tuple=False)[:, 1].view(-1, 2)\n      node_a_idx, node_b_idx = unvisited_indices[:, 0], unvisited_indices[:, 1]\n      \n      current_node_pen = state.current_node_index()[is_penultimate.squeeze(-1)]\n      start_node_pen = state.first_node_index()[is_penultimate.squeeze(-1)]\n      dist_matrix_pen = dist_matrix[is_penultimate.squeeze(-1)]\n\n      dist_curr_a = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_a_idx]\n      dist_curr_b = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_b_idx]\n      dist_a_b = dist_matrix_pen[torch.arange(len(node_a_idx)), node_a_idx, node_b_idx]\n      dist_a_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_a_idx, start_node_pen]\n      dist_b_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_b_idx, start_node_pen]\n      \n      cost1 = dist_curr_a + dist_a_b + dist_b_start\n      cost2 = dist_curr_b + dist_a_b + dist_a_start\n      penultimate_cost = torch.min(cost1, cost2)\n      value[is_penultimate.squeeze(-1)] = penultimate_cost\n\n    # If only one unvisited node, cost is current -> last -> start\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step.squeeze(-1)].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_from_current[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        dist_last_to_start = torch.gather(dist_from_start[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step.squeeze(-1)] = last_step_cost\n    \n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.2396109479522705, "rmse": 0.48950071292314834, "mse_tsp20": 0.2396109479522705, "rmse_tsp20": 0.48950071292314834, "mse_tsp50": 0.24980534642333985, "rmse_tsp50": 0.4998053085185669, "mse_tsp100": 0.41270564431152346, "rmse_tsp100": 0.6424217028646553, "mse_worst": 0.41270564431152346, "rmse_worst": 0.6424217028646553}, "stats_text": "mse=0.239611; rmse=0.489501; mse_tsp100=0.412706; mse_tsp20=0.239611; mse_tsp50=0.249805; mse_worst=0.412706; rmse_tsp100=0.642422; rmse_tsp20=0.489501; rmse_tsp50=0.499805; rmse_worst=0.642422"}
{"score": 0.11230624864292459, "gamma": -0.1, "algorithm": "Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.", "code_hash": "0e7601ed649dfde68fc9175671d4df815cf1f6e8088ee79de00b3b2d9f6dd931", "code": "# THOUGHT: {Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on the geometric properties of unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes using the area of their convex hull.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n    This combines a geometric heuristic for the bulk of the path with connection costs.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n\n    # 1. Approximate sub-tour length using convex hull area of unvisited nodes\n    # A heuristic for tour length is related to the square root of the area of the convex hull.\n    # We use a simplified proxy: the area of the bounding box of unvisited nodes.\n\n    # Mask coordinates of visited nodes to exclude them from min/max calculations\n    # [B, N, 2]\n    masked_coords = coords.clone()\n    # Use a large value for visited nodes so they don't affect min, and a small value for max\n    large_val = torch.finfo(coords.dtype).max\n    small_val = torch.finfo(coords.dtype).min\n    # [B, N, 1]\n    unvisited_mask_exp = unvisited_mask.unsqueeze(-1)\n    masked_coords.masked_fill_(~unvisited_mask_exp, large_val)\n    min_coords, _ = torch.min(masked_coords, dim=1)  # [B, 2]\n\n    masked_coords = coords.clone()\n    masked_coords.masked_fill_(~unvisited_mask_exp, small_val)\n    max_coords, _ = torch.max(masked_coords, dim=1)  # [B, 2]\n\n    # Calculate width and height of the bounding box\n    # [B, 2]\n    span = max_coords - min_coords\n    # Clamp to avoid negative span if only one node is left\n    span = torch.clamp(span, min=0.0)\n    # [B]\n    area = span[:, 0] * span[:, 1]\n    # Heuristic for tour length: k * sqrt(Area * num_unvisited), k is an empirical factor\n    # For a unit square with N points, E[tour_len] ~ beta * sqrt(N), and Area=1.\n    # We use a simplified form: sqrt(Area) as a proxy for the spatial scale.\n    # The sum of two sides of the bounding box is a reasonable perimeter proxy.\n    subtour_cost = span[:, 0] + span[:, 1]\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, torch.finfo(dist_from_current.dtype).max)\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop)\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, torch.finfo(dist_from_start.dtype).max)\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Combine the components\n    # [B]\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n    \n    # Handle edge case where only one unvisited node remains\n    # The cost is just from current -> last_unvisited -> start\n    is_last_step = (num_unvisited.squeeze(-1) == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step]\n\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix[is_last_step, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix[is_last_step, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step] = last_step_cost\n\n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set if num_unvisited=0) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.9090601949462891, "rmse": 0.9534464824762264, "mse_tsp20": 0.9090601949462891, "rmse_tsp20": 0.9534464824762264, "mse_tsp50": 3.432229481640625, "rmse_tsp50": 1.852627723435182, "mse_tsp100": 8.904224048828125, "rmse_tsp100": 2.9839946462465585, "mse_worst": 8.904224048828125, "rmse_worst": 2.9839946462465585}, "stats_text": "mse=0.90906; rmse=0.953446; mse_tsp100=8.90422; mse_tsp20=0.90906; mse_tsp50=3.43223; mse_worst=8.90422; rmse_tsp100=2.98399; rmse_tsp20=0.953446; rmse_tsp50=1.85263; rmse_worst=2.98399"}
{"score": 0.07782706118698951, "gamma": -0.1, "algorithm": "Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.", "code_hash": "5fd3309104022111fb964be45f064a888499b1e8ed8f66c21cadfee07bffcee5", "code": "# THOUGHT: {Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length by averaging connection costs to the unvisited set.\n    The value is the sum of two components:\n    1. The average distance from the current node to all unvisited nodes.\n    2. The average distance from the start node to all unvisited nodes (to close the tour).\n    This heuristic focuses on the expected cost of the next and final connections.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N = unvisited_mask.shape\n    device = unvisited_mask.device\n    \n    # [B, 1]\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)\n    is_done = (num_unvisited == 0)\n\n    # Use a small epsilon to avoid division by zero when no nodes are unvisited\n    # The result for this case will be masked out later anyway.\n    num_unvisited_safe = num_unvisited.clamp(min=1.0)\n\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n\n    # 1. Average distance from the current node to the unvisited set\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    \n    # Mask out distances to already visited nodes\n    dist_from_current_unvisited = dist_from_current.masked_fill(~unvisited_mask, 0.0)\n    \n    # [B, 1]\n    sum_dist_from_current = dist_from_current_unvisited.sum(dim=1, keepdim=True)\n    avg_dist_from_current = sum_dist_from_current / num_unvisited_safe\n\n    # 2. Average distance from the start node to the unvisited set (for closing the loop)\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n\n    # Mask out distances to already visited nodes\n    dist_from_start_unvisited = dist_from_start.masked_fill(~unvisited_mask, 0.0)\n\n    # [B, 1]\n    sum_dist_from_start = dist_from_start_unvisited.sum(dim=1, keepdim=True)\n    avg_dist_from_start = sum_dist_from_start / num_unvisited_safe\n\n    # Combine the components\n    # [B, 1]\n    value = avg_dist_from_current + avg_dist_from_start\n    \n    # Handle the special case where only one unvisited node remains.\n    # The cost is exactly current -> last -> start.\n    is_last_step = (num_unvisited == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step.squeeze(-1)].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step.squeeze(-1)]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step.squeeze(-1)]\n        \n        # [B_last, N, N]\n        dist_matrix_last = dist_matrix[is_last_step.squeeze(-1)]\n        \n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix_last[:, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix_last[:, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = (dist_curr_to_last + dist_last_to_start).unsqueeze(-1)\n        value = torch.where(is_last_step, last_step_cost, value)\n\n    # If the tour is done, the future cost is zero.\n    value.masked_fill_(is_done, 0.0)\n\n    return value", "stats": {"mse": 1.5873716700439453, "rmse": 1.2599093896165492, "mse_tsp20": 1.5873716700439453, "rmse_tsp20": 1.2599093896165492, "mse_tsp50": 4.672369123242188, "rmse_tsp50": 2.161566358741315, "mse_tsp100": 12.849001166796874, "rmse_tsp100": 3.58455034373865, "mse_worst": 12.849001166796874, "rmse_worst": 3.58455034373865}, "stats_text": "mse=1.58737; rmse=1.25991; mse_tsp100=12.849; mse_tsp20=1.58737; mse_tsp50=4.67237; mse_worst=12.849; rmse_tsp100=3.58455; rmse_tsp20=1.25991; rmse_tsp50=2.16157; rmse_worst=3.58455"}
{"score": 0.05769675402296268, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.", "code_hash": "df7489edeace72aa540d26fe77201af647d81f86388de9934a7284bd97b03348", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.}\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node = state.current_node_index().unsqueeze(-1).unsqueeze(-1).expand(-1, 1, dist_matrix.size(1))\n    # [B, 1, N]\n    current_distances = torch.gather(dist_matrix, 1, current_node)\n    # [B, N]\n    current_distances_squeezed = current_distances.squeeze(1)\n\n    # [B] -> [B, 1]\n    first_node = state.first_node_index().unsqueeze(-1)\n    # [B, 1]\n    dist_to_start = torch.gather(current_distances_squeezed, 1, first_node)\n\n    # For each unvisited node, find the minimum distance to any other node (including current)\n    # Create a mask that includes unvisited nodes and the current node as potential connection points\n    # [B, N]\n    connect_to_mask = unvisited_mask.clone()\n    # [B, N]\n    connect_to_mask.scatter_(1, state.current_node_index().unsqueeze(-1), True)\n    # [B, 1, N]\n    connect_to_mask_expanded = connect_to_mask.unsqueeze(1)\n\n    # Mask the distance matrix to only consider connections to valid nodes\n    # Set distances to invalid connection points to infinity\n    # [B, N, N]\n    masked_dist = dist_matrix.clone()\n    masked_dist[~connect_to_mask_expanded.expand_as(dist_matrix)] = torch.finfo(dist_matrix.dtype).max\n\n    # Find the minimum distance from each node to a valid connection point\n    # [B, N]\n    min_dist_to_connect, _ = torch.min(masked_dist, dim=2)\n\n    # Sum these minimum distances only for the unvisited nodes\n    # [B, N]\n    min_dist_to_connect.masked_fill_(~unvisited_mask, 0)\n    # [B]\n    sum_min_dists = torch.sum(min_dist_to_connect, dim=1)\n\n    # The total estimated cost is the sum of minimum connection costs for unvisited nodes\n    # plus the cost to return to the start node from the current node.\n    # [B]\n    value = sum_min_dists + dist_to_start.squeeze(1)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 4.035992338867188, "rmse": 2.0089779338925524, "mse_tsp20": 4.035992338867188, "rmse_tsp20": 2.0089779338925524, "mse_tsp50": 8.995781856640624, "rmse_tsp50": 2.9992968937136957, "mse_tsp100": 17.3319975609375, "rmse_tsp100": 4.163171574765745, "mse_worst": 17.3319975609375, "rmse_worst": 4.163171574765745}, "stats_text": "mse=4.03599; rmse=2.00898; mse_tsp100=17.332; mse_tsp20=4.03599; mse_tsp50=8.99578; mse_worst=17.332; rmse_tsp100=4.16317; rmse_tsp20=2.00898; rmse_tsp50=2.9993; rmse_worst=4.16317"}
{"score": 0.05030289270434993, "gamma": 1.0, "algorithm": "auto} def phi(state): \"\"\" Estimates future tour length based on the convex hull of unvisited nodes, plus connection costs. {The algorithm estimates the remaining tour length by summing three components: the perimeter of the convex hull of the unvisited nodes, the minimum distance from the current node to a node on the hull, and the minimum distance from the starting node to a node on the hull if it's unvisited.", "code_hash": "a0d8b8cd0955fa9b8200849b52e3cc78956528631d7eb1a3016d0bf7085d320a", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on the convex hull of unvisited nodes, plus connection costs.\n    {The algorithm estimates the remaining tour length by summing three components: the perimeter of the convex hull of the unvisited nodes, the minimum distance from the current node to a node on the hull, and the minimum distance from the starting node to a node on the hull if it's unvisited.}\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node_idx = state.current_node_index()\n    # [B]\n    start_node_idx = state.first_node_index()\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal states where few or no nodes are unvisited\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = n_unvisited <= 2\n    if is_terminal.all():\n        return torch.zeros(B, 1, device=device)\n\n    # 1. Calculate the convex hull perimeter of unvisited nodes\n    # A large value to effectively remove visited nodes from consideration\n    inf_val = coords.abs().max().item() * 1e3 if coords.numel() > 0 else 1e9\n    \n    # [B, N, 2], move visited nodes far away\n    unvisited_coords = torch.where(unvisited_mask.unsqueeze(-1), coords, torch.full_like(coords, inf_val))\n\n    # Find the bottom-left point (start of the hull) for each batch item\n    # [B, 2]\n    start_point_coords = torch.full_like(coords[:, 0, :], inf_val)\n    start_point_coords[:, 1] = unvisited_coords[:, :, 1].min(dim=1).values\n    # Break ties with the minimum x-coordinate\n    y_min_mask = (unvisited_coords[:, :, 1] == start_point_coords[:, 1].unsqueeze(1))\n    x_for_y_min = torch.where(y_min_mask, unvisited_coords[:, :, 0], torch.full_like(coords[:, 0, 0], inf_val))\n    start_point_coords[:, 0] = x_for_y_min.min(dim=1).values\n\n    # Calculate angles from the start point to all other unvisited points\n    # [B, N, 2]\n    vectors = unvisited_coords - start_point_coords.unsqueeze(1)\n    # [B, N]\n    angles = torch.atan2(vectors[..., 1], vectors[..., 0])\n    # Set angle for start point itself to a large negative value to keep it first\n    is_start_point = (unvisited_coords == start_point_coords.unsqueeze(1)).all(dim=-1)\n    angles = torch.where(is_start_point, -torch.pi * 2, angles)\n    # Set angles for visited points to a large value to sort them last\n    angles = torch.where(unvisited_mask, angles, torch.pi * 2)\n\n    # Sort indices by angle to get the hull path\n    # [B, N]\n    _, sorted_indices = torch.sort(angles, dim=1)\n    # [B, N, 2]\n    sorted_coords = torch.gather(coords, 1, sorted_indices.unsqueeze(-1).expand(-1, -1, 2))\n    \n    # Calculate perimeter of the sorted points (which form the convex hull)\n    # [B, N, 2]\n    rolled_coords = torch.roll(sorted_coords, shifts=-1, dims=1)\n    # [B, N]\n    segment_lengths = torch.linalg.norm(sorted_coords - rolled_coords, dim=-1)\n    # [B]\n    hull_perimeter = torch.where(n_unvisited > 0, segment_lengths.sum(dim=1), torch.tensor(0.0, device=device))\n\n    # 2. Minimum distance from current node to the convex hull (unvisited nodes)\n    # [B, N]\n    current_dists = torch.gather(dist_matrix, 1, current_node_idx.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    current_dists_unvisited = torch.where(unvisited_mask, current_dists, torch.full_like(current_dists, float('inf')))\n    # [B]\n    min_dist_to_hull = current_dists_unvisited.min(dim=1).values\n    # If no unvisited nodes, this will be inf; handle below.\n\n    # 3. Minimum distance from start node to the convex hull (if start node is unvisited)\n    # [B, N]\n    start_dists = torch.gather(dist_matrix, 1, start_node_idx.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    start_dists_unvisited = torch.where(unvisited_mask, start_dists, torch.full_like(start_dists, float('inf')))\n    # [B]\n    min_dist_from_start = start_dists_unvisited.min(dim=1).values\n    \n    # Check if start node has been visited\n    # [B]\n    start_node_visited_mask = state.visited_mask().gather(1, start_node_idx.unsqueeze(1)).squeeze(1)\n    # Cost is zero if start node is already visited or is the current node\n    start_connection_cost = torch.where(start_node_visited_mask | (current_node_idx == start_node_idx), 0.0, min_dist_from_start)\n    \n    # Combine the components\n    # [B]\n    total_value = hull_perimeter + min_dist_to_hull + start_connection_cost\n\n    # Final cleanup for terminal states\n    final_value = torch.where(is_terminal, 0.0, total_value)\n\n    return final_value.unsqueeze(-1)", "stats": {"mse": 4.669061997314453, "rmse": 2.1608012396595977, "mse_tsp20": 4.669061997314453, "rmse_tsp20": 2.1608012396595977, "mse_tsp50": 10.516099542578125, "rmse_tsp50": 3.242853611031205, "mse_tsp100": 19.87957245078125, "rmse_tsp100": 4.458651416155029, "mse_worst": 19.87957245078125, "rmse_worst": 4.458651416155029}, "stats_text": "mse=4.66906; rmse=2.1608; mse_tsp100=19.8796; mse_tsp20=4.66906; mse_tsp50=10.5161; mse_worst=19.8796; rmse_tsp100=4.45865; rmse_tsp20=2.1608; rmse_tsp50=3.24285; rmse_worst=4.45865"}
{"score": 0.030135818936369817, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The algorithm estimates the remaining tour length by summing two components: the average distance from the current node to all unvisited nodes, and the average minimum distance from each unvisited node to another unvisited node, scaled by the number of remaining nodes to visit.", "code_hash": "0c563bef19de3f217d8b84ca5c62a92fac8dbc59fdd898899abbc565e6ea1f92", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The algorithm estimates the remaining tour length by summing two components: the average distance from the current node to all unvisited nodes, and the average minimum distance from each unvisited node to another unvisited node, scaled by the number of remaining nodes to visit.}\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    visited_mask = state.visited_mask()\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # Create a mask for terminal states where no nodes are unvisited\n    is_not_terminal = n_unvisited > 0\n    # Create a safe divisor to avoid division by zero for terminal states\n    safe_n_unvisited = torch.where(is_not_terminal, n_unvisited, torch.ones_like(n_unvisited))\n\n    # Component 1: Average distance from the current node to all unvisited nodes.\n    # [B, N]\n    current_to_all_dists = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    # [B]\n    current_to_unvisited_dists = torch.where(unvisited_mask, current_to_all_dists, torch.tensor(0.0, device=dist_matrix.device))\n    # [B]\n    avg_dist_to_unvisited = current_to_unvisited_dists.sum(dim=1) / safe_n_unvisited\n\n    # Component 2: Average of the minimum distances from each unvisited node to another unvisited node.\n    # This estimates the cost of the next step from any potential unvisited node.\n    # Mask out visited nodes in the distance matrix by setting their distances to a large value.\n    large_value = dist_matrix.max() + 1.0 if dist_matrix.numel() > 0 else 1e9\n    # [B, N, N]\n    unvisited_dist_matrix = dist_matrix.clone()\n    # Mask rows (from) corresponding to visited nodes\n    unvisited_dist_matrix[visited_mask, :] = large_value\n    # Mask columns (to) corresponding to visited nodes\n    unvisited_dist_matrix[:, visited_mask] = large_value\n    # Set diagonal to a large value to ignore self-loops\n    unvisited_dist_matrix.diagonal(dim1=-2, dim2=-1).fill_(large_value)\n\n    # [B, N]\n    min_dists_from_unvisited, _ = unvisited_dist_matrix.min(dim=2)\n    # Set distances from visited nodes to 0 so they don't contribute to the sum\n    min_dists_from_unvisited = torch.where(unvisited_mask, min_dists_from_unvisited, torch.tensor(0.0, device=dist_matrix.device))\n    # [B]\n    avg_min_dist_between_unvisited = min_dists_from_unvisited.sum(dim=1) / safe_n_unvisited\n\n    # Heuristic: The remaining tour length is roughly the number of remaining steps\n    # times the average cost of a step.\n    # We estimate the average step cost using the average minimum distance between unvisited nodes.\n    # We add the cost to get to the next node from the current one.\n    # n_unvisited already includes the step back to the start if it's unvisited.\n    # [B]\n    remaining_tour_length = avg_dist_to_unvisited + (n_unvisited - 1).clamp(min=0) * avg_min_dist_between_unvisited\n\n    # For terminal states, the future cost is zero.\n    # [B]\n    value = torch.where(is_not_terminal, remaining_tour_length, torch.tensor(0.0, device=dist_matrix.device))\n\n    return value.unsqueeze(-1)", "stats": {"mse": 12.401788290039063, "rmse": 3.5216172833002544, "mse_tsp20": 12.401788290039063, "rmse_tsp20": 3.5216172833002544, "mse_tsp50": 23.8361524796875, "rmse_tsp50": 4.8822282289634416, "mse_tsp100": 33.1831035390625, "rmse_tsp100": 5.760477717955561, "mse_worst": 33.1831035390625, "rmse_worst": 5.760477717955561}, "stats_text": "mse=12.4018; rmse=3.52162; mse_tsp100=33.1831; mse_tsp20=12.4018; mse_tsp50=23.8362; mse_worst=33.1831; rmse_tsp100=5.76048; rmse_tsp20=3.52162; rmse_tsp50=4.88223; rmse_worst=5.76048"}
{"score": 0.0162410203458143, "gamma": -0.1, "algorithm": "Estimate the future tour length by calculating the cost of a convex hull around unvisited nodes, plus the costs to connect the current and start nodes to this hull.", "code_hash": "4fd7044f0a2792e1506701c0b8d639b18640f0383c6f3aa38f4a2283890d4310", "code": "# THOUGHT: {Estimate the future tour length by calculating the cost of a convex hull around unvisited nodes, plus the costs to connect the current and start nodes to this hull.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP using a convex hull heuristic.\n    The value is composed of three parts:\n    1. The perimeter of the convex hull of the unvisited nodes, which serves as a lower bound for the sub-tour length.\n    2. The minimum distance from the current node to any unvisited node (cost to enter the sub-tour).\n    3. The minimum distance from the start node to any unvisited node (cost to return from the sub-tour).\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, 1]\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)\n\n    # 1. Calculate the convex hull perimeter for unvisited nodes\n    # For stability, replace coordinates of visited nodes with a far-away point\n    # so they don't interfere with the convex hull of unvisited nodes.\n    # A large value like 1e9 should be outside any practical TSP coordinate range.\n    large_val = torch.full_like(coords, 1e9)\n    # [B, N, 2]\n    unvisited_coords = torch.where(unvisited_mask.unsqueeze(-1), coords, large_val)\n\n    # Find the min/max x/y coordinates among unvisited nodes to approximate the hull size\n    # This avoids complex hull algorithms and is differentiable.\n    # [B, 1]\n    min_x = torch.min(unvisited_coords[..., 0], dim=1, keepdim=True).values\n    max_x = torch.max(unvisited_coords[..., 0].masked_fill_(~unvisited_mask, -1e9), dim=1, keepdim=True).values\n    min_y = torch.min(unvisited_coords[..., 1], dim=1, keepdim=True).values\n    max_y = torch.max(unvisited_coords[..., 1].masked_fill_(~unvisited_mask, -1e9), dim=1, keepdim=True).values\n\n    # Approximate perimeter of the bounding box as a proxy for convex hull perimeter\n    # [B, 1]\n    hull_perimeter = 2 * ((max_x - min_x) + (max_y - min_y))\n    # Handle cases with 0 or 1 unvisited nodes where hull is undefined or zero\n    hull_perimeter = hull_perimeter.masked_fill(num_unvisited <= 1, 0.0)\n\n    # 2. Calculate connection costs to the unvisited set\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(-1, 1, 1).expand(-1, 1, dist_matrix.size(1))\n    start_node_idx = state.first_node_index().view(-1, 1, 1).expand(-1, 1, dist_matrix.size(1))\n\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n\n    # Find minimum distance to any unvisited node\n    # [B, 1]\n    min_dist_to_unvisited = torch.min(dist_from_current.masked_fill(~unvisited_mask, float('inf')), dim=1, keepdim=True).values\n    min_dist_from_unvisited_to_start = torch.min(dist_from_start.masked_fill(~unvisited_mask, float('inf')), dim=1, keepdim=True).values\n\n    # Handle terminal states where no unvisited nodes exist\n    min_dist_to_unvisited = min_dist_to_unvisited.nan_to_num(posinf=0.0)\n    min_dist_from_unvisited_to_start = min_dist_from_unvisited_to_start.nan_to_num(posinf=0.0)\n\n    # Total estimated future cost\n    value = hull_perimeter + min_dist_to_unvisited + min_dist_from_unvisited_to_start\n\n    # Special case for the last step: cost is simply from current to last, then to start\n    is_last_step = (num_unvisited == 1)\n    if is_last_step.any():\n        # [B, 1]\n        last_unvisited_idx = unvisited_mask.long().argmax(dim=1, keepdim=True)\n        # [B, 1]\n        dist_curr_to_last = torch.gather(dist_from_current, 1, last_unvisited_idx)\n        dist_last_to_start = torch.gather(dist_from_start, 1, last_unvisited_idx)\n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value = torch.where(is_last_step, last_step_cost, value)\n\n    # If the tour is done, future cost is zero.\n    is_done = (num_unvisited == 0)\n    value = value.masked_fill(is_done, 0.0)\n\n    return -value", "stats": {"mse": 28.49783874609375, "rmse": 5.338336702203576, "mse_tsp20": 28.49783874609375, "rmse_tsp20": 5.338336702203576, "mse_tsp50": 42.679790340625, "rmse_tsp50": 6.532977142208979, "mse_tsp100": 61.57248613125, "rmse_tsp100": 7.846813756630777, "mse_worst": 61.57248613125, "rmse_worst": 7.846813756630777}, "stats_text": "mse=28.4978; rmse=5.33834; mse_tsp100=61.5725; mse_tsp20=28.4978; mse_tsp50=42.6798; mse_worst=61.5725; rmse_tsp100=7.84681; rmse_tsp20=5.33834; rmse_tsp50=6.53298; rmse_worst=7.84681"}
{"score": 0.013692846885730149, "gamma": 0.1, "algorithm": "auto", "code_hash": "c56b73843f678df98a303431c2ce030b166c3f27684f9e1488fd86edf87774e0", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP.\n    The value is composed of three main parts:\n    1. The expected distance from the current node to the next unvisited node.\n    2. The expected total distance for the tour among the remaining unvisited nodes.\n    3. The expected distance from the last unvisited node back to the start node.\n    This provides a heuristic for the remaining path length.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # Get batch size and number of nodes\n    B, N, _ = state.all_node_coords().shape\n    device = state.all_node_coords().device\n\n    # Get masks for visited and unvisited nodes\n    unvisited_mask = state.unvisited_mask()  # [B, N]\n    visited_mask = state.visited_mask()      # [B, N]\n\n    # Count the number of unvisited nodes\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited <= 1) # If 0 or 1 unvisited, the tour is effectively done or in the last step.\n\n    # 1. Distance from the current node to all unvisited nodes\n    dist_matrix = state.distance_matrix()  # [B, N, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N) # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1) # [B, N]\n\n    # Mask out distances to already visited nodes\n    dist_from_current_to_unvisited = dist_from_current.masked_fill(visited_mask, float('inf'))\n    \n    # Heuristic for the next step: average distance to an unvisited node\n    # Use a small epsilon to avoid division by zero\n    avg_dist_to_next = dist_from_current_to_unvisited.nan_to_num(posinf=0.0).sum(dim=1, keepdim=True) / torch.clamp(num_unvisited, min=1.0)\n\n    # 2. Heuristic for the tour among remaining unvisited nodes\n    # For each unvisited node, find its minimum distance to another unvisited node\n    unvisited_to_unvisited_mask = unvisited_mask.unsqueeze(2) & unvisited_mask.unsqueeze(1) # [B, N, N]\n    dist_unvisited = dist_matrix.masked_fill(~unvisited_to_unvisited_mask, float('inf'))\n    \n    # Set diagonal to infinity to find min distance to *another* unvisited node\n    dist_unvisited.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n    \n    # Find the minimum distance from each unvisited node to any other unvisited node\n    min_dist_per_unvisited_node, _ = torch.min(dist_unvisited, dim=2) # [B, N]\n    \n    # Sum these minimum distances and average them to get a per-node cost estimate\n    total_min_dist = min_dist_per_unvisited_node.nan_to_num(posinf=0.0).sum(dim=1, keepdim=True) # [B, 1]\n    avg_min_dist_unvisited = total_min_dist / torch.clamp(num_unvisited, min=1.0)\n    \n    # Scale by the number of remaining steps (num_unvisited - 1)\n    # This approximates a nearest-neighbor heuristic for the remaining sub-tour\n    remaining_subtour_cost = avg_min_dist_unvisited * torch.clamp(num_unvisited - 1, min=0.0)\n\n    # 3. Heuristic for returning to the start node from the last unvisited node\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N) # [B, 1, N]\n    dist_to_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1) # [B, N]\n    \n    # Average distance from any unvisited node back to the start\n    dist_unvisited_to_start = dist_to_start.masked_fill(visited_mask, 0.0)\n    avg_dist_to_start = dist_unvisited_to_start.sum(dim=1, keepdim=True) / torch.clamp(num_unvisited, min=1.0)\n    \n    # Combine the components\n    # The total estimated future cost is the sum of the three parts.\n    # We use num_unvisited > 1 as a condition for adding the subtour and start-return costs.\n    # When num_unvisited == 1, the only remaining action is to return to start.\n    # When num_unvisited == 0, the tour is done, cost is 0.\n    \n    # If only one node left, cost is just dist from current to it, plus dist from it to start\n    last_step_mask = (num_unvisited == 1.0)\n    last_unvisited_idx = unvisited_mask.long().argmax(dim=1, keepdim=True) # [B, 1]\n    last_unvisited_idx_exp = last_unvisited_idx.unsqueeze(2) # [B, 1, 1]\n    \n    dist_curr_to_last = torch.gather(dist_from_current, 1, last_unvisited_idx) # [B, 1]\n    dist_last_to_start = torch.gather(dist_to_start, 1, last_unvisited_idx) # [B, 1]\n    last_step_cost = dist_curr_to_last + dist_last_to_start\n    \n    # Calculate the full heuristic\n    value = avg_dist_to_next + remaining_subtour_cost + avg_dist_to_start\n    \n    # Apply special case for the last step\n    value = torch.where(last_step_mask, last_step_cost, value)\n\n    # If the episode is done (or about to be), the future cost is 0.\n    # This ensures terminal consistency.\n    value = value.masked_fill(is_done, 0.0)\n    \n    # Return as a negative value because the environment uses negative rewards (path length)\n    return -value", "stats": {"mse": 22.51568820703125, "rmse": 4.745069884314798, "mse_tsp20": 22.51568820703125, "rmse_tsp20": 4.745069884314798, "mse_tsp50": 42.503790928125, "rmse_tsp50": 6.519493149634027, "mse_tsp100": 73.0308319625, "rmse_tsp100": 8.545807858973896, "mse_worst": 73.0308319625, "rmse_worst": 8.545807858973896}, "stats_text": "mse=22.5157; rmse=4.74507; mse_tsp100=73.0308; mse_tsp20=22.5157; mse_tsp50=42.5038; mse_worst=73.0308; rmse_tsp100=8.54581; rmse_tsp20=4.74507; rmse_tsp50=6.51949; rmse_worst=8.54581"}
{"score": 0.013379277095224842, "gamma": 0.1, "algorithm": "Estimate the future tour length by summing, for each unvisited node, half the distance to its two nearest unvisited neighbors, plus the costs to connect the current and start nodes into this estimated sub-tour.", "code_hash": "6a5852e5d396822bcba2058559cc394425eefcabcf728af2a303c083fd70961e", "code": "# THOUGHT: {Estimate the future tour length by summing, for each unvisited node, half the distance to its two nearest unvisited neighbors, plus the costs to connect the current and start nodes into this estimated sub-tour.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP using a nearest-neighbor heuristic on the unvisited subgraph.\n    The value is composed of three parts:\n    1. An estimation of the sub-tour length through unvisited nodes. For each unvisited node, we find its two nearest\n       unvisited neighbors and add half the distance to each (approximating one incoming and one outgoing edge).\n    2. The minimum distance from the current node to any unvisited node (cost to enter the sub-tour).\n    3. The minimum distance from the start node to any unvisited node (cost to return from the sub-tour).\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, 1]\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)\n\n    # 1. Estimate the sub-tour length through unvisited nodes\n    # Create a distance matrix masked to only show distances between unvisited nodes\n    # [B, N, 1]\n    unvisited_from = unvisited_mask.unsqueeze(-1)\n    # [B, 1, N]\n    unvisited_to = unvisited_mask.unsqueeze(-2)\n    # [B, N, N]\n    unvisited_dist = dist_matrix.masked_fill(~(unvisited_from & unvisited_to), float('inf'))\n    # Set diagonal to infinity to avoid picking a node as its own neighbor\n    unvisited_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n\n    # Find the two nearest unvisited neighbors for each unvisited node\n    # [B, N, 2]\n    k_smallest_dists, _ = torch.topk(unvisited_dist, k=2, dim=-1, largest=False)\n\n    # Sum of distances to the two nearest unvisited neighbors, for unvisited nodes only\n    # [B, N]\n    sum_2_nn_dists = k_smallest_dists.sum(dim=-1)\n    # Zero out distances for nodes that are already visited\n    sum_2_nn_dists.masked_fill_(~unvisited_mask, 0.0)\n    # We take the sum over all nodes and divide by 2, as each edge (i,j) is counted twice (once for i, once for j).\n    # This is equivalent to summing (d1+d2)/2 for each node.\n    # [B, 1]\n    subtour_estimate = sum_2_nn_dists.sum(dim=-1, keepdim=True) * 0.5\n    # Handle cases with < 2 unvisited nodes where topk(2) is not meaningful\n    subtour_estimate = subtour_estimate.masked_fill(num_unvisited < 2, 0.0)\n\n    # 2. & 3. Calculate connection costs from current and start nodes to the unvisited set\n    # [B] -> [B, 1]\n    current_node_idx = state.current_node_index().unsqueeze(-1)\n    start_node_idx = state.first_node_index().unsqueeze(-1)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx.unsqueeze(-1).expand(-1, -1, dist_matrix.size(-1))).squeeze(1)\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx.unsqueeze(-1).expand(-1, -1, dist_matrix.size(-1))).squeeze(1)\n\n    # Find minimum distance to any unvisited node\n    # [B, 1]\n    min_dist_to_unvisited = torch.min(dist_from_current.masked_fill(~unvisited_mask, float('inf')), dim=1, keepdim=True).values\n    min_dist_from_unvisited_to_start = torch.min(dist_from_start.masked_fill(~unvisited_mask, float('inf')), dim=1, keepdim=True).values\n    \n    # Handle terminal states where no unvisited nodes exist\n    min_dist_to_unvisited = min_dist_to_unvisited.nan_to_num(posinf=0.0)\n    min_dist_from_unvisited_to_start = min_dist_from_unvisited_to_start.nan_to_num(posinf=0.0)\n\n    # Total estimated future cost\n    value = subtour_estimate + min_dist_to_unvisited + min_dist_from_unvisited_to_start\n\n    # If the tour is done (num_unvisited == 0), future cost is zero.\n    # This is handled naturally by the components becoming 0.\n    # If only one node is left, subtour_estimate is 0, and the cost is curr->last + last->start.\n    # This is also handled naturally.\n\n    return -value", "stats": {"mse": 21.7091130703125, "rmse": 4.6593039255142505, "mse_tsp20": 21.7091130703125, "rmse_tsp20": 4.6593039255142505, "mse_tsp50": 41.8858065, "rmse_tsp50": 6.471924481945073, "mse_tsp100": 74.7424537875, "rmse_tsp100": 8.645371813143724, "mse_worst": 74.7424537875, "rmse_worst": 8.645371813143724}, "stats_text": "mse=21.7091; rmse=4.6593; mse_tsp100=74.7425; mse_tsp20=21.7091; mse_tsp50=41.8858; mse_worst=74.7425; rmse_tsp100=8.64537; rmse_tsp20=4.6593; rmse_tsp50=6.47192; rmse_worst=8.64537"}
{"score": 3.4209696471518978, "gamma": -0.1, "algorithm": "Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.", "code_hash": "d5014fe6247751116f6de4174accdec9f7c2eafdcfcbe2f724c5ad25941cb364", "code": "# THOUGHT: {Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length using a Minimum Spanning Tree (MST) based heuristic.\n    The cost is the sum of three components:\n    1. The cost of the MST of the subgraph formed by the unvisited nodes. This provides a\n       tight lower bound on the optimal sub-tour length for these nodes.\n    2. The minimum cost to connect the current node to the set of unvisited nodes.\n    3. The minimum cost to connect the start node to the set of unvisited nodes,\n       which is necessary for closing the tour.\n    \n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n    \n    # 1. Calculate the cost of the MST on the unvisited nodes.\n    # Prim's algorithm for dense graphs.\n    # We will compute this only for batches where there are unvisited nodes.\n    # [B, N]\n    min_cost = torch.full((B, N), float('inf'), device=device)\n    # [B, N]\n    visited_in_mst = torch.zeros_like(unvisited_mask)\n    # [B]\n    mst_cost = torch.zeros(B, device=device)\n    \n    # Initialize Prim's: pick the first unvisited node as the starting point for the MST.\n    # Find the index of the first 'True' in unvisited_mask for each batch item.\n    first_unvisited_idx = torch.argmax(unvisited_mask.int(), dim=1)\n    \n    # Set the min_cost for the starting node of the MST to 0.\n    # This ensures it's the first one picked.\n    min_cost.scatter_(1, first_unvisited_idx.unsqueeze(1), 0)\n    \n    # Mask min_cost for nodes that are already visited in the main tour.\n    min_cost.masked_fill_(~unvisited_mask, float('inf'))\n\n    # Prim's algorithm loop executed in a parallelized way over N-1 steps.\n    # This is a fixed-iteration loop, avoiding dynamic Python loops.\n    for _ in range(N):\n        # Find the node `u` with the minimum cost that is unvisited in the MST.\n        # [B, 1]\n        u_idx = torch.argmin(min_cost, dim=1, keepdim=True)\n        # [B]\n        u_cost = torch.gather(min_cost, 1, u_idx).squeeze(1)\n        \n        # Add its cost to the total MST cost, handling inf for disconnected components.\n        mst_cost += torch.where(u_cost == float('inf'), 0, u_cost)\n        \n        # Mark `u` as visited in the MST and remove it from consideration.\n        visited_in_mst.scatter_(1, u_idx, True)\n        min_cost.scatter_(1, u_idx, float('inf'))\n\n        # Update min_costs for neighbors of `u`.\n        # [B, N]\n        dist_from_u = torch.gather(dist_matrix, 1, u_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        \n        # Update only if the new path through `u` is shorter and the neighbor is unvisited in MST.\n        # We also need to ensure the neighbor is part of the unvisited set for the main tour.\n        update_mask = (dist_from_u < min_cost) & ~visited_in_mst & unvisited_mask\n        min_cost[update_mask] = dist_from_u[update_mask]\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    # Mask distances to already visited nodes.\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop).\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Total estimated cost\n    # For the case with only one unvisited node, MST cost is 0. The formula becomes\n    # dist(current -> last) + dist(start -> last), which is correct.\n    value = mst_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # For terminal states, future cost is 0.\n    value.masked_fill_(is_terminal, 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0.\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.18682559706115723, "rmse": 0.4322332669533399, "mse_tsp20": 0.18682559706115723, "rmse_tsp20": 0.4322332669533399, "mse_tsp50": 0.19572340977783204, "rmse_tsp50": 0.4424063853266949, "mse_tsp100": 0.2923147829833984, "rmse_tsp100": 0.5406614310114958, "mse_worst": 0.2923147829833984, "rmse_worst": 0.5406614310114958}, "stats_text": "mse=0.186826; rmse=0.432233; mse_tsp100=0.292315; mse_tsp20=0.186826; mse_tsp50=0.195723; mse_worst=0.292315; rmse_tsp100=0.540661; rmse_tsp20=0.432233; rmse_tsp50=0.442406; rmse_worst=0.540661"}
{"score": 3.406448250786877, "gamma": -0.1, "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.", "code_hash": "a509be98760cefdd1fed21f2974aece62623fff8e8b93600894306f7a87ee209", "code": "# THOUGHT: {Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for a TSP state.\n    The estimation is based on three components:\n    1. The cost of a Minimum Spanning Tree (MST) over all unvisited nodes.\n    2. The minimum cost to connect the current node to one of the unvisited nodes.\n    3. The minimum cost to connect the start node to one of the unvisited nodes.\n    This heuristic approximates the cost of visiting all remaining nodes and returning home.\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # 1. MST cost on unvisited nodes\n    # Create a subgraph distance matrix for unvisited nodes\n    # [B, N, N]\n    unvisited_dist = dist_matrix.clone()\n    # Mask rows and columns for visited nodes by setting distances to infinity\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n\n    # Prim's algorithm for MST cost\n    # [B]\n    num_unvisited = unvisited_mask.sum(dim=1)\n    # [B, N], init with large values\n    min_cost = torch.full_like(unvisited_mask, float('inf'), dtype=dist_matrix.dtype)\n    # [B, N], init with False\n    in_mst = torch.zeros_like(unvisited_mask, dtype=torch.bool)\n    # [B]\n    mst_cost = torch.zeros(B, device=dist_matrix.device)\n\n    # Find the first unvisited node to start Prim's algorithm\n    # [B], indices of first unvisited nodes\n    start_node_idx = torch.where(unvisited_mask.any(1), unvisited_mask.float().argmax(1), -1)\n\n    # Set the cost of the starting node to 0\n    # Use scatter for batched indexing\n    min_cost.scatter_(1, start_node_idx.unsqueeze(1).clamp(min=0), 0)\n\n    # Prim's algorithm loop (vectorized)\n    # This loop runs N times, which is more than necessary but avoids dynamic loops\n    # and is safe because nodes already in MST won't be chosen again.\n    for _ in range(N):\n        # Select node `u` not in MST with the minimum cost\n        # [B, N]\n        cost_if_not_in_mst = min_cost.clone()\n        cost_if_not_in_mst.masked_fill_(in_mst, float('inf'))\n        # [B, 1]\n        u_cost, u_idx = cost_if_not_in_mst.min(dim=1, keepdim=True)\n\n        # Add cost to total and mark node as in MST\n        # This mask handles batches where no unvisited nodes are left (u_cost is inf)\n        is_finite_mask = torch.isfinite(u_cost.squeeze(-1))\n        mst_cost[is_finite_mask] += u_cost[is_finite_mask].squeeze(-1)\n        in_mst.scatter_(1, u_idx.clamp(min=0), True)\n\n        # Update min_cost for neighbors of `u`\n        # [B, 1, N]\n        dist_from_u = torch.gather(unvisited_dist, 1, u_idx.unsqueeze(-1).expand(-1, 1, N))\n        # [B, N]\n        dist_from_u_squeezed = dist_from_u.squeeze(1)\n        # [B, N]\n        min_cost = torch.min(min_cost, dist_from_u_squeezed)\n\n    # 2. Minimum cost from current node to any unvisited node\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_exp = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_exp)\n    # [B, N]\n    dist_from_current_squeezed = dist_from_current.squeeze(1)\n    dist_from_current_squeezed.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_to_unvisited = dist_from_current_squeezed.min(dim=1).values\n    min_to_unvisited.masked_fill_(num_unvisited == 0, 0) # If no unvisited, cost is 0\n\n    # 3. Minimum cost from start node to any unvisited node\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    first_node_exp = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_start = torch.gather(dist_matrix, 1, first_node_exp)\n    # [B, N]\n    dist_from_start_squeezed = dist_from_start.squeeze(1)\n    dist_from_start_squeezed.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_to_return = dist_from_start_squeezed.min(dim=1).values\n    min_to_return.masked_fill_(num_unvisited == 0, 0) # If no unvisited, cost is 0\n\n    # Total estimated cost\n    # Special case: if only one unvisited node, MST cost is 0. The cost is just to go there and back.\n    # [B]\n    is_one_unvisited = (num_unvisited == 1)\n    # [B, 1]\n    first_unvisited_idx = torch.where(is_one_unvisited, unvisited_mask.float().argmax(1).unsqueeze(-1), -1)\n    # [B, 1]\n    dist_curr_to_last = torch.gather(dist_from_current_squeezed, 1, first_unvisited_idx.clamp(min=0))\n    # [B, 1]\n    dist_last_to_start = torch.gather(dist_from_start_squeezed, 1, first_unvisited_idx.clamp(min=0))\n    # [B]\n    one_unvisited_cost = (dist_curr_to_last + dist_last_to_start).squeeze(-1)\n\n    # Combine costs\n    value = torch.where(is_one_unvisited, one_unvisited_cost, mst_cost + min_to_unvisited + min_to_return)\n\n    # Final state: tour complete, cost is 0\n    value.masked_fill_(num_unvisited == 0, 0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.19756102726745606, "rmse": 0.444478376602795, "mse_tsp20": 0.19756102726745606, "rmse_tsp20": 0.444478376602795, "mse_tsp50": 0.20184117449951172, "rmse_tsp50": 0.44926737528949473, "mse_tsp100": 0.29356089580078126, "rmse_tsp100": 0.5418126021059138, "mse_worst": 0.29356089580078126, "rmse_worst": 0.5418126021059138}, "stats_text": "mse=0.197561; rmse=0.444478; mse_tsp100=0.293561; mse_tsp20=0.197561; mse_tsp50=0.201841; mse_worst=0.293561; rmse_tsp100=0.541813; rmse_tsp20=0.444478; rmse_tsp50=0.449267; rmse_worst=0.541813"}
{"score": 3.3781803516081297, "gamma": 1.0, "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.", "code_hash": "54055c1f192cd4960761c781d6f2bc50f9e6fcc45c0de48c9b7057e7a6b4b015", "code": "# THOUGHT: {Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for TSP.\n    The estimate is composed of three parts:\n    1. The cost of a Minimum Spanning Tree (MST) over all unvisited nodes. This approximates\n       the shortest path needed to connect all remaining nodes.\n    2. The cost to connect the current node to the set of unvisited nodes (minimum edge).\n    3. The cost to connect the start node to the set of unvisited nodes (minimum edge).\n    This forms a lower bound on the remaining tour length, as it approximates a path\n    connecting the current node, all unvisited nodes, and returning to the start.\n\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # 1. Calculate the cost of the MST on the subgraph of unvisited nodes.\n    # We use a Prim's algorithm-like approach.\n    # Create a distance matrix for only the unvisited nodes.\n    # Mask rows and columns corresponding to visited nodes.\n    unvisited_dist_matrix = dist_matrix.clone()\n    # Mask rows for visited nodes\n    unvisited_dist_matrix.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n    # Mask columns for visited nodes\n    unvisited_dist_matrix.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n\n    # Prim's algorithm to find MST cost\n    # `in_mst` mask: nodes already included in the MST\n    in_mst = torch.zeros_like(unvisited_mask)\n    # `min_cost` array: min cost to connect each node to the MST\n    min_cost = torch.full((B, N), float('inf'), device=dist_matrix.device, dtype=dist_matrix.dtype)\n\n    # Find the first unvisited node to start Prim's algorithm\n    # This is guaranteed to exist if there are unvisited nodes.\n    first_unvisited_idx = torch.argmax(unvisited_mask.float(), dim=1, keepdim=True)\n\n    # Initialize: select the first unvisited node. Its cost to connect is 0.\n    min_cost.scatter_(1, first_unvisited_idx, 0)\n\n    # Iteratively add N-1 nodes to the MST (or until all unvisited are added)\n    # This loop is fixed to N, which is acceptable as it's not a Python loop.\n    mst_cost = torch.zeros(B, device=dist_matrix.device, dtype=dist_matrix.dtype)\n    for _ in range(N):\n        # Find the node not in MST with the minimum connection cost\n        cost_to_add = min_cost.clone()\n        cost_to_add.masked_fill_(in_mst, float('inf'))\n        # If no nodes are left to add (all unvisited are in mst), cost will be inf\n        min_val, new_node_idx = torch.min(cost_to_add, dim=1)\n\n        # Create a mask for valid additions (cost is not inf)\n        is_valid_addition = min_val != float('inf')\n        \n        # Add its cost to the total MST cost\n        mst_cost += min_val.where(is_valid_addition, torch.tensor(0.0, device=mst_cost.device))\n\n        # Add the new node to the MST\n        new_node_idx = new_node_idx.unsqueeze(1)\n        in_mst.scatter_(1, new_node_idx, True)\n\n        # Update min_cost for all nodes based on the newly added node\n        # Distances from the newly added node to all other nodes\n        dist_from_new = torch.gather(unvisited_dist_matrix, 1, new_node_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        min_cost = torch.min(min_cost, dist_from_new)\n\n    # 2. Find the minimum cost to connect the current node to any unvisited node.\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx)\n    # Mask distances to already visited nodes\n    dist_from_current.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # [B]\n    min_dist_from_current, _ = torch.min(dist_from_current.squeeze(1), dim=1)\n    # If no unvisited nodes, this cost is 0 (or inf, we handle it)\n    min_dist_from_current.masked_fill_(~unvisited_mask.any(dim=1), 0)\n\n    # 3. Find the minimum cost to connect the start node to any unvisited node.\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx)\n    # Mask distances to already visited nodes\n    dist_from_start.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start.squeeze(1), dim=1)\n    # If no unvisited nodes, this cost is 0\n    min_dist_from_start.masked_fill_(~unvisited_mask.any(dim=1), 0)\n    \n    # In terminal states, there are no unvisited nodes. The MST cost will be 0,\n    # and the connection costs will be 0. The only remaining cost is to return to start.\n    is_terminal = ~unvisited_mask.any(dim=1)\n    # [B]\n    dist_to_start_terminal = torch.gather(dist_matrix, 1, state.current_node_index().unsqueeze(1).unsqueeze(2)).squeeze()\n    dist_to_start_terminal = torch.gather(dist_to_start_terminal, 1, state.first_node_index().unsqueeze(1)).squeeze(1)\n\n    # Total estimated future cost\n    value = mst_cost + min_dist_from_current + min_dist_from_start\n    # For terminal states, the value is just the cost to return home\n    value = torch.where(is_terminal, dist_to_start_terminal, value)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.21352034575653075, "rmse": 0.4620826178904923, "mse_tsp20": 0.21352034575653075, "rmse_tsp20": 0.4620826178904923, "mse_tsp50": 0.20358135737304686, "rmse_tsp50": 0.4511999084364345, "mse_tsp100": 0.2960173513305664, "rmse_tsp100": 0.5440747663056672, "mse_worst": 0.2960173513305664, "rmse_worst": 0.5440747663056672}, "stats_text": "mse=0.21352; rmse=0.462083; mse_tsp100=0.296017; mse_tsp20=0.21352; mse_tsp50=0.203581; mse_worst=0.296017; rmse_tsp100=0.544075; rmse_tsp20=0.462083; rmse_tsp50=0.4512; rmse_worst=0.544075"}
{"score": 2.423034464838014, "gamma": -0.1, "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.", "code_hash": "1b3b0812ca98a6aa6a8fb459b2e47dca3884b0f5419dcd0d7504221710b3f7b9", "code": "# THOUGHT: {Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length by approximating a path through unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes. For each unvisited node,\n       we find the distance to its two nearest neighbors among the other unvisited nodes.\n       The sum of these distances, averaged over all unvisited nodes, provides an estimate\n       of the local path cost. This is scaled by the number of unvisited nodes.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n    is_last_step = (num_unvisited == 1)\n    is_penultimate = (num_unvisited == 2)\n\n    # 1. Approximate sub-tour length through unvisited nodes\n    # Create a distance matrix only considering unvisited nodes.\n    # We set distances to/from visited nodes to infinity.\n    unvisited_dist = dist_matrix.clone()\n    inf = torch.finfo(dist_matrix.dtype).max\n    # Mask rows (from) and columns (to) corresponding to visited nodes\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), inf)\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), inf)\n\n    # For each unvisited node, find the distances to its two nearest unvisited neighbors.\n    # We use k=3 because the node itself is included with distance 0.\n    # [B, N, 3]\n    k = min(3, N) # handle N < 3 case\n    topk_dists, _ = torch.topk(unvisited_dist, k, dim=2, largest=False)\n\n    # The first value (k=0) is always 0 (distance to self), so we take k=1 and k=2.\n    # Sum of distances to two nearest neighbors for each node.\n    # If less than 3 unvisited nodes, some of these will be inf.\n    if k > 2:\n        two_nn_dist_sum = topk_dists[:, :, 1] + topk_dists[:, :, 2] # [B, N]\n    elif k > 1:\n        two_nn_dist_sum = topk_dists[:, :, 1] # [B, N]\n    else:\n        two_nn_dist_sum = torch.zeros_like(unvisited_mask, dtype=dist_matrix.dtype)\n\n\n    # Mask out the sums for visited nodes\n    two_nn_dist_sum.masked_fill_(~unvisited_mask, 0.0)\n\n    # The sum of these distances over all unvisited nodes, divided by 2 (since each edge is counted twice),\n    # approximates the MST length, which is a lower bound on the tour length.\n    # We use the sum directly as a heuristic.\n    subtour_cost = torch.sum(two_nn_dist_sum, dim=1) / 2.0\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    # [B]\n    min_dist_to_unvisited = torch.min(dist_from_current.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # 3. Cost to connect the start node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    # [B]\n    min_dist_from_start = torch.min(dist_from_start.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # Combine the components\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # Handle edge cases where subtour_cost is not well-defined\n    # If only two unvisited nodes, cost is current->A->B->start or current->B->A->start\n    if torch.any(is_penultimate):\n      # [B_pen, 2]\n      unvisited_indices = unvisited_mask[is_penultimate.squeeze(-1)].long().nonzero(as_tuple=False)[:, 1].view(-1, 2)\n      node_a_idx, node_b_idx = unvisited_indices[:, 0], unvisited_indices[:, 1]\n      \n      current_node_pen = state.current_node_index()[is_penultimate.squeeze(-1)]\n      start_node_pen = state.first_node_index()[is_penultimate.squeeze(-1)]\n      dist_matrix_pen = dist_matrix[is_penultimate.squeeze(-1)]\n\n      dist_curr_a = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_a_idx]\n      dist_curr_b = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_b_idx]\n      dist_a_b = dist_matrix_pen[torch.arange(len(node_a_idx)), node_a_idx, node_b_idx]\n      dist_a_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_a_idx, start_node_pen]\n      dist_b_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_b_idx, start_node_pen]\n      \n      cost1 = dist_curr_a + dist_a_b + dist_b_start\n      cost2 = dist_curr_b + dist_a_b + dist_a_start\n      penultimate_cost = torch.min(cost1, cost2)\n      value[is_penultimate.squeeze(-1)] = penultimate_cost\n\n    # If only one unvisited node, cost is current -> last -> start\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step.squeeze(-1)].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_from_current[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        dist_last_to_start = torch.gather(dist_from_start[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step.squeeze(-1)] = last_step_cost\n    \n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.2396109479522705, "rmse": 0.48950071292314834, "mse_tsp20": 0.2396109479522705, "rmse_tsp20": 0.48950071292314834, "mse_tsp50": 0.24980534642333985, "rmse_tsp50": 0.4998053085185669, "mse_tsp100": 0.41270564431152346, "rmse_tsp100": 0.6424217028646553, "mse_worst": 0.41270564431152346, "rmse_worst": 0.6424217028646553}, "stats_text": "mse=0.239611; rmse=0.489501; mse_tsp100=0.412706; mse_tsp20=0.239611; mse_tsp50=0.249805; mse_worst=0.412706; rmse_tsp100=0.642422; rmse_tsp20=0.489501; rmse_tsp50=0.499805; rmse_worst=0.642422"}
{"score": 0.11230624864292459, "gamma": -0.1, "algorithm": "Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.", "code_hash": "0e7601ed649dfde68fc9175671d4df815cf1f6e8088ee79de00b3b2d9f6dd931", "code": "# THOUGHT: {Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on the geometric properties of unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes using the area of their convex hull.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n    This combines a geometric heuristic for the bulk of the path with connection costs.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n\n    # 1. Approximate sub-tour length using convex hull area of unvisited nodes\n    # A heuristic for tour length is related to the square root of the area of the convex hull.\n    # We use a simplified proxy: the area of the bounding box of unvisited nodes.\n\n    # Mask coordinates of visited nodes to exclude them from min/max calculations\n    # [B, N, 2]\n    masked_coords = coords.clone()\n    # Use a large value for visited nodes so they don't affect min, and a small value for max\n    large_val = torch.finfo(coords.dtype).max\n    small_val = torch.finfo(coords.dtype).min\n    # [B, N, 1]\n    unvisited_mask_exp = unvisited_mask.unsqueeze(-1)\n    masked_coords.masked_fill_(~unvisited_mask_exp, large_val)\n    min_coords, _ = torch.min(masked_coords, dim=1)  # [B, 2]\n\n    masked_coords = coords.clone()\n    masked_coords.masked_fill_(~unvisited_mask_exp, small_val)\n    max_coords, _ = torch.max(masked_coords, dim=1)  # [B, 2]\n\n    # Calculate width and height of the bounding box\n    # [B, 2]\n    span = max_coords - min_coords\n    # Clamp to avoid negative span if only one node is left\n    span = torch.clamp(span, min=0.0)\n    # [B]\n    area = span[:, 0] * span[:, 1]\n    # Heuristic for tour length: k * sqrt(Area * num_unvisited), k is an empirical factor\n    # For a unit square with N points, E[tour_len] ~ beta * sqrt(N), and Area=1.\n    # We use a simplified form: sqrt(Area) as a proxy for the spatial scale.\n    # The sum of two sides of the bounding box is a reasonable perimeter proxy.\n    subtour_cost = span[:, 0] + span[:, 1]\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, torch.finfo(dist_from_current.dtype).max)\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop)\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, torch.finfo(dist_from_start.dtype).max)\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Combine the components\n    # [B]\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n    \n    # Handle edge case where only one unvisited node remains\n    # The cost is just from current -> last_unvisited -> start\n    is_last_step = (num_unvisited.squeeze(-1) == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step]\n\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix[is_last_step, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix[is_last_step, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step] = last_step_cost\n\n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set if num_unvisited=0) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.9090601949462891, "rmse": 0.9534464824762264, "mse_tsp20": 0.9090601949462891, "rmse_tsp20": 0.9534464824762264, "mse_tsp50": 3.432229481640625, "rmse_tsp50": 1.852627723435182, "mse_tsp100": 8.904224048828125, "rmse_tsp100": 2.9839946462465585, "mse_worst": 8.904224048828125, "rmse_worst": 2.9839946462465585}, "stats_text": "mse=0.90906; rmse=0.953446; mse_tsp100=8.90422; mse_tsp20=0.90906; mse_tsp50=3.43223; mse_worst=8.90422; rmse_tsp100=2.98399; rmse_tsp20=0.953446; rmse_tsp50=1.85263; rmse_worst=2.98399"}
{"score": 0.07782706118698951, "gamma": -0.1, "algorithm": "Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.", "code_hash": "5fd3309104022111fb964be45f064a888499b1e8ed8f66c21cadfee07bffcee5", "code": "# THOUGHT: {Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length by averaging connection costs to the unvisited set.\n    The value is the sum of two components:\n    1. The average distance from the current node to all unvisited nodes.\n    2. The average distance from the start node to all unvisited nodes (to close the tour).\n    This heuristic focuses on the expected cost of the next and final connections.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N = unvisited_mask.shape\n    device = unvisited_mask.device\n    \n    # [B, 1]\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)\n    is_done = (num_unvisited == 0)\n\n    # Use a small epsilon to avoid division by zero when no nodes are unvisited\n    # The result for this case will be masked out later anyway.\n    num_unvisited_safe = num_unvisited.clamp(min=1.0)\n\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n\n    # 1. Average distance from the current node to the unvisited set\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    \n    # Mask out distances to already visited nodes\n    dist_from_current_unvisited = dist_from_current.masked_fill(~unvisited_mask, 0.0)\n    \n    # [B, 1]\n    sum_dist_from_current = dist_from_current_unvisited.sum(dim=1, keepdim=True)\n    avg_dist_from_current = sum_dist_from_current / num_unvisited_safe\n\n    # 2. Average distance from the start node to the unvisited set (for closing the loop)\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n\n    # Mask out distances to already visited nodes\n    dist_from_start_unvisited = dist_from_start.masked_fill(~unvisited_mask, 0.0)\n\n    # [B, 1]\n    sum_dist_from_start = dist_from_start_unvisited.sum(dim=1, keepdim=True)\n    avg_dist_from_start = sum_dist_from_start / num_unvisited_safe\n\n    # Combine the components\n    # [B, 1]\n    value = avg_dist_from_current + avg_dist_from_start\n    \n    # Handle the special case where only one unvisited node remains.\n    # The cost is exactly current -> last -> start.\n    is_last_step = (num_unvisited == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step.squeeze(-1)].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step.squeeze(-1)]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step.squeeze(-1)]\n        \n        # [B_last, N, N]\n        dist_matrix_last = dist_matrix[is_last_step.squeeze(-1)]\n        \n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix_last[:, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix_last[:, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = (dist_curr_to_last + dist_last_to_start).unsqueeze(-1)\n        value = torch.where(is_last_step, last_step_cost, value)\n\n    # If the tour is done, the future cost is zero.\n    value.masked_fill_(is_done, 0.0)\n\n    return value", "stats": {"mse": 1.5873716700439453, "rmse": 1.2599093896165492, "mse_tsp20": 1.5873716700439453, "rmse_tsp20": 1.2599093896165492, "mse_tsp50": 4.672369123242188, "rmse_tsp50": 2.161566358741315, "mse_tsp100": 12.849001166796874, "rmse_tsp100": 3.58455034373865, "mse_worst": 12.849001166796874, "rmse_worst": 3.58455034373865}, "stats_text": "mse=1.58737; rmse=1.25991; mse_tsp100=12.849; mse_tsp20=1.58737; mse_tsp50=4.67237; mse_worst=12.849; rmse_tsp100=3.58455; rmse_tsp20=1.25991; rmse_tsp50=2.16157; rmse_worst=3.58455"}
{"score": 0.07266666341623383, "gamma": 1.0, "algorithm": "Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.", "code_hash": "884346de00c0f4e4ef075e61c49dd857c93553fc2d00215ba1795fcf9caa8a84", "code": "# THOUGHT: {Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on average distances to the set of unvisited nodes.\n    This heuristic considers the expected cost to connect the current path segment back\n    to the main cluster of unvisited nodes, and then eventually close the tour from that\n    cluster back to the start node. It uses average distance as a robust proxy for\n    these connection costs, avoiding reliance on single min/max values which can be noisy.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n    device = dist_matrix.device\n\n    # [B]\n    num_unvisited = unvisited_mask.sum(dim=1)\n    # Avoid division by zero for terminal states.\n    # The final value for terminal states will be masked to 0 anyway.\n    num_unvisited_safe = torch.clamp(num_unvisited, min=1.0)\n\n    # 1. Calculate the average distance from the current node to all unvisited nodes.\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    # Mask out distances to already visited nodes by setting them to 0.\n    dist_from_current_unvisited = dist_from_current * unvisited_mask\n    # [B]\n    avg_dist_from_current = dist_from_current_unvisited.sum(dim=1) / num_unvisited_safe\n\n    # 2. Calculate the average distance from the start node to all unvisited nodes.\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    # Mask out distances to already visited nodes.\n    dist_from_start_unvisited = dist_from_start * unvisited_mask\n    # [B]\n    avg_dist_from_start = dist_from_start_unvisited.sum(dim=1) / num_unvisited_safe\n\n    # 3. Handle the case where only one unvisited node remains.\n    # The cost is exactly current -> last_unvisited -> start.\n    is_last_step = (num_unvisited == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step]\n\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix[is_last_step, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix[is_last_step, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        # For the last step, the average distances are just the exact distances, so this is correct.\n        avg_dist_from_current[is_last_step] = dist_curr_to_last\n        avg_dist_from_start[is_last_step] = dist_last_to_start\n\n    # Combine the two average distance components.\n    # This represents the cost to enter the unvisited cluster and the cost to leave it to finish the tour.\n    value = avg_dist_from_current + avg_dist_from_start\n\n    # If the tour is done (num_unvisited is 0), the future cost is 0.\n    is_done = (num_unvisited == 0)\n    value.masked_fill_(is_done, 0.0)\n\n    # Return broadcastable shape [B, 1]\n    return value.unsqueeze(-1)", "stats": {"mse": 2.3418170474853515, "rmse": 1.5302996593756895, "mse_tsp20": 2.3418170474853515, "rmse_tsp20": 1.5302996593756895, "mse_tsp50": 6.4205319578125, "rmse_tsp50": 2.5338768631905735, "mse_tsp100": 13.76146850546875, "rmse_tsp100": 3.709645334188802, "mse_worst": 13.76146850546875, "rmse_worst": 3.709645334188802}, "stats_text": "mse=2.34182; rmse=1.5303; mse_tsp100=13.7615; mse_tsp20=2.34182; mse_tsp50=6.42053; mse_worst=13.7615; rmse_tsp100=3.70965; rmse_tsp20=1.5303; rmse_tsp50=2.53388; rmse_worst=3.70965"}
{"score": 0.0624345409506303, "gamma": 1.0, "algorithm": "auto} def phi(state): \"\"\" {Estimates future tour length based on the convex hull area of unvisited nodes, plus connection costs.", "code_hash": "627d91b23b0370ff838ed2c69bc931795333336d40829148afcc16965d6b24a6", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimates future tour length based on the convex hull area of unvisited nodes, plus connection costs.}\n    The heuristic has three parts:\n    1. The area of the convex hull of the unvisited nodes, scaled by a factor. This approximates the density and spread of the remaining problem.\n    2. The cost to connect the current node to the closest unvisited node.\n    3. The cost to connect the start node to the closest unvisited node (approximating the tour completion cost).\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    num_unvisited = unvisited_mask.sum(dim=1)\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n\n    # Handle terminal state: if no nodes are unvisited, the future cost is zero.\n    is_terminal = (num_unvisited == 0)\n    # Handle case with < 3 unvisited nodes where convex hull is undefined/zero area\n    is_small_subproblem = (num_unvisited < 3)\n\n    # 1. Convex Hull Area of Unvisited Nodes\n    # Set coordinates of visited nodes to a large value so they don't affect the hull\n    masked_coords = coords.clone()\n    masked_coords[~unvisited_mask] = 1e9\n    \n    # Find the node with the minimum y-coordinate (and then x) to start the hull scan\n    min_y_coords, _ = masked_coords[:, :, 1].min(dim=1, keepdim=True)\n    is_min_y = (masked_coords[:, :, 1] == min_y_coords)\n    min_x_at_min_y, _ = (masked_coords[:, :, 0] + (~is_min_y) * 1e9).min(dim=1, keepdim=True)\n    is_start_node = is_min_y & (masked_coords[:, :, 0] == min_x_at_min_y)\n    start_node_idx = torch.argmax(is_start_node.float(), dim=1)\n    \n    # Calculate angles from the start node to all other unvisited nodes\n    start_node_coords = torch.gather(coords, 1, start_node_idx.view(-1, 1, 1).expand(-1, 1, 2))\n    delta = masked_coords - start_node_coords\n    angles = torch.atan2(delta[:, :, 1], delta[:, :, 0])\n    angles[~unvisited_mask] = 4.0 # Put visited nodes at the end after sorting\n    angles.scatter_(1, start_node_idx.unsqueeze(1), 4.0) # Start node also at the end\n\n    # Sort nodes by angle to get the convex hull vertex order\n    _, sorted_indices = torch.sort(angles, dim=1)\n    sorted_coords = torch.gather(coords, 1, sorted_indices.unsqueeze(-1).expand(-1, -1, 2))\n\n    # Shoelace formula for polygon area\n    x = sorted_coords[:, :, 0]\n    y = sorted_coords[:, :, 1]\n    # Area = 0.5 * |(x1*y2 + x2*y3 + ... + xn*y1) - (y1*x2 + y2*x3 + ... + yn*x1)|\n    area = 0.5 * torch.abs(torch.sum(x * torch.roll(y, -1, dims=1), dim=1) - torch.sum(y * torch.roll(x, -1, dims=1), dim=1))\n    \n    # The area is an approximation of the subproblem size. Scale it to be distance-like.\n    # Sqrt(area) is a length-like dimension.\n    hull_cost = torch.sqrt(area)\n    hull_cost[is_small_subproblem] = 0.0 # No area for <3 points\n\n    # 2. Connection Costs\n    current_node = state.current_node_index()\n    start_node = state.first_node_index()\n\n    # Distances from current/start to all nodes\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n\n    # Mask to find closest unvisited node\n    dist_to_unvisited = dist_from_current.clone()\n    dist_to_unvisited[~unvisited_mask] = float('inf')\n    connect_cost_current, _ = torch.min(dist_to_unvisited, dim=1, keepdim=False)\n\n    dist_to_unvisited_from_start = dist_from_start.clone()\n    dist_to_unvisited_from_start[~unvisited_mask] = float('inf')\n    connect_cost_start, _ = torch.min(dist_to_unvisited_from_start, dim=1, keepdim=False)\n\n    # Combine costs\n    value = hull_cost + connect_cost_current + connect_cost_start\n    value[is_terminal] = 0.0\n    \n    return value.unsqueeze(-1)", "stats": {"mse": 3.284633240966797, "rmse": 1.8123557159031438, "mse_tsp20": 3.284633240966797, "rmse_tsp20": 1.8123557159031438, "mse_tsp50": 8.050507896484374, "rmse_tsp50": 2.837341695405115, "mse_tsp100": 16.0167750859375, "rmse_tsp100": 4.002096336413892, "mse_worst": 16.0167750859375, "rmse_worst": 4.002096336413892}, "stats_text": "mse=3.28463; rmse=1.81236; mse_tsp100=16.0168; mse_tsp20=3.28463; mse_tsp50=8.05051; mse_worst=16.0168; rmse_tsp100=4.0021; rmse_tsp20=1.81236; rmse_tsp50=2.83734; rmse_worst=4.0021"}
{"score": 0.05769675402296268, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.", "code_hash": "df7489edeace72aa540d26fe77201af647d81f86388de9934a7284bd97b03348", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.}\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node = state.current_node_index().unsqueeze(-1).unsqueeze(-1).expand(-1, 1, dist_matrix.size(1))\n    # [B, 1, N]\n    current_distances = torch.gather(dist_matrix, 1, current_node)\n    # [B, N]\n    current_distances_squeezed = current_distances.squeeze(1)\n\n    # [B] -> [B, 1]\n    first_node = state.first_node_index().unsqueeze(-1)\n    # [B, 1]\n    dist_to_start = torch.gather(current_distances_squeezed, 1, first_node)\n\n    # For each unvisited node, find the minimum distance to any other node (including current)\n    # Create a mask that includes unvisited nodes and the current node as potential connection points\n    # [B, N]\n    connect_to_mask = unvisited_mask.clone()\n    # [B, N]\n    connect_to_mask.scatter_(1, state.current_node_index().unsqueeze(-1), True)\n    # [B, 1, N]\n    connect_to_mask_expanded = connect_to_mask.unsqueeze(1)\n\n    # Mask the distance matrix to only consider connections to valid nodes\n    # Set distances to invalid connection points to infinity\n    # [B, N, N]\n    masked_dist = dist_matrix.clone()\n    masked_dist[~connect_to_mask_expanded.expand_as(dist_matrix)] = torch.finfo(dist_matrix.dtype).max\n\n    # Find the minimum distance from each node to a valid connection point\n    # [B, N]\n    min_dist_to_connect, _ = torch.min(masked_dist, dim=2)\n\n    # Sum these minimum distances only for the unvisited nodes\n    # [B, N]\n    min_dist_to_connect.masked_fill_(~unvisited_mask, 0)\n    # [B]\n    sum_min_dists = torch.sum(min_dist_to_connect, dim=1)\n\n    # The total estimated cost is the sum of minimum connection costs for unvisited nodes\n    # plus the cost to return to the start node from the current node.\n    # [B]\n    value = sum_min_dists + dist_to_start.squeeze(1)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 4.035992338867188, "rmse": 2.0089779338925524, "mse_tsp20": 4.035992338867188, "rmse_tsp20": 2.0089779338925524, "mse_tsp50": 8.995781856640624, "rmse_tsp50": 2.9992968937136957, "mse_tsp100": 17.3319975609375, "rmse_tsp100": 4.163171574765745, "mse_worst": 17.3319975609375, "rmse_worst": 4.163171574765745}, "stats_text": "mse=4.03599; rmse=2.00898; mse_tsp100=17.332; mse_tsp20=4.03599; mse_tsp50=8.99578; mse_worst=17.332; rmse_tsp100=4.16317; rmse_tsp20=2.00898; rmse_tsp50=2.9993; rmse_worst=4.16317"}
{"score": 0.05030289270434993, "gamma": 1.0, "algorithm": "auto} def phi(state): \"\"\" Estimates future tour length based on the convex hull of unvisited nodes, plus connection costs. {The algorithm estimates the remaining tour length by summing three components: the perimeter of the convex hull of the unvisited nodes, the minimum distance from the current node to a node on the hull, and the minimum distance from the starting node to a node on the hull if it's unvisited.", "code_hash": "a0d8b8cd0955fa9b8200849b52e3cc78956528631d7eb1a3016d0bf7085d320a", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on the convex hull of unvisited nodes, plus connection costs.\n    {The algorithm estimates the remaining tour length by summing three components: the perimeter of the convex hull of the unvisited nodes, the minimum distance from the current node to a node on the hull, and the minimum distance from the starting node to a node on the hull if it's unvisited.}\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node_idx = state.current_node_index()\n    # [B]\n    start_node_idx = state.first_node_index()\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal states where few or no nodes are unvisited\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = n_unvisited <= 2\n    if is_terminal.all():\n        return torch.zeros(B, 1, device=device)\n\n    # 1. Calculate the convex hull perimeter of unvisited nodes\n    # A large value to effectively remove visited nodes from consideration\n    inf_val = coords.abs().max().item() * 1e3 if coords.numel() > 0 else 1e9\n    \n    # [B, N, 2], move visited nodes far away\n    unvisited_coords = torch.where(unvisited_mask.unsqueeze(-1), coords, torch.full_like(coords, inf_val))\n\n    # Find the bottom-left point (start of the hull) for each batch item\n    # [B, 2]\n    start_point_coords = torch.full_like(coords[:, 0, :], inf_val)\n    start_point_coords[:, 1] = unvisited_coords[:, :, 1].min(dim=1).values\n    # Break ties with the minimum x-coordinate\n    y_min_mask = (unvisited_coords[:, :, 1] == start_point_coords[:, 1].unsqueeze(1))\n    x_for_y_min = torch.where(y_min_mask, unvisited_coords[:, :, 0], torch.full_like(coords[:, 0, 0], inf_val))\n    start_point_coords[:, 0] = x_for_y_min.min(dim=1).values\n\n    # Calculate angles from the start point to all other unvisited points\n    # [B, N, 2]\n    vectors = unvisited_coords - start_point_coords.unsqueeze(1)\n    # [B, N]\n    angles = torch.atan2(vectors[..., 1], vectors[..., 0])\n    # Set angle for start point itself to a large negative value to keep it first\n    is_start_point = (unvisited_coords == start_point_coords.unsqueeze(1)).all(dim=-1)\n    angles = torch.where(is_start_point, -torch.pi * 2, angles)\n    # Set angles for visited points to a large value to sort them last\n    angles = torch.where(unvisited_mask, angles, torch.pi * 2)\n\n    # Sort indices by angle to get the hull path\n    # [B, N]\n    _, sorted_indices = torch.sort(angles, dim=1)\n    # [B, N, 2]\n    sorted_coords = torch.gather(coords, 1, sorted_indices.unsqueeze(-1).expand(-1, -1, 2))\n    \n    # Calculate perimeter of the sorted points (which form the convex hull)\n    # [B, N, 2]\n    rolled_coords = torch.roll(sorted_coords, shifts=-1, dims=1)\n    # [B, N]\n    segment_lengths = torch.linalg.norm(sorted_coords - rolled_coords, dim=-1)\n    # [B]\n    hull_perimeter = torch.where(n_unvisited > 0, segment_lengths.sum(dim=1), torch.tensor(0.0, device=device))\n\n    # 2. Minimum distance from current node to the convex hull (unvisited nodes)\n    # [B, N]\n    current_dists = torch.gather(dist_matrix, 1, current_node_idx.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    current_dists_unvisited = torch.where(unvisited_mask, current_dists, torch.full_like(current_dists, float('inf')))\n    # [B]\n    min_dist_to_hull = current_dists_unvisited.min(dim=1).values\n    # If no unvisited nodes, this will be inf; handle below.\n\n    # 3. Minimum distance from start node to the convex hull (if start node is unvisited)\n    # [B, N]\n    start_dists = torch.gather(dist_matrix, 1, start_node_idx.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    start_dists_unvisited = torch.where(unvisited_mask, start_dists, torch.full_like(start_dists, float('inf')))\n    # [B]\n    min_dist_from_start = start_dists_unvisited.min(dim=1).values\n    \n    # Check if start node has been visited\n    # [B]\n    start_node_visited_mask = state.visited_mask().gather(1, start_node_idx.unsqueeze(1)).squeeze(1)\n    # Cost is zero if start node is already visited or is the current node\n    start_connection_cost = torch.where(start_node_visited_mask | (current_node_idx == start_node_idx), 0.0, min_dist_from_start)\n    \n    # Combine the components\n    # [B]\n    total_value = hull_perimeter + min_dist_to_hull + start_connection_cost\n\n    # Final cleanup for terminal states\n    final_value = torch.where(is_terminal, 0.0, total_value)\n\n    return final_value.unsqueeze(-1)", "stats": {"mse": 4.669061997314453, "rmse": 2.1608012396595977, "mse_tsp20": 4.669061997314453, "rmse_tsp20": 2.1608012396595977, "mse_tsp50": 10.516099542578125, "rmse_tsp50": 3.242853611031205, "mse_tsp100": 19.87957245078125, "rmse_tsp100": 4.458651416155029, "mse_worst": 19.87957245078125, "rmse_worst": 4.458651416155029}, "stats_text": "mse=4.66906; rmse=2.1608; mse_tsp100=19.8796; mse_tsp20=4.66906; mse_tsp50=10.5161; mse_worst=19.8796; rmse_tsp100=4.45865; rmse_tsp20=2.1608; rmse_tsp50=3.24285; rmse_worst=4.45865"}
{"score": 3.4209696471518978, "gamma": -0.1, "algorithm": "Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.", "code_hash": "d5014fe6247751116f6de4174accdec9f7c2eafdcfcbe2f724c5ad25941cb364", "code": "# THOUGHT: {Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length using a Minimum Spanning Tree (MST) based heuristic.\n    The cost is the sum of three components:\n    1. The cost of the MST of the subgraph formed by the unvisited nodes. This provides a\n       tight lower bound on the optimal sub-tour length for these nodes.\n    2. The minimum cost to connect the current node to the set of unvisited nodes.\n    3. The minimum cost to connect the start node to the set of unvisited nodes,\n       which is necessary for closing the tour.\n    \n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n    \n    # 1. Calculate the cost of the MST on the unvisited nodes.\n    # Prim's algorithm for dense graphs.\n    # We will compute this only for batches where there are unvisited nodes.\n    # [B, N]\n    min_cost = torch.full((B, N), float('inf'), device=device)\n    # [B, N]\n    visited_in_mst = torch.zeros_like(unvisited_mask)\n    # [B]\n    mst_cost = torch.zeros(B, device=device)\n    \n    # Initialize Prim's: pick the first unvisited node as the starting point for the MST.\n    # Find the index of the first 'True' in unvisited_mask for each batch item.\n    first_unvisited_idx = torch.argmax(unvisited_mask.int(), dim=1)\n    \n    # Set the min_cost for the starting node of the MST to 0.\n    # This ensures it's the first one picked.\n    min_cost.scatter_(1, first_unvisited_idx.unsqueeze(1), 0)\n    \n    # Mask min_cost for nodes that are already visited in the main tour.\n    min_cost.masked_fill_(~unvisited_mask, float('inf'))\n\n    # Prim's algorithm loop executed in a parallelized way over N-1 steps.\n    # This is a fixed-iteration loop, avoiding dynamic Python loops.\n    for _ in range(N):\n        # Find the node `u` with the minimum cost that is unvisited in the MST.\n        # [B, 1]\n        u_idx = torch.argmin(min_cost, dim=1, keepdim=True)\n        # [B]\n        u_cost = torch.gather(min_cost, 1, u_idx).squeeze(1)\n        \n        # Add its cost to the total MST cost, handling inf for disconnected components.\n        mst_cost += torch.where(u_cost == float('inf'), 0, u_cost)\n        \n        # Mark `u` as visited in the MST and remove it from consideration.\n        visited_in_mst.scatter_(1, u_idx, True)\n        min_cost.scatter_(1, u_idx, float('inf'))\n\n        # Update min_costs for neighbors of `u`.\n        # [B, N]\n        dist_from_u = torch.gather(dist_matrix, 1, u_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        \n        # Update only if the new path through `u` is shorter and the neighbor is unvisited in MST.\n        # We also need to ensure the neighbor is part of the unvisited set for the main tour.\n        update_mask = (dist_from_u < min_cost) & ~visited_in_mst & unvisited_mask\n        min_cost[update_mask] = dist_from_u[update_mask]\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    # Mask distances to already visited nodes.\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop).\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Total estimated cost\n    # For the case with only one unvisited node, MST cost is 0. The formula becomes\n    # dist(current -> last) + dist(start -> last), which is correct.\n    value = mst_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # For terminal states, future cost is 0.\n    value.masked_fill_(is_terminal, 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0.\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.18682559706115723, "rmse": 0.4322332669533399, "mse_tsp20": 0.18682559706115723, "rmse_tsp20": 0.4322332669533399, "mse_tsp50": 0.19572340977783204, "rmse_tsp50": 0.4424063853266949, "mse_tsp100": 0.2923147829833984, "rmse_tsp100": 0.5406614310114958, "mse_worst": 0.2923147829833984, "rmse_worst": 0.5406614310114958}, "stats_text": "mse=0.186826; rmse=0.432233; mse_tsp100=0.292315; mse_tsp20=0.186826; mse_tsp50=0.195723; mse_worst=0.292315; rmse_tsp100=0.540661; rmse_tsp20=0.432233; rmse_tsp50=0.442406; rmse_worst=0.540661"}
{"score": 3.406448250786877, "gamma": -0.1, "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.", "code_hash": "a509be98760cefdd1fed21f2974aece62623fff8e8b93600894306f7a87ee209", "code": "# THOUGHT: {Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for a TSP state.\n    The estimation is based on three components:\n    1. The cost of a Minimum Spanning Tree (MST) over all unvisited nodes.\n    2. The minimum cost to connect the current node to one of the unvisited nodes.\n    3. The minimum cost to connect the start node to one of the unvisited nodes.\n    This heuristic approximates the cost of visiting all remaining nodes and returning home.\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # 1. MST cost on unvisited nodes\n    # Create a subgraph distance matrix for unvisited nodes\n    # [B, N, N]\n    unvisited_dist = dist_matrix.clone()\n    # Mask rows and columns for visited nodes by setting distances to infinity\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n\n    # Prim's algorithm for MST cost\n    # [B]\n    num_unvisited = unvisited_mask.sum(dim=1)\n    # [B, N], init with large values\n    min_cost = torch.full_like(unvisited_mask, float('inf'), dtype=dist_matrix.dtype)\n    # [B, N], init with False\n    in_mst = torch.zeros_like(unvisited_mask, dtype=torch.bool)\n    # [B]\n    mst_cost = torch.zeros(B, device=dist_matrix.device)\n\n    # Find the first unvisited node to start Prim's algorithm\n    # [B], indices of first unvisited nodes\n    start_node_idx = torch.where(unvisited_mask.any(1), unvisited_mask.float().argmax(1), -1)\n\n    # Set the cost of the starting node to 0\n    # Use scatter for batched indexing\n    min_cost.scatter_(1, start_node_idx.unsqueeze(1).clamp(min=0), 0)\n\n    # Prim's algorithm loop (vectorized)\n    # This loop runs N times, which is more than necessary but avoids dynamic loops\n    # and is safe because nodes already in MST won't be chosen again.\n    for _ in range(N):\n        # Select node `u` not in MST with the minimum cost\n        # [B, N]\n        cost_if_not_in_mst = min_cost.clone()\n        cost_if_not_in_mst.masked_fill_(in_mst, float('inf'))\n        # [B, 1]\n        u_cost, u_idx = cost_if_not_in_mst.min(dim=1, keepdim=True)\n\n        # Add cost to total and mark node as in MST\n        # This mask handles batches where no unvisited nodes are left (u_cost is inf)\n        is_finite_mask = torch.isfinite(u_cost.squeeze(-1))\n        mst_cost[is_finite_mask] += u_cost[is_finite_mask].squeeze(-1)\n        in_mst.scatter_(1, u_idx.clamp(min=0), True)\n\n        # Update min_cost for neighbors of `u`\n        # [B, 1, N]\n        dist_from_u = torch.gather(unvisited_dist, 1, u_idx.unsqueeze(-1).expand(-1, 1, N))\n        # [B, N]\n        dist_from_u_squeezed = dist_from_u.squeeze(1)\n        # [B, N]\n        min_cost = torch.min(min_cost, dist_from_u_squeezed)\n\n    # 2. Minimum cost from current node to any unvisited node\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_exp = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_exp)\n    # [B, N]\n    dist_from_current_squeezed = dist_from_current.squeeze(1)\n    dist_from_current_squeezed.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_to_unvisited = dist_from_current_squeezed.min(dim=1).values\n    min_to_unvisited.masked_fill_(num_unvisited == 0, 0) # If no unvisited, cost is 0\n\n    # 3. Minimum cost from start node to any unvisited node\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    first_node_exp = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_start = torch.gather(dist_matrix, 1, first_node_exp)\n    # [B, N]\n    dist_from_start_squeezed = dist_from_start.squeeze(1)\n    dist_from_start_squeezed.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_to_return = dist_from_start_squeezed.min(dim=1).values\n    min_to_return.masked_fill_(num_unvisited == 0, 0) # If no unvisited, cost is 0\n\n    # Total estimated cost\n    # Special case: if only one unvisited node, MST cost is 0. The cost is just to go there and back.\n    # [B]\n    is_one_unvisited = (num_unvisited == 1)\n    # [B, 1]\n    first_unvisited_idx = torch.where(is_one_unvisited, unvisited_mask.float().argmax(1).unsqueeze(-1), -1)\n    # [B, 1]\n    dist_curr_to_last = torch.gather(dist_from_current_squeezed, 1, first_unvisited_idx.clamp(min=0))\n    # [B, 1]\n    dist_last_to_start = torch.gather(dist_from_start_squeezed, 1, first_unvisited_idx.clamp(min=0))\n    # [B]\n    one_unvisited_cost = (dist_curr_to_last + dist_last_to_start).squeeze(-1)\n\n    # Combine costs\n    value = torch.where(is_one_unvisited, one_unvisited_cost, mst_cost + min_to_unvisited + min_to_return)\n\n    # Final state: tour complete, cost is 0\n    value.masked_fill_(num_unvisited == 0, 0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.19756102726745606, "rmse": 0.444478376602795, "mse_tsp20": 0.19756102726745606, "rmse_tsp20": 0.444478376602795, "mse_tsp50": 0.20184117449951172, "rmse_tsp50": 0.44926737528949473, "mse_tsp100": 0.29356089580078126, "rmse_tsp100": 0.5418126021059138, "mse_worst": 0.29356089580078126, "rmse_worst": 0.5418126021059138}, "stats_text": "mse=0.197561; rmse=0.444478; mse_tsp100=0.293561; mse_tsp20=0.197561; mse_tsp50=0.201841; mse_worst=0.293561; rmse_tsp100=0.541813; rmse_tsp20=0.444478; rmse_tsp50=0.449267; rmse_worst=0.541813"}
{"score": 3.3781803516081297, "gamma": 1.0, "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.", "code_hash": "54055c1f192cd4960761c781d6f2bc50f9e6fcc45c0de48c9b7057e7a6b4b015", "code": "# THOUGHT: {Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for TSP.\n    The estimate is composed of three parts:\n    1. The cost of a Minimum Spanning Tree (MST) over all unvisited nodes. This approximates\n       the shortest path needed to connect all remaining nodes.\n    2. The cost to connect the current node to the set of unvisited nodes (minimum edge).\n    3. The cost to connect the start node to the set of unvisited nodes (minimum edge).\n    This forms a lower bound on the remaining tour length, as it approximates a path\n    connecting the current node, all unvisited nodes, and returning to the start.\n\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # 1. Calculate the cost of the MST on the subgraph of unvisited nodes.\n    # We use a Prim's algorithm-like approach.\n    # Create a distance matrix for only the unvisited nodes.\n    # Mask rows and columns corresponding to visited nodes.\n    unvisited_dist_matrix = dist_matrix.clone()\n    # Mask rows for visited nodes\n    unvisited_dist_matrix.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n    # Mask columns for visited nodes\n    unvisited_dist_matrix.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n\n    # Prim's algorithm to find MST cost\n    # `in_mst` mask: nodes already included in the MST\n    in_mst = torch.zeros_like(unvisited_mask)\n    # `min_cost` array: min cost to connect each node to the MST\n    min_cost = torch.full((B, N), float('inf'), device=dist_matrix.device, dtype=dist_matrix.dtype)\n\n    # Find the first unvisited node to start Prim's algorithm\n    # This is guaranteed to exist if there are unvisited nodes.\n    first_unvisited_idx = torch.argmax(unvisited_mask.float(), dim=1, keepdim=True)\n\n    # Initialize: select the first unvisited node. Its cost to connect is 0.\n    min_cost.scatter_(1, first_unvisited_idx, 0)\n\n    # Iteratively add N-1 nodes to the MST (or until all unvisited are added)\n    # This loop is fixed to N, which is acceptable as it's not a Python loop.\n    mst_cost = torch.zeros(B, device=dist_matrix.device, dtype=dist_matrix.dtype)\n    for _ in range(N):\n        # Find the node not in MST with the minimum connection cost\n        cost_to_add = min_cost.clone()\n        cost_to_add.masked_fill_(in_mst, float('inf'))\n        # If no nodes are left to add (all unvisited are in mst), cost will be inf\n        min_val, new_node_idx = torch.min(cost_to_add, dim=1)\n\n        # Create a mask for valid additions (cost is not inf)\n        is_valid_addition = min_val != float('inf')\n        \n        # Add its cost to the total MST cost\n        mst_cost += min_val.where(is_valid_addition, torch.tensor(0.0, device=mst_cost.device))\n\n        # Add the new node to the MST\n        new_node_idx = new_node_idx.unsqueeze(1)\n        in_mst.scatter_(1, new_node_idx, True)\n\n        # Update min_cost for all nodes based on the newly added node\n        # Distances from the newly added node to all other nodes\n        dist_from_new = torch.gather(unvisited_dist_matrix, 1, new_node_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        min_cost = torch.min(min_cost, dist_from_new)\n\n    # 2. Find the minimum cost to connect the current node to any unvisited node.\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx)\n    # Mask distances to already visited nodes\n    dist_from_current.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # [B]\n    min_dist_from_current, _ = torch.min(dist_from_current.squeeze(1), dim=1)\n    # If no unvisited nodes, this cost is 0 (or inf, we handle it)\n    min_dist_from_current.masked_fill_(~unvisited_mask.any(dim=1), 0)\n\n    # 3. Find the minimum cost to connect the start node to any unvisited node.\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx)\n    # Mask distances to already visited nodes\n    dist_from_start.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start.squeeze(1), dim=1)\n    # If no unvisited nodes, this cost is 0\n    min_dist_from_start.masked_fill_(~unvisited_mask.any(dim=1), 0)\n    \n    # In terminal states, there are no unvisited nodes. The MST cost will be 0,\n    # and the connection costs will be 0. The only remaining cost is to return to start.\n    is_terminal = ~unvisited_mask.any(dim=1)\n    # [B]\n    dist_to_start_terminal = torch.gather(dist_matrix, 1, state.current_node_index().unsqueeze(1).unsqueeze(2)).squeeze()\n    dist_to_start_terminal = torch.gather(dist_to_start_terminal, 1, state.first_node_index().unsqueeze(1)).squeeze(1)\n\n    # Total estimated future cost\n    value = mst_cost + min_dist_from_current + min_dist_from_start\n    # For terminal states, the value is just the cost to return home\n    value = torch.where(is_terminal, dist_to_start_terminal, value)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.21352034575653075, "rmse": 0.4620826178904923, "mse_tsp20": 0.21352034575653075, "rmse_tsp20": 0.4620826178904923, "mse_tsp50": 0.20358135737304686, "rmse_tsp50": 0.4511999084364345, "mse_tsp100": 0.2960173513305664, "rmse_tsp100": 0.5440747663056672, "mse_worst": 0.2960173513305664, "rmse_worst": 0.5440747663056672}, "stats_text": "mse=0.21352; rmse=0.462083; mse_tsp100=0.296017; mse_tsp20=0.21352; mse_tsp50=0.203581; mse_worst=0.296017; rmse_tsp100=0.544075; rmse_tsp20=0.462083; rmse_tsp50=0.4512; rmse_worst=0.544075"}
{"score": 2.423034464838014, "gamma": -0.1, "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.", "code_hash": "1b3b0812ca98a6aa6a8fb459b2e47dca3884b0f5419dcd0d7504221710b3f7b9", "code": "# THOUGHT: {Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length by approximating a path through unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes. For each unvisited node,\n       we find the distance to its two nearest neighbors among the other unvisited nodes.\n       The sum of these distances, averaged over all unvisited nodes, provides an estimate\n       of the local path cost. This is scaled by the number of unvisited nodes.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n    is_last_step = (num_unvisited == 1)\n    is_penultimate = (num_unvisited == 2)\n\n    # 1. Approximate sub-tour length through unvisited nodes\n    # Create a distance matrix only considering unvisited nodes.\n    # We set distances to/from visited nodes to infinity.\n    unvisited_dist = dist_matrix.clone()\n    inf = torch.finfo(dist_matrix.dtype).max\n    # Mask rows (from) and columns (to) corresponding to visited nodes\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), inf)\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), inf)\n\n    # For each unvisited node, find the distances to its two nearest unvisited neighbors.\n    # We use k=3 because the node itself is included with distance 0.\n    # [B, N, 3]\n    k = min(3, N) # handle N < 3 case\n    topk_dists, _ = torch.topk(unvisited_dist, k, dim=2, largest=False)\n\n    # The first value (k=0) is always 0 (distance to self), so we take k=1 and k=2.\n    # Sum of distances to two nearest neighbors for each node.\n    # If less than 3 unvisited nodes, some of these will be inf.\n    if k > 2:\n        two_nn_dist_sum = topk_dists[:, :, 1] + topk_dists[:, :, 2] # [B, N]\n    elif k > 1:\n        two_nn_dist_sum = topk_dists[:, :, 1] # [B, N]\n    else:\n        two_nn_dist_sum = torch.zeros_like(unvisited_mask, dtype=dist_matrix.dtype)\n\n\n    # Mask out the sums for visited nodes\n    two_nn_dist_sum.masked_fill_(~unvisited_mask, 0.0)\n\n    # The sum of these distances over all unvisited nodes, divided by 2 (since each edge is counted twice),\n    # approximates the MST length, which is a lower bound on the tour length.\n    # We use the sum directly as a heuristic.\n    subtour_cost = torch.sum(two_nn_dist_sum, dim=1) / 2.0\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    # [B]\n    min_dist_to_unvisited = torch.min(dist_from_current.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # 3. Cost to connect the start node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    # [B]\n    min_dist_from_start = torch.min(dist_from_start.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # Combine the components\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # Handle edge cases where subtour_cost is not well-defined\n    # If only two unvisited nodes, cost is current->A->B->start or current->B->A->start\n    if torch.any(is_penultimate):\n      # [B_pen, 2]\n      unvisited_indices = unvisited_mask[is_penultimate.squeeze(-1)].long().nonzero(as_tuple=False)[:, 1].view(-1, 2)\n      node_a_idx, node_b_idx = unvisited_indices[:, 0], unvisited_indices[:, 1]\n      \n      current_node_pen = state.current_node_index()[is_penultimate.squeeze(-1)]\n      start_node_pen = state.first_node_index()[is_penultimate.squeeze(-1)]\n      dist_matrix_pen = dist_matrix[is_penultimate.squeeze(-1)]\n\n      dist_curr_a = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_a_idx]\n      dist_curr_b = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_b_idx]\n      dist_a_b = dist_matrix_pen[torch.arange(len(node_a_idx)), node_a_idx, node_b_idx]\n      dist_a_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_a_idx, start_node_pen]\n      dist_b_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_b_idx, start_node_pen]\n      \n      cost1 = dist_curr_a + dist_a_b + dist_b_start\n      cost2 = dist_curr_b + dist_a_b + dist_a_start\n      penultimate_cost = torch.min(cost1, cost2)\n      value[is_penultimate.squeeze(-1)] = penultimate_cost\n\n    # If only one unvisited node, cost is current -> last -> start\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step.squeeze(-1)].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_from_current[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        dist_last_to_start = torch.gather(dist_from_start[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step.squeeze(-1)] = last_step_cost\n    \n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.2396109479522705, "rmse": 0.48950071292314834, "mse_tsp20": 0.2396109479522705, "rmse_tsp20": 0.48950071292314834, "mse_tsp50": 0.24980534642333985, "rmse_tsp50": 0.4998053085185669, "mse_tsp100": 0.41270564431152346, "rmse_tsp100": 0.6424217028646553, "mse_worst": 0.41270564431152346, "rmse_worst": 0.6424217028646553}, "stats_text": "mse=0.239611; rmse=0.489501; mse_tsp100=0.412706; mse_tsp20=0.239611; mse_tsp50=0.249805; mse_worst=0.412706; rmse_tsp100=0.642422; rmse_tsp20=0.489501; rmse_tsp50=0.499805; rmse_worst=0.642422"}
{"score": 0.7280720372806312, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.", "code_hash": "0cc2a43e13841f036b76914d86123d54dbc39c9e3e58d8eeb12c85a3cec64035", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.}\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node_idx = state.current_node_index()\n    # [B]\n    first_node_idx = state.first_node_index()\n    # [B]\n    batch_indices = torch.arange(dist_matrix.size(0), device=dist_matrix.device)\n\n    # Cost to return to the start node from the current node\n    # [B]\n    dist_to_start = dist_matrix[batch_indices, current_node_idx, first_node_idx]\n\n    # For each unvisited node, find its minimum connection cost to any other node.\n    # We set diagonal to infinity to avoid picking the zero-cost self-connection.\n    # [B, N, N]\n    dist_matrix_no_self = dist_matrix + torch.diag(torch.full((dist_matrix.size(1),), float('inf'), device=dist_matrix.device))\n    # [B, N]\n    min_dist_per_node, _ = torch.min(dist_matrix_no_self, dim=2)\n    \n    # Sum these minimum distances only for the unvisited nodes\n    # [B, N]\n    min_dist_per_node.masked_fill_(~unvisited_mask, 0)\n    # [B]\n    sum_min_dists = torch.sum(min_dist_per_node, dim=1)\n    \n    # The total estimated cost is the sum of minimum connection costs for unvisited nodes\n    # plus the cost to return to the start node from the current node.\n    # [B]\n    value = sum_min_dists + dist_to_start\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.4083288623046875, "rmse": 0.6390061520084822, "mse_tsp20": 0.4083288623046875, "rmse_tsp20": 0.6390061520084822, "mse_tsp50": 0.7378879370117187, "rmse_tsp50": 0.8590040378320225, "mse_tsp100": 1.3734904635742187, "rmse_tsp100": 1.1719600947021271, "mse_worst": 1.3734904635742187, "rmse_worst": 1.1719600947021271}, "stats_text": "mse=0.408329; rmse=0.639006; mse_tsp100=1.37349; mse_tsp20=0.408329; mse_tsp50=0.737888; mse_worst=1.37349; rmse_tsp100=1.17196; rmse_tsp20=0.639006; rmse_tsp50=0.859004; rmse_worst=1.17196"}
{"score": 0.14442194401455405, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The algorithm estimates the remaining tour length by multiplying the number of unvisited nodes by the average minimum distance from each unvisited node to any other unvisited node.", "code_hash": "948da801474913ef9ed2db71f330b186f78363384b494b85e41c1da0b92ac1a8", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The algorithm estimates the remaining tour length by multiplying the number of unvisited nodes by the average minimum distance from each unvisited node to any other unvisited node.}\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    n_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # For terminal states, the future cost is zero.\n    is_not_terminal = n_unvisited > 1\n    if not is_not_terminal.any():\n        return torch.zeros(dist_matrix.size(0), 1, device=dist_matrix.device)\n\n    # A large value to mask out irrelevant distances\n    large_value = dist_matrix.max() * 2 + 1 if dist_matrix.numel() > 0 else 1e9\n\n    # Create a temporary distance matrix where distances to/from visited nodes are masked\n    # [B, N, N]\n    temp_dist_matrix = dist_matrix.clone()\n    # Mask rows and columns corresponding to visited nodes\n    visited_mask = ~unvisited_mask\n    temp_dist_matrix[visited_mask, :] = large_value\n    temp_dist_matrix[:, visited_mask] = large_value\n    # Mask self-loops\n    temp_dist_matrix.diagonal(dim1=-2, dim2=-1).fill_(large_value)\n\n    # Find the minimum distance from each unvisited node to another unvisited node\n    # [B, N]\n    min_dists, _ = temp_dist_matrix.min(dim=2)\n\n    # Set distances from visited nodes to 0 so they don't affect the sum\n    min_dists.masked_fill_(visited_mask, 0)\n\n    # Calculate the average of these minimum distances\n    # Use a safe divisor to avoid division by zero for terminal states\n    safe_n_unvisited = torch.where(n_unvisited > 0, n_unvisited, torch.ones_like(n_unvisited))\n    # [B]\n    avg_min_dist = min_dists.sum(dim=1) / safe_n_unvisited\n\n    # Estimate the remaining tour length\n    # [B]\n    remaining_tour_length = n_unvisited * avg_min_dist\n\n    # Ensure terminal states have zero value\n    value = torch.where(is_not_terminal, remaining_tour_length, torch.tensor(0.0, device=dist_matrix.device))\n\n    return value.unsqueeze(-1)", "stats": {"mse": 1.8778033940429688, "rmse": 1.3703296661909385, "mse_tsp20": 1.8778033940429688, "rmse_tsp20": 1.3703296661909385, "mse_tsp50": 3.856727740234375, "rmse_tsp50": 1.9638553256883193, "mse_tsp100": 6.9241555140625, "rmse_tsp100": 2.6313790137611304, "mse_worst": 6.9241555140625, "rmse_worst": 2.6313790137611304}, "stats_text": "mse=1.8778; rmse=1.37033; mse_tsp100=6.92416; mse_tsp20=1.8778; mse_tsp50=3.85673; mse_worst=6.92416; rmse_tsp100=2.63138; rmse_tsp20=1.37033; rmse_tsp50=1.96386; rmse_worst=2.63138"}
{"score": 0.11230624864292459, "gamma": -0.1, "algorithm": "Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.", "code_hash": "0e7601ed649dfde68fc9175671d4df815cf1f6e8088ee79de00b3b2d9f6dd931", "code": "# THOUGHT: {Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on the geometric properties of unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes using the area of their convex hull.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n    This combines a geometric heuristic for the bulk of the path with connection costs.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n\n    # 1. Approximate sub-tour length using convex hull area of unvisited nodes\n    # A heuristic for tour length is related to the square root of the area of the convex hull.\n    # We use a simplified proxy: the area of the bounding box of unvisited nodes.\n\n    # Mask coordinates of visited nodes to exclude them from min/max calculations\n    # [B, N, 2]\n    masked_coords = coords.clone()\n    # Use a large value for visited nodes so they don't affect min, and a small value for max\n    large_val = torch.finfo(coords.dtype).max\n    small_val = torch.finfo(coords.dtype).min\n    # [B, N, 1]\n    unvisited_mask_exp = unvisited_mask.unsqueeze(-1)\n    masked_coords.masked_fill_(~unvisited_mask_exp, large_val)\n    min_coords, _ = torch.min(masked_coords, dim=1)  # [B, 2]\n\n    masked_coords = coords.clone()\n    masked_coords.masked_fill_(~unvisited_mask_exp, small_val)\n    max_coords, _ = torch.max(masked_coords, dim=1)  # [B, 2]\n\n    # Calculate width and height of the bounding box\n    # [B, 2]\n    span = max_coords - min_coords\n    # Clamp to avoid negative span if only one node is left\n    span = torch.clamp(span, min=0.0)\n    # [B]\n    area = span[:, 0] * span[:, 1]\n    # Heuristic for tour length: k * sqrt(Area * num_unvisited), k is an empirical factor\n    # For a unit square with N points, E[tour_len] ~ beta * sqrt(N), and Area=1.\n    # We use a simplified form: sqrt(Area) as a proxy for the spatial scale.\n    # The sum of two sides of the bounding box is a reasonable perimeter proxy.\n    subtour_cost = span[:, 0] + span[:, 1]\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, torch.finfo(dist_from_current.dtype).max)\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop)\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, torch.finfo(dist_from_start.dtype).max)\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Combine the components\n    # [B]\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n    \n    # Handle edge case where only one unvisited node remains\n    # The cost is just from current -> last_unvisited -> start\n    is_last_step = (num_unvisited.squeeze(-1) == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step]\n\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix[is_last_step, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix[is_last_step, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step] = last_step_cost\n\n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set if num_unvisited=0) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.9090601949462891, "rmse": 0.9534464824762264, "mse_tsp20": 0.9090601949462891, "rmse_tsp20": 0.9534464824762264, "mse_tsp50": 3.432229481640625, "rmse_tsp50": 1.852627723435182, "mse_tsp100": 8.904224048828125, "rmse_tsp100": 2.9839946462465585, "mse_worst": 8.904224048828125, "rmse_worst": 2.9839946462465585}, "stats_text": "mse=0.90906; rmse=0.953446; mse_tsp100=8.90422; mse_tsp20=0.90906; mse_tsp50=3.43223; mse_worst=8.90422; rmse_tsp100=2.98399; rmse_tsp20=0.953446; rmse_tsp50=1.85263; rmse_worst=2.98399"}
{"score": 0.07782706118698951, "gamma": -0.1, "algorithm": "Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.", "code_hash": "5fd3309104022111fb964be45f064a888499b1e8ed8f66c21cadfee07bffcee5", "code": "# THOUGHT: {Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length by averaging connection costs to the unvisited set.\n    The value is the sum of two components:\n    1. The average distance from the current node to all unvisited nodes.\n    2. The average distance from the start node to all unvisited nodes (to close the tour).\n    This heuristic focuses on the expected cost of the next and final connections.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N = unvisited_mask.shape\n    device = unvisited_mask.device\n    \n    # [B, 1]\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)\n    is_done = (num_unvisited == 0)\n\n    # Use a small epsilon to avoid division by zero when no nodes are unvisited\n    # The result for this case will be masked out later anyway.\n    num_unvisited_safe = num_unvisited.clamp(min=1.0)\n\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n\n    # 1. Average distance from the current node to the unvisited set\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    \n    # Mask out distances to already visited nodes\n    dist_from_current_unvisited = dist_from_current.masked_fill(~unvisited_mask, 0.0)\n    \n    # [B, 1]\n    sum_dist_from_current = dist_from_current_unvisited.sum(dim=1, keepdim=True)\n    avg_dist_from_current = sum_dist_from_current / num_unvisited_safe\n\n    # 2. Average distance from the start node to the unvisited set (for closing the loop)\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n\n    # Mask out distances to already visited nodes\n    dist_from_start_unvisited = dist_from_start.masked_fill(~unvisited_mask, 0.0)\n\n    # [B, 1]\n    sum_dist_from_start = dist_from_start_unvisited.sum(dim=1, keepdim=True)\n    avg_dist_from_start = sum_dist_from_start / num_unvisited_safe\n\n    # Combine the components\n    # [B, 1]\n    value = avg_dist_from_current + avg_dist_from_start\n    \n    # Handle the special case where only one unvisited node remains.\n    # The cost is exactly current -> last -> start.\n    is_last_step = (num_unvisited == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step.squeeze(-1)].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step.squeeze(-1)]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step.squeeze(-1)]\n        \n        # [B_last, N, N]\n        dist_matrix_last = dist_matrix[is_last_step.squeeze(-1)]\n        \n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix_last[:, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix_last[:, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = (dist_curr_to_last + dist_last_to_start).unsqueeze(-1)\n        value = torch.where(is_last_step, last_step_cost, value)\n\n    # If the tour is done, the future cost is zero.\n    value.masked_fill_(is_done, 0.0)\n\n    return value", "stats": {"mse": 1.5873716700439453, "rmse": 1.2599093896165492, "mse_tsp20": 1.5873716700439453, "rmse_tsp20": 1.2599093896165492, "mse_tsp50": 4.672369123242188, "rmse_tsp50": 2.161566358741315, "mse_tsp100": 12.849001166796874, "rmse_tsp100": 3.58455034373865, "mse_worst": 12.849001166796874, "rmse_worst": 3.58455034373865}, "stats_text": "mse=1.58737; rmse=1.25991; mse_tsp100=12.849; mse_tsp20=1.58737; mse_tsp50=4.67237; mse_worst=12.849; rmse_tsp100=3.58455; rmse_tsp20=1.25991; rmse_tsp50=2.16157; rmse_worst=3.58455"}
{"score": 0.07266666341623383, "gamma": 1.0, "algorithm": "Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.", "code_hash": "884346de00c0f4e4ef075e61c49dd857c93553fc2d00215ba1795fcf9caa8a84", "code": "# THOUGHT: {Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on average distances to the set of unvisited nodes.\n    This heuristic considers the expected cost to connect the current path segment back\n    to the main cluster of unvisited nodes, and then eventually close the tour from that\n    cluster back to the start node. It uses average distance as a robust proxy for\n    these connection costs, avoiding reliance on single min/max values which can be noisy.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n    device = dist_matrix.device\n\n    # [B]\n    num_unvisited = unvisited_mask.sum(dim=1)\n    # Avoid division by zero for terminal states.\n    # The final value for terminal states will be masked to 0 anyway.\n    num_unvisited_safe = torch.clamp(num_unvisited, min=1.0)\n\n    # 1. Calculate the average distance from the current node to all unvisited nodes.\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    # Mask out distances to already visited nodes by setting them to 0.\n    dist_from_current_unvisited = dist_from_current * unvisited_mask\n    # [B]\n    avg_dist_from_current = dist_from_current_unvisited.sum(dim=1) / num_unvisited_safe\n\n    # 2. Calculate the average distance from the start node to all unvisited nodes.\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    # Mask out distances to already visited nodes.\n    dist_from_start_unvisited = dist_from_start * unvisited_mask\n    # [B]\n    avg_dist_from_start = dist_from_start_unvisited.sum(dim=1) / num_unvisited_safe\n\n    # 3. Handle the case where only one unvisited node remains.\n    # The cost is exactly current -> last_unvisited -> start.\n    is_last_step = (num_unvisited == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step]\n\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix[is_last_step, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix[is_last_step, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        # For the last step, the average distances are just the exact distances, so this is correct.\n        avg_dist_from_current[is_last_step] = dist_curr_to_last\n        avg_dist_from_start[is_last_step] = dist_last_to_start\n\n    # Combine the two average distance components.\n    # This represents the cost to enter the unvisited cluster and the cost to leave it to finish the tour.\n    value = avg_dist_from_current + avg_dist_from_start\n\n    # If the tour is done (num_unvisited is 0), the future cost is 0.\n    is_done = (num_unvisited == 0)\n    value.masked_fill_(is_done, 0.0)\n\n    # Return broadcastable shape [B, 1]\n    return value.unsqueeze(-1)", "stats": {"mse": 2.3418170474853515, "rmse": 1.5302996593756895, "mse_tsp20": 2.3418170474853515, "rmse_tsp20": 1.5302996593756895, "mse_tsp50": 6.4205319578125, "rmse_tsp50": 2.5338768631905735, "mse_tsp100": 13.76146850546875, "rmse_tsp100": 3.709645334188802, "mse_worst": 13.76146850546875, "rmse_worst": 3.709645334188802}, "stats_text": "mse=2.34182; rmse=1.5303; mse_tsp100=13.7615; mse_tsp20=2.34182; mse_tsp50=6.42053; mse_worst=13.7615; rmse_tsp100=3.70965; rmse_tsp20=1.5303; rmse_tsp50=2.53388; rmse_worst=3.70965"}
{"score": 0.0624345409506303, "gamma": 1.0, "algorithm": "auto} def phi(state): \"\"\" {Estimates future tour length based on the convex hull area of unvisited nodes, plus connection costs.", "code_hash": "627d91b23b0370ff838ed2c69bc931795333336d40829148afcc16965d6b24a6", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimates future tour length based on the convex hull area of unvisited nodes, plus connection costs.}\n    The heuristic has three parts:\n    1. The area of the convex hull of the unvisited nodes, scaled by a factor. This approximates the density and spread of the remaining problem.\n    2. The cost to connect the current node to the closest unvisited node.\n    3. The cost to connect the start node to the closest unvisited node (approximating the tour completion cost).\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    num_unvisited = unvisited_mask.sum(dim=1)\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n\n    # Handle terminal state: if no nodes are unvisited, the future cost is zero.\n    is_terminal = (num_unvisited == 0)\n    # Handle case with < 3 unvisited nodes where convex hull is undefined/zero area\n    is_small_subproblem = (num_unvisited < 3)\n\n    # 1. Convex Hull Area of Unvisited Nodes\n    # Set coordinates of visited nodes to a large value so they don't affect the hull\n    masked_coords = coords.clone()\n    masked_coords[~unvisited_mask] = 1e9\n    \n    # Find the node with the minimum y-coordinate (and then x) to start the hull scan\n    min_y_coords, _ = masked_coords[:, :, 1].min(dim=1, keepdim=True)\n    is_min_y = (masked_coords[:, :, 1] == min_y_coords)\n    min_x_at_min_y, _ = (masked_coords[:, :, 0] + (~is_min_y) * 1e9).min(dim=1, keepdim=True)\n    is_start_node = is_min_y & (masked_coords[:, :, 0] == min_x_at_min_y)\n    start_node_idx = torch.argmax(is_start_node.float(), dim=1)\n    \n    # Calculate angles from the start node to all other unvisited nodes\n    start_node_coords = torch.gather(coords, 1, start_node_idx.view(-1, 1, 1).expand(-1, 1, 2))\n    delta = masked_coords - start_node_coords\n    angles = torch.atan2(delta[:, :, 1], delta[:, :, 0])\n    angles[~unvisited_mask] = 4.0 # Put visited nodes at the end after sorting\n    angles.scatter_(1, start_node_idx.unsqueeze(1), 4.0) # Start node also at the end\n\n    # Sort nodes by angle to get the convex hull vertex order\n    _, sorted_indices = torch.sort(angles, dim=1)\n    sorted_coords = torch.gather(coords, 1, sorted_indices.unsqueeze(-1).expand(-1, -1, 2))\n\n    # Shoelace formula for polygon area\n    x = sorted_coords[:, :, 0]\n    y = sorted_coords[:, :, 1]\n    # Area = 0.5 * |(x1*y2 + x2*y3 + ... + xn*y1) - (y1*x2 + y2*x3 + ... + yn*x1)|\n    area = 0.5 * torch.abs(torch.sum(x * torch.roll(y, -1, dims=1), dim=1) - torch.sum(y * torch.roll(x, -1, dims=1), dim=1))\n    \n    # The area is an approximation of the subproblem size. Scale it to be distance-like.\n    # Sqrt(area) is a length-like dimension.\n    hull_cost = torch.sqrt(area)\n    hull_cost[is_small_subproblem] = 0.0 # No area for <3 points\n\n    # 2. Connection Costs\n    current_node = state.current_node_index()\n    start_node = state.first_node_index()\n\n    # Distances from current/start to all nodes\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n\n    # Mask to find closest unvisited node\n    dist_to_unvisited = dist_from_current.clone()\n    dist_to_unvisited[~unvisited_mask] = float('inf')\n    connect_cost_current, _ = torch.min(dist_to_unvisited, dim=1, keepdim=False)\n\n    dist_to_unvisited_from_start = dist_from_start.clone()\n    dist_to_unvisited_from_start[~unvisited_mask] = float('inf')\n    connect_cost_start, _ = torch.min(dist_to_unvisited_from_start, dim=1, keepdim=False)\n\n    # Combine costs\n    value = hull_cost + connect_cost_current + connect_cost_start\n    value[is_terminal] = 0.0\n    \n    return value.unsqueeze(-1)", "stats": {"mse": 3.284633240966797, "rmse": 1.8123557159031438, "mse_tsp20": 3.284633240966797, "rmse_tsp20": 1.8123557159031438, "mse_tsp50": 8.050507896484374, "rmse_tsp50": 2.837341695405115, "mse_tsp100": 16.0167750859375, "rmse_tsp100": 4.002096336413892, "mse_worst": 16.0167750859375, "rmse_worst": 4.002096336413892}, "stats_text": "mse=3.28463; rmse=1.81236; mse_tsp100=16.0168; mse_tsp20=3.28463; mse_tsp50=8.05051; mse_worst=16.0168; rmse_tsp100=4.0021; rmse_tsp20=1.81236; rmse_tsp50=2.83734; rmse_worst=4.0021"}
{"score": 3.4209696471518978, "gamma": -0.1, "algorithm": "Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.", "code_hash": "d5014fe6247751116f6de4174accdec9f7c2eafdcfcbe2f724c5ad25941cb364", "code": "# THOUGHT: {Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length using a Minimum Spanning Tree (MST) based heuristic.\n    The cost is the sum of three components:\n    1. The cost of the MST of the subgraph formed by the unvisited nodes. This provides a\n       tight lower bound on the optimal sub-tour length for these nodes.\n    2. The minimum cost to connect the current node to the set of unvisited nodes.\n    3. The minimum cost to connect the start node to the set of unvisited nodes,\n       which is necessary for closing the tour.\n    \n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n    \n    # 1. Calculate the cost of the MST on the unvisited nodes.\n    # Prim's algorithm for dense graphs.\n    # We will compute this only for batches where there are unvisited nodes.\n    # [B, N]\n    min_cost = torch.full((B, N), float('inf'), device=device)\n    # [B, N]\n    visited_in_mst = torch.zeros_like(unvisited_mask)\n    # [B]\n    mst_cost = torch.zeros(B, device=device)\n    \n    # Initialize Prim's: pick the first unvisited node as the starting point for the MST.\n    # Find the index of the first 'True' in unvisited_mask for each batch item.\n    first_unvisited_idx = torch.argmax(unvisited_mask.int(), dim=1)\n    \n    # Set the min_cost for the starting node of the MST to 0.\n    # This ensures it's the first one picked.\n    min_cost.scatter_(1, first_unvisited_idx.unsqueeze(1), 0)\n    \n    # Mask min_cost for nodes that are already visited in the main tour.\n    min_cost.masked_fill_(~unvisited_mask, float('inf'))\n\n    # Prim's algorithm loop executed in a parallelized way over N-1 steps.\n    # This is a fixed-iteration loop, avoiding dynamic Python loops.\n    for _ in range(N):\n        # Find the node `u` with the minimum cost that is unvisited in the MST.\n        # [B, 1]\n        u_idx = torch.argmin(min_cost, dim=1, keepdim=True)\n        # [B]\n        u_cost = torch.gather(min_cost, 1, u_idx).squeeze(1)\n        \n        # Add its cost to the total MST cost, handling inf for disconnected components.\n        mst_cost += torch.where(u_cost == float('inf'), 0, u_cost)\n        \n        # Mark `u` as visited in the MST and remove it from consideration.\n        visited_in_mst.scatter_(1, u_idx, True)\n        min_cost.scatter_(1, u_idx, float('inf'))\n\n        # Update min_costs for neighbors of `u`.\n        # [B, N]\n        dist_from_u = torch.gather(dist_matrix, 1, u_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        \n        # Update only if the new path through `u` is shorter and the neighbor is unvisited in MST.\n        # We also need to ensure the neighbor is part of the unvisited set for the main tour.\n        update_mask = (dist_from_u < min_cost) & ~visited_in_mst & unvisited_mask\n        min_cost[update_mask] = dist_from_u[update_mask]\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    # Mask distances to already visited nodes.\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop).\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Total estimated cost\n    # For the case with only one unvisited node, MST cost is 0. The formula becomes\n    # dist(current -> last) + dist(start -> last), which is correct.\n    value = mst_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # For terminal states, future cost is 0.\n    value.masked_fill_(is_terminal, 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0.\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.18682559706115723, "rmse": 0.4322332669533399, "mse_tsp20": 0.18682559706115723, "rmse_tsp20": 0.4322332669533399, "mse_tsp50": 0.19572340977783204, "rmse_tsp50": 0.4424063853266949, "mse_tsp100": 0.2923147829833984, "rmse_tsp100": 0.5406614310114958, "mse_worst": 0.2923147829833984, "rmse_worst": 0.5406614310114958}, "stats_text": "mse=0.186826; rmse=0.432233; mse_tsp100=0.292315; mse_tsp20=0.186826; mse_tsp50=0.195723; mse_worst=0.292315; rmse_tsp100=0.540661; rmse_tsp20=0.432233; rmse_tsp50=0.442406; rmse_worst=0.540661"}
{"score": 3.406448250786877, "gamma": -0.1, "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.", "code_hash": "a509be98760cefdd1fed21f2974aece62623fff8e8b93600894306f7a87ee209", "code": "# THOUGHT: {Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for a TSP state.\n    The estimation is based on three components:\n    1. The cost of a Minimum Spanning Tree (MST) over all unvisited nodes.\n    2. The minimum cost to connect the current node to one of the unvisited nodes.\n    3. The minimum cost to connect the start node to one of the unvisited nodes.\n    This heuristic approximates the cost of visiting all remaining nodes and returning home.\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # 1. MST cost on unvisited nodes\n    # Create a subgraph distance matrix for unvisited nodes\n    # [B, N, N]\n    unvisited_dist = dist_matrix.clone()\n    # Mask rows and columns for visited nodes by setting distances to infinity\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n\n    # Prim's algorithm for MST cost\n    # [B]\n    num_unvisited = unvisited_mask.sum(dim=1)\n    # [B, N], init with large values\n    min_cost = torch.full_like(unvisited_mask, float('inf'), dtype=dist_matrix.dtype)\n    # [B, N], init with False\n    in_mst = torch.zeros_like(unvisited_mask, dtype=torch.bool)\n    # [B]\n    mst_cost = torch.zeros(B, device=dist_matrix.device)\n\n    # Find the first unvisited node to start Prim's algorithm\n    # [B], indices of first unvisited nodes\n    start_node_idx = torch.where(unvisited_mask.any(1), unvisited_mask.float().argmax(1), -1)\n\n    # Set the cost of the starting node to 0\n    # Use scatter for batched indexing\n    min_cost.scatter_(1, start_node_idx.unsqueeze(1).clamp(min=0), 0)\n\n    # Prim's algorithm loop (vectorized)\n    # This loop runs N times, which is more than necessary but avoids dynamic loops\n    # and is safe because nodes already in MST won't be chosen again.\n    for _ in range(N):\n        # Select node `u` not in MST with the minimum cost\n        # [B, N]\n        cost_if_not_in_mst = min_cost.clone()\n        cost_if_not_in_mst.masked_fill_(in_mst, float('inf'))\n        # [B, 1]\n        u_cost, u_idx = cost_if_not_in_mst.min(dim=1, keepdim=True)\n\n        # Add cost to total and mark node as in MST\n        # This mask handles batches where no unvisited nodes are left (u_cost is inf)\n        is_finite_mask = torch.isfinite(u_cost.squeeze(-1))\n        mst_cost[is_finite_mask] += u_cost[is_finite_mask].squeeze(-1)\n        in_mst.scatter_(1, u_idx.clamp(min=0), True)\n\n        # Update min_cost for neighbors of `u`\n        # [B, 1, N]\n        dist_from_u = torch.gather(unvisited_dist, 1, u_idx.unsqueeze(-1).expand(-1, 1, N))\n        # [B, N]\n        dist_from_u_squeezed = dist_from_u.squeeze(1)\n        # [B, N]\n        min_cost = torch.min(min_cost, dist_from_u_squeezed)\n\n    # 2. Minimum cost from current node to any unvisited node\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_exp = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_exp)\n    # [B, N]\n    dist_from_current_squeezed = dist_from_current.squeeze(1)\n    dist_from_current_squeezed.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_to_unvisited = dist_from_current_squeezed.min(dim=1).values\n    min_to_unvisited.masked_fill_(num_unvisited == 0, 0) # If no unvisited, cost is 0\n\n    # 3. Minimum cost from start node to any unvisited node\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    first_node_exp = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_start = torch.gather(dist_matrix, 1, first_node_exp)\n    # [B, N]\n    dist_from_start_squeezed = dist_from_start.squeeze(1)\n    dist_from_start_squeezed.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_to_return = dist_from_start_squeezed.min(dim=1).values\n    min_to_return.masked_fill_(num_unvisited == 0, 0) # If no unvisited, cost is 0\n\n    # Total estimated cost\n    # Special case: if only one unvisited node, MST cost is 0. The cost is just to go there and back.\n    # [B]\n    is_one_unvisited = (num_unvisited == 1)\n    # [B, 1]\n    first_unvisited_idx = torch.where(is_one_unvisited, unvisited_mask.float().argmax(1).unsqueeze(-1), -1)\n    # [B, 1]\n    dist_curr_to_last = torch.gather(dist_from_current_squeezed, 1, first_unvisited_idx.clamp(min=0))\n    # [B, 1]\n    dist_last_to_start = torch.gather(dist_from_start_squeezed, 1, first_unvisited_idx.clamp(min=0))\n    # [B]\n    one_unvisited_cost = (dist_curr_to_last + dist_last_to_start).squeeze(-1)\n\n    # Combine costs\n    value = torch.where(is_one_unvisited, one_unvisited_cost, mst_cost + min_to_unvisited + min_to_return)\n\n    # Final state: tour complete, cost is 0\n    value.masked_fill_(num_unvisited == 0, 0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.19756102726745606, "rmse": 0.444478376602795, "mse_tsp20": 0.19756102726745606, "rmse_tsp20": 0.444478376602795, "mse_tsp50": 0.20184117449951172, "rmse_tsp50": 0.44926737528949473, "mse_tsp100": 0.29356089580078126, "rmse_tsp100": 0.5418126021059138, "mse_worst": 0.29356089580078126, "rmse_worst": 0.5418126021059138}, "stats_text": "mse=0.197561; rmse=0.444478; mse_tsp100=0.293561; mse_tsp20=0.197561; mse_tsp50=0.201841; mse_worst=0.293561; rmse_tsp100=0.541813; rmse_tsp20=0.444478; rmse_tsp50=0.449267; rmse_worst=0.541813"}
{"score": 3.3781803516081297, "gamma": 1.0, "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.", "code_hash": "54055c1f192cd4960761c781d6f2bc50f9e6fcc45c0de48c9b7057e7a6b4b015", "code": "# THOUGHT: {Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for TSP.\n    The estimate is composed of three parts:\n    1. The cost of a Minimum Spanning Tree (MST) over all unvisited nodes. This approximates\n       the shortest path needed to connect all remaining nodes.\n    2. The cost to connect the current node to the set of unvisited nodes (minimum edge).\n    3. The cost to connect the start node to the set of unvisited nodes (minimum edge).\n    This forms a lower bound on the remaining tour length, as it approximates a path\n    connecting the current node, all unvisited nodes, and returning to the start.\n\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # 1. Calculate the cost of the MST on the subgraph of unvisited nodes.\n    # We use a Prim's algorithm-like approach.\n    # Create a distance matrix for only the unvisited nodes.\n    # Mask rows and columns corresponding to visited nodes.\n    unvisited_dist_matrix = dist_matrix.clone()\n    # Mask rows for visited nodes\n    unvisited_dist_matrix.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n    # Mask columns for visited nodes\n    unvisited_dist_matrix.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n\n    # Prim's algorithm to find MST cost\n    # `in_mst` mask: nodes already included in the MST\n    in_mst = torch.zeros_like(unvisited_mask)\n    # `min_cost` array: min cost to connect each node to the MST\n    min_cost = torch.full((B, N), float('inf'), device=dist_matrix.device, dtype=dist_matrix.dtype)\n\n    # Find the first unvisited node to start Prim's algorithm\n    # This is guaranteed to exist if there are unvisited nodes.\n    first_unvisited_idx = torch.argmax(unvisited_mask.float(), dim=1, keepdim=True)\n\n    # Initialize: select the first unvisited node. Its cost to connect is 0.\n    min_cost.scatter_(1, first_unvisited_idx, 0)\n\n    # Iteratively add N-1 nodes to the MST (or until all unvisited are added)\n    # This loop is fixed to N, which is acceptable as it's not a Python loop.\n    mst_cost = torch.zeros(B, device=dist_matrix.device, dtype=dist_matrix.dtype)\n    for _ in range(N):\n        # Find the node not in MST with the minimum connection cost\n        cost_to_add = min_cost.clone()\n        cost_to_add.masked_fill_(in_mst, float('inf'))\n        # If no nodes are left to add (all unvisited are in mst), cost will be inf\n        min_val, new_node_idx = torch.min(cost_to_add, dim=1)\n\n        # Create a mask for valid additions (cost is not inf)\n        is_valid_addition = min_val != float('inf')\n        \n        # Add its cost to the total MST cost\n        mst_cost += min_val.where(is_valid_addition, torch.tensor(0.0, device=mst_cost.device))\n\n        # Add the new node to the MST\n        new_node_idx = new_node_idx.unsqueeze(1)\n        in_mst.scatter_(1, new_node_idx, True)\n\n        # Update min_cost for all nodes based on the newly added node\n        # Distances from the newly added node to all other nodes\n        dist_from_new = torch.gather(unvisited_dist_matrix, 1, new_node_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        min_cost = torch.min(min_cost, dist_from_new)\n\n    # 2. Find the minimum cost to connect the current node to any unvisited node.\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx)\n    # Mask distances to already visited nodes\n    dist_from_current.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # [B]\n    min_dist_from_current, _ = torch.min(dist_from_current.squeeze(1), dim=1)\n    # If no unvisited nodes, this cost is 0 (or inf, we handle it)\n    min_dist_from_current.masked_fill_(~unvisited_mask.any(dim=1), 0)\n\n    # 3. Find the minimum cost to connect the start node to any unvisited node.\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx)\n    # Mask distances to already visited nodes\n    dist_from_start.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start.squeeze(1), dim=1)\n    # If no unvisited nodes, this cost is 0\n    min_dist_from_start.masked_fill_(~unvisited_mask.any(dim=1), 0)\n    \n    # In terminal states, there are no unvisited nodes. The MST cost will be 0,\n    # and the connection costs will be 0. The only remaining cost is to return to start.\n    is_terminal = ~unvisited_mask.any(dim=1)\n    # [B]\n    dist_to_start_terminal = torch.gather(dist_matrix, 1, state.current_node_index().unsqueeze(1).unsqueeze(2)).squeeze()\n    dist_to_start_terminal = torch.gather(dist_to_start_terminal, 1, state.first_node_index().unsqueeze(1)).squeeze(1)\n\n    # Total estimated future cost\n    value = mst_cost + min_dist_from_current + min_dist_from_start\n    # For terminal states, the value is just the cost to return home\n    value = torch.where(is_terminal, dist_to_start_terminal, value)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.21352034575653075, "rmse": 0.4620826178904923, "mse_tsp20": 0.21352034575653075, "rmse_tsp20": 0.4620826178904923, "mse_tsp50": 0.20358135737304686, "rmse_tsp50": 0.4511999084364345, "mse_tsp100": 0.2960173513305664, "rmse_tsp100": 0.5440747663056672, "mse_worst": 0.2960173513305664, "rmse_worst": 0.5440747663056672}, "stats_text": "mse=0.21352; rmse=0.462083; mse_tsp100=0.296017; mse_tsp20=0.21352; mse_tsp50=0.203581; mse_worst=0.296017; rmse_tsp100=0.544075; rmse_tsp20=0.462083; rmse_tsp50=0.4512; rmse_worst=0.544075"}
{"score": 2.423034464838014, "gamma": -0.1, "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.", "code_hash": "1b3b0812ca98a6aa6a8fb459b2e47dca3884b0f5419dcd0d7504221710b3f7b9", "code": "# THOUGHT: {Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length by approximating a path through unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes. For each unvisited node,\n       we find the distance to its two nearest neighbors among the other unvisited nodes.\n       The sum of these distances, averaged over all unvisited nodes, provides an estimate\n       of the local path cost. This is scaled by the number of unvisited nodes.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n    is_last_step = (num_unvisited == 1)\n    is_penultimate = (num_unvisited == 2)\n\n    # 1. Approximate sub-tour length through unvisited nodes\n    # Create a distance matrix only considering unvisited nodes.\n    # We set distances to/from visited nodes to infinity.\n    unvisited_dist = dist_matrix.clone()\n    inf = torch.finfo(dist_matrix.dtype).max\n    # Mask rows (from) and columns (to) corresponding to visited nodes\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), inf)\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), inf)\n\n    # For each unvisited node, find the distances to its two nearest unvisited neighbors.\n    # We use k=3 because the node itself is included with distance 0.\n    # [B, N, 3]\n    k = min(3, N) # handle N < 3 case\n    topk_dists, _ = torch.topk(unvisited_dist, k, dim=2, largest=False)\n\n    # The first value (k=0) is always 0 (distance to self), so we take k=1 and k=2.\n    # Sum of distances to two nearest neighbors for each node.\n    # If less than 3 unvisited nodes, some of these will be inf.\n    if k > 2:\n        two_nn_dist_sum = topk_dists[:, :, 1] + topk_dists[:, :, 2] # [B, N]\n    elif k > 1:\n        two_nn_dist_sum = topk_dists[:, :, 1] # [B, N]\n    else:\n        two_nn_dist_sum = torch.zeros_like(unvisited_mask, dtype=dist_matrix.dtype)\n\n\n    # Mask out the sums for visited nodes\n    two_nn_dist_sum.masked_fill_(~unvisited_mask, 0.0)\n\n    # The sum of these distances over all unvisited nodes, divided by 2 (since each edge is counted twice),\n    # approximates the MST length, which is a lower bound on the tour length.\n    # We use the sum directly as a heuristic.\n    subtour_cost = torch.sum(two_nn_dist_sum, dim=1) / 2.0\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    # [B]\n    min_dist_to_unvisited = torch.min(dist_from_current.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # 3. Cost to connect the start node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    # [B]\n    min_dist_from_start = torch.min(dist_from_start.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # Combine the components\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # Handle edge cases where subtour_cost is not well-defined\n    # If only two unvisited nodes, cost is current->A->B->start or current->B->A->start\n    if torch.any(is_penultimate):\n      # [B_pen, 2]\n      unvisited_indices = unvisited_mask[is_penultimate.squeeze(-1)].long().nonzero(as_tuple=False)[:, 1].view(-1, 2)\n      node_a_idx, node_b_idx = unvisited_indices[:, 0], unvisited_indices[:, 1]\n      \n      current_node_pen = state.current_node_index()[is_penultimate.squeeze(-1)]\n      start_node_pen = state.first_node_index()[is_penultimate.squeeze(-1)]\n      dist_matrix_pen = dist_matrix[is_penultimate.squeeze(-1)]\n\n      dist_curr_a = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_a_idx]\n      dist_curr_b = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_b_idx]\n      dist_a_b = dist_matrix_pen[torch.arange(len(node_a_idx)), node_a_idx, node_b_idx]\n      dist_a_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_a_idx, start_node_pen]\n      dist_b_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_b_idx, start_node_pen]\n      \n      cost1 = dist_curr_a + dist_a_b + dist_b_start\n      cost2 = dist_curr_b + dist_a_b + dist_a_start\n      penultimate_cost = torch.min(cost1, cost2)\n      value[is_penultimate.squeeze(-1)] = penultimate_cost\n\n    # If only one unvisited node, cost is current -> last -> start\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step.squeeze(-1)].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_from_current[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        dist_last_to_start = torch.gather(dist_from_start[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step.squeeze(-1)] = last_step_cost\n    \n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.2396109479522705, "rmse": 0.48950071292314834, "mse_tsp20": 0.2396109479522705, "rmse_tsp20": 0.48950071292314834, "mse_tsp50": 0.24980534642333985, "rmse_tsp50": 0.4998053085185669, "mse_tsp100": 0.41270564431152346, "rmse_tsp100": 0.6424217028646553, "mse_worst": 0.41270564431152346, "rmse_worst": 0.6424217028646553}, "stats_text": "mse=0.239611; rmse=0.489501; mse_tsp100=0.412706; mse_tsp20=0.239611; mse_tsp50=0.249805; mse_worst=0.412706; rmse_tsp100=0.642422; rmse_tsp20=0.489501; rmse_tsp50=0.499805; rmse_worst=0.642422"}
{"score": 0.7280720372806312, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.", "code_hash": "0cc2a43e13841f036b76914d86123d54dbc39c9e3e58d8eeb12c85a3cec64035", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.}\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node_idx = state.current_node_index()\n    # [B]\n    first_node_idx = state.first_node_index()\n    # [B]\n    batch_indices = torch.arange(dist_matrix.size(0), device=dist_matrix.device)\n\n    # Cost to return to the start node from the current node\n    # [B]\n    dist_to_start = dist_matrix[batch_indices, current_node_idx, first_node_idx]\n\n    # For each unvisited node, find its minimum connection cost to any other node.\n    # We set diagonal to infinity to avoid picking the zero-cost self-connection.\n    # [B, N, N]\n    dist_matrix_no_self = dist_matrix + torch.diag(torch.full((dist_matrix.size(1),), float('inf'), device=dist_matrix.device))\n    # [B, N]\n    min_dist_per_node, _ = torch.min(dist_matrix_no_self, dim=2)\n    \n    # Sum these minimum distances only for the unvisited nodes\n    # [B, N]\n    min_dist_per_node.masked_fill_(~unvisited_mask, 0)\n    # [B]\n    sum_min_dists = torch.sum(min_dist_per_node, dim=1)\n    \n    # The total estimated cost is the sum of minimum connection costs for unvisited nodes\n    # plus the cost to return to the start node from the current node.\n    # [B]\n    value = sum_min_dists + dist_to_start\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.4083288623046875, "rmse": 0.6390061520084822, "mse_tsp20": 0.4083288623046875, "rmse_tsp20": 0.6390061520084822, "mse_tsp50": 0.7378879370117187, "rmse_tsp50": 0.8590040378320225, "mse_tsp100": 1.3734904635742187, "rmse_tsp100": 1.1719600947021271, "mse_worst": 1.3734904635742187, "rmse_worst": 1.1719600947021271}, "stats_text": "mse=0.408329; rmse=0.639006; mse_tsp100=1.37349; mse_tsp20=0.408329; mse_tsp50=0.737888; mse_worst=1.37349; rmse_tsp100=1.17196; rmse_tsp20=0.639006; rmse_tsp50=0.859004; rmse_worst=1.17196"}
{"score": 0.14442194401455405, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The algorithm estimates the remaining tour length by multiplying the number of unvisited nodes by the average minimum distance from each unvisited node to any other unvisited node.", "code_hash": "948da801474913ef9ed2db71f330b186f78363384b494b85e41c1da0b92ac1a8", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The algorithm estimates the remaining tour length by multiplying the number of unvisited nodes by the average minimum distance from each unvisited node to any other unvisited node.}\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    n_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # For terminal states, the future cost is zero.\n    is_not_terminal = n_unvisited > 1\n    if not is_not_terminal.any():\n        return torch.zeros(dist_matrix.size(0), 1, device=dist_matrix.device)\n\n    # A large value to mask out irrelevant distances\n    large_value = dist_matrix.max() * 2 + 1 if dist_matrix.numel() > 0 else 1e9\n\n    # Create a temporary distance matrix where distances to/from visited nodes are masked\n    # [B, N, N]\n    temp_dist_matrix = dist_matrix.clone()\n    # Mask rows and columns corresponding to visited nodes\n    visited_mask = ~unvisited_mask\n    temp_dist_matrix[visited_mask, :] = large_value\n    temp_dist_matrix[:, visited_mask] = large_value\n    # Mask self-loops\n    temp_dist_matrix.diagonal(dim1=-2, dim2=-1).fill_(large_value)\n\n    # Find the minimum distance from each unvisited node to another unvisited node\n    # [B, N]\n    min_dists, _ = temp_dist_matrix.min(dim=2)\n\n    # Set distances from visited nodes to 0 so they don't affect the sum\n    min_dists.masked_fill_(visited_mask, 0)\n\n    # Calculate the average of these minimum distances\n    # Use a safe divisor to avoid division by zero for terminal states\n    safe_n_unvisited = torch.where(n_unvisited > 0, n_unvisited, torch.ones_like(n_unvisited))\n    # [B]\n    avg_min_dist = min_dists.sum(dim=1) / safe_n_unvisited\n\n    # Estimate the remaining tour length\n    # [B]\n    remaining_tour_length = n_unvisited * avg_min_dist\n\n    # Ensure terminal states have zero value\n    value = torch.where(is_not_terminal, remaining_tour_length, torch.tensor(0.0, device=dist_matrix.device))\n\n    return value.unsqueeze(-1)", "stats": {"mse": 1.8778033940429688, "rmse": 1.3703296661909385, "mse_tsp20": 1.8778033940429688, "rmse_tsp20": 1.3703296661909385, "mse_tsp50": 3.856727740234375, "rmse_tsp50": 1.9638553256883193, "mse_tsp100": 6.9241555140625, "rmse_tsp100": 2.6313790137611304, "mse_worst": 6.9241555140625, "rmse_worst": 2.6313790137611304}, "stats_text": "mse=1.8778; rmse=1.37033; mse_tsp100=6.92416; mse_tsp20=1.8778; mse_tsp50=3.85673; mse_worst=6.92416; rmse_tsp100=2.63138; rmse_tsp20=1.37033; rmse_tsp50=1.96386; rmse_worst=2.63138"}
{"score": 0.11230624864292459, "gamma": -0.1, "algorithm": "Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.", "code_hash": "0e7601ed649dfde68fc9175671d4df815cf1f6e8088ee79de00b3b2d9f6dd931", "code": "# THOUGHT: {Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on the geometric properties of unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes using the area of their convex hull.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n    This combines a geometric heuristic for the bulk of the path with connection costs.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n\n    # 1. Approximate sub-tour length using convex hull area of unvisited nodes\n    # A heuristic for tour length is related to the square root of the area of the convex hull.\n    # We use a simplified proxy: the area of the bounding box of unvisited nodes.\n\n    # Mask coordinates of visited nodes to exclude them from min/max calculations\n    # [B, N, 2]\n    masked_coords = coords.clone()\n    # Use a large value for visited nodes so they don't affect min, and a small value for max\n    large_val = torch.finfo(coords.dtype).max\n    small_val = torch.finfo(coords.dtype).min\n    # [B, N, 1]\n    unvisited_mask_exp = unvisited_mask.unsqueeze(-1)\n    masked_coords.masked_fill_(~unvisited_mask_exp, large_val)\n    min_coords, _ = torch.min(masked_coords, dim=1)  # [B, 2]\n\n    masked_coords = coords.clone()\n    masked_coords.masked_fill_(~unvisited_mask_exp, small_val)\n    max_coords, _ = torch.max(masked_coords, dim=1)  # [B, 2]\n\n    # Calculate width and height of the bounding box\n    # [B, 2]\n    span = max_coords - min_coords\n    # Clamp to avoid negative span if only one node is left\n    span = torch.clamp(span, min=0.0)\n    # [B]\n    area = span[:, 0] * span[:, 1]\n    # Heuristic for tour length: k * sqrt(Area * num_unvisited), k is an empirical factor\n    # For a unit square with N points, E[tour_len] ~ beta * sqrt(N), and Area=1.\n    # We use a simplified form: sqrt(Area) as a proxy for the spatial scale.\n    # The sum of two sides of the bounding box is a reasonable perimeter proxy.\n    subtour_cost = span[:, 0] + span[:, 1]\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, torch.finfo(dist_from_current.dtype).max)\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop)\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, torch.finfo(dist_from_start.dtype).max)\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Combine the components\n    # [B]\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n    \n    # Handle edge case where only one unvisited node remains\n    # The cost is just from current -> last_unvisited -> start\n    is_last_step = (num_unvisited.squeeze(-1) == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step]\n\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix[is_last_step, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix[is_last_step, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step] = last_step_cost\n\n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set if num_unvisited=0) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.9090601949462891, "rmse": 0.9534464824762264, "mse_tsp20": 0.9090601949462891, "rmse_tsp20": 0.9534464824762264, "mse_tsp50": 3.432229481640625, "rmse_tsp50": 1.852627723435182, "mse_tsp100": 8.904224048828125, "rmse_tsp100": 2.9839946462465585, "mse_worst": 8.904224048828125, "rmse_worst": 2.9839946462465585}, "stats_text": "mse=0.90906; rmse=0.953446; mse_tsp100=8.90422; mse_tsp20=0.90906; mse_tsp50=3.43223; mse_worst=8.90422; rmse_tsp100=2.98399; rmse_tsp20=0.953446; rmse_tsp50=1.85263; rmse_worst=2.98399"}
{"score": 0.07782706118698951, "gamma": -0.1, "algorithm": "Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.", "code_hash": "5fd3309104022111fb964be45f064a888499b1e8ed8f66c21cadfee07bffcee5", "code": "# THOUGHT: {Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length by averaging connection costs to the unvisited set.\n    The value is the sum of two components:\n    1. The average distance from the current node to all unvisited nodes.\n    2. The average distance from the start node to all unvisited nodes (to close the tour).\n    This heuristic focuses on the expected cost of the next and final connections.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N = unvisited_mask.shape\n    device = unvisited_mask.device\n    \n    # [B, 1]\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)\n    is_done = (num_unvisited == 0)\n\n    # Use a small epsilon to avoid division by zero when no nodes are unvisited\n    # The result for this case will be masked out later anyway.\n    num_unvisited_safe = num_unvisited.clamp(min=1.0)\n\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n\n    # 1. Average distance from the current node to the unvisited set\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    \n    # Mask out distances to already visited nodes\n    dist_from_current_unvisited = dist_from_current.masked_fill(~unvisited_mask, 0.0)\n    \n    # [B, 1]\n    sum_dist_from_current = dist_from_current_unvisited.sum(dim=1, keepdim=True)\n    avg_dist_from_current = sum_dist_from_current / num_unvisited_safe\n\n    # 2. Average distance from the start node to the unvisited set (for closing the loop)\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n\n    # Mask out distances to already visited nodes\n    dist_from_start_unvisited = dist_from_start.masked_fill(~unvisited_mask, 0.0)\n\n    # [B, 1]\n    sum_dist_from_start = dist_from_start_unvisited.sum(dim=1, keepdim=True)\n    avg_dist_from_start = sum_dist_from_start / num_unvisited_safe\n\n    # Combine the components\n    # [B, 1]\n    value = avg_dist_from_current + avg_dist_from_start\n    \n    # Handle the special case where only one unvisited node remains.\n    # The cost is exactly current -> last -> start.\n    is_last_step = (num_unvisited == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step.squeeze(-1)].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step.squeeze(-1)]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step.squeeze(-1)]\n        \n        # [B_last, N, N]\n        dist_matrix_last = dist_matrix[is_last_step.squeeze(-1)]\n        \n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix_last[:, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix_last[:, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = (dist_curr_to_last + dist_last_to_start).unsqueeze(-1)\n        value = torch.where(is_last_step, last_step_cost, value)\n\n    # If the tour is done, the future cost is zero.\n    value.masked_fill_(is_done, 0.0)\n\n    return value", "stats": {"mse": 1.5873716700439453, "rmse": 1.2599093896165492, "mse_tsp20": 1.5873716700439453, "rmse_tsp20": 1.2599093896165492, "mse_tsp50": 4.672369123242188, "rmse_tsp50": 2.161566358741315, "mse_tsp100": 12.849001166796874, "rmse_tsp100": 3.58455034373865, "mse_worst": 12.849001166796874, "rmse_worst": 3.58455034373865}, "stats_text": "mse=1.58737; rmse=1.25991; mse_tsp100=12.849; mse_tsp20=1.58737; mse_tsp50=4.67237; mse_worst=12.849; rmse_tsp100=3.58455; rmse_tsp20=1.25991; rmse_tsp50=2.16157; rmse_worst=3.58455"}
{"score": 0.07266666341623383, "gamma": 1.0, "algorithm": "Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.", "code_hash": "884346de00c0f4e4ef075e61c49dd857c93553fc2d00215ba1795fcf9caa8a84", "code": "# THOUGHT: {Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on average distances to the set of unvisited nodes.\n    This heuristic considers the expected cost to connect the current path segment back\n    to the main cluster of unvisited nodes, and then eventually close the tour from that\n    cluster back to the start node. It uses average distance as a robust proxy for\n    these connection costs, avoiding reliance on single min/max values which can be noisy.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n    device = dist_matrix.device\n\n    # [B]\n    num_unvisited = unvisited_mask.sum(dim=1)\n    # Avoid division by zero for terminal states.\n    # The final value for terminal states will be masked to 0 anyway.\n    num_unvisited_safe = torch.clamp(num_unvisited, min=1.0)\n\n    # 1. Calculate the average distance from the current node to all unvisited nodes.\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    # Mask out distances to already visited nodes by setting them to 0.\n    dist_from_current_unvisited = dist_from_current * unvisited_mask\n    # [B]\n    avg_dist_from_current = dist_from_current_unvisited.sum(dim=1) / num_unvisited_safe\n\n    # 2. Calculate the average distance from the start node to all unvisited nodes.\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    # Mask out distances to already visited nodes.\n    dist_from_start_unvisited = dist_from_start * unvisited_mask\n    # [B]\n    avg_dist_from_start = dist_from_start_unvisited.sum(dim=1) / num_unvisited_safe\n\n    # 3. Handle the case where only one unvisited node remains.\n    # The cost is exactly current -> last_unvisited -> start.\n    is_last_step = (num_unvisited == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step]\n\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix[is_last_step, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix[is_last_step, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        # For the last step, the average distances are just the exact distances, so this is correct.\n        avg_dist_from_current[is_last_step] = dist_curr_to_last\n        avg_dist_from_start[is_last_step] = dist_last_to_start\n\n    # Combine the two average distance components.\n    # This represents the cost to enter the unvisited cluster and the cost to leave it to finish the tour.\n    value = avg_dist_from_current + avg_dist_from_start\n\n    # If the tour is done (num_unvisited is 0), the future cost is 0.\n    is_done = (num_unvisited == 0)\n    value.masked_fill_(is_done, 0.0)\n\n    # Return broadcastable shape [B, 1]\n    return value.unsqueeze(-1)", "stats": {"mse": 2.3418170474853515, "rmse": 1.5302996593756895, "mse_tsp20": 2.3418170474853515, "rmse_tsp20": 1.5302996593756895, "mse_tsp50": 6.4205319578125, "rmse_tsp50": 2.5338768631905735, "mse_tsp100": 13.76146850546875, "rmse_tsp100": 3.709645334188802, "mse_worst": 13.76146850546875, "rmse_worst": 3.709645334188802}, "stats_text": "mse=2.34182; rmse=1.5303; mse_tsp100=13.7615; mse_tsp20=2.34182; mse_tsp50=6.42053; mse_worst=13.7615; rmse_tsp100=3.70965; rmse_tsp20=1.5303; rmse_tsp50=2.53388; rmse_worst=3.70965"}
{"score": 0.0624345409506303, "gamma": 1.0, "algorithm": "auto} def phi(state): \"\"\" {Estimates future tour length based on the convex hull area of unvisited nodes, plus connection costs.", "code_hash": "627d91b23b0370ff838ed2c69bc931795333336d40829148afcc16965d6b24a6", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimates future tour length based on the convex hull area of unvisited nodes, plus connection costs.}\n    The heuristic has three parts:\n    1. The area of the convex hull of the unvisited nodes, scaled by a factor. This approximates the density and spread of the remaining problem.\n    2. The cost to connect the current node to the closest unvisited node.\n    3. The cost to connect the start node to the closest unvisited node (approximating the tour completion cost).\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    num_unvisited = unvisited_mask.sum(dim=1)\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n\n    # Handle terminal state: if no nodes are unvisited, the future cost is zero.\n    is_terminal = (num_unvisited == 0)\n    # Handle case with < 3 unvisited nodes where convex hull is undefined/zero area\n    is_small_subproblem = (num_unvisited < 3)\n\n    # 1. Convex Hull Area of Unvisited Nodes\n    # Set coordinates of visited nodes to a large value so they don't affect the hull\n    masked_coords = coords.clone()\n    masked_coords[~unvisited_mask] = 1e9\n    \n    # Find the node with the minimum y-coordinate (and then x) to start the hull scan\n    min_y_coords, _ = masked_coords[:, :, 1].min(dim=1, keepdim=True)\n    is_min_y = (masked_coords[:, :, 1] == min_y_coords)\n    min_x_at_min_y, _ = (masked_coords[:, :, 0] + (~is_min_y) * 1e9).min(dim=1, keepdim=True)\n    is_start_node = is_min_y & (masked_coords[:, :, 0] == min_x_at_min_y)\n    start_node_idx = torch.argmax(is_start_node.float(), dim=1)\n    \n    # Calculate angles from the start node to all other unvisited nodes\n    start_node_coords = torch.gather(coords, 1, start_node_idx.view(-1, 1, 1).expand(-1, 1, 2))\n    delta = masked_coords - start_node_coords\n    angles = torch.atan2(delta[:, :, 1], delta[:, :, 0])\n    angles[~unvisited_mask] = 4.0 # Put visited nodes at the end after sorting\n    angles.scatter_(1, start_node_idx.unsqueeze(1), 4.0) # Start node also at the end\n\n    # Sort nodes by angle to get the convex hull vertex order\n    _, sorted_indices = torch.sort(angles, dim=1)\n    sorted_coords = torch.gather(coords, 1, sorted_indices.unsqueeze(-1).expand(-1, -1, 2))\n\n    # Shoelace formula for polygon area\n    x = sorted_coords[:, :, 0]\n    y = sorted_coords[:, :, 1]\n    # Area = 0.5 * |(x1*y2 + x2*y3 + ... + xn*y1) - (y1*x2 + y2*x3 + ... + yn*x1)|\n    area = 0.5 * torch.abs(torch.sum(x * torch.roll(y, -1, dims=1), dim=1) - torch.sum(y * torch.roll(x, -1, dims=1), dim=1))\n    \n    # The area is an approximation of the subproblem size. Scale it to be distance-like.\n    # Sqrt(area) is a length-like dimension.\n    hull_cost = torch.sqrt(area)\n    hull_cost[is_small_subproblem] = 0.0 # No area for <3 points\n\n    # 2. Connection Costs\n    current_node = state.current_node_index()\n    start_node = state.first_node_index()\n\n    # Distances from current/start to all nodes\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n\n    # Mask to find closest unvisited node\n    dist_to_unvisited = dist_from_current.clone()\n    dist_to_unvisited[~unvisited_mask] = float('inf')\n    connect_cost_current, _ = torch.min(dist_to_unvisited, dim=1, keepdim=False)\n\n    dist_to_unvisited_from_start = dist_from_start.clone()\n    dist_to_unvisited_from_start[~unvisited_mask] = float('inf')\n    connect_cost_start, _ = torch.min(dist_to_unvisited_from_start, dim=1, keepdim=False)\n\n    # Combine costs\n    value = hull_cost + connect_cost_current + connect_cost_start\n    value[is_terminal] = 0.0\n    \n    return value.unsqueeze(-1)", "stats": {"mse": 3.284633240966797, "rmse": 1.8123557159031438, "mse_tsp20": 3.284633240966797, "rmse_tsp20": 1.8123557159031438, "mse_tsp50": 8.050507896484374, "rmse_tsp50": 2.837341695405115, "mse_tsp100": 16.0167750859375, "rmse_tsp100": 4.002096336413892, "mse_worst": 16.0167750859375, "rmse_worst": 4.002096336413892}, "stats_text": "mse=3.28463; rmse=1.81236; mse_tsp100=16.0168; mse_tsp20=3.28463; mse_tsp50=8.05051; mse_worst=16.0168; rmse_tsp100=4.0021; rmse_tsp20=1.81236; rmse_tsp50=2.83734; rmse_worst=4.0021"}
{"score": 3.4209696471518978, "gamma": -0.1, "algorithm": "Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.", "code_hash": "d5014fe6247751116f6de4174accdec9f7c2eafdcfcbe2f724c5ad25941cb364", "code": "# THOUGHT: {Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length using a Minimum Spanning Tree (MST) based heuristic.\n    The cost is the sum of three components:\n    1. The cost of the MST of the subgraph formed by the unvisited nodes. This provides a\n       tight lower bound on the optimal sub-tour length for these nodes.\n    2. The minimum cost to connect the current node to the set of unvisited nodes.\n    3. The minimum cost to connect the start node to the set of unvisited nodes,\n       which is necessary for closing the tour.\n    \n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n    \n    # 1. Calculate the cost of the MST on the unvisited nodes.\n    # Prim's algorithm for dense graphs.\n    # We will compute this only for batches where there are unvisited nodes.\n    # [B, N]\n    min_cost = torch.full((B, N), float('inf'), device=device)\n    # [B, N]\n    visited_in_mst = torch.zeros_like(unvisited_mask)\n    # [B]\n    mst_cost = torch.zeros(B, device=device)\n    \n    # Initialize Prim's: pick the first unvisited node as the starting point for the MST.\n    # Find the index of the first 'True' in unvisited_mask for each batch item.\n    first_unvisited_idx = torch.argmax(unvisited_mask.int(), dim=1)\n    \n    # Set the min_cost for the starting node of the MST to 0.\n    # This ensures it's the first one picked.\n    min_cost.scatter_(1, first_unvisited_idx.unsqueeze(1), 0)\n    \n    # Mask min_cost for nodes that are already visited in the main tour.\n    min_cost.masked_fill_(~unvisited_mask, float('inf'))\n\n    # Prim's algorithm loop executed in a parallelized way over N-1 steps.\n    # This is a fixed-iteration loop, avoiding dynamic Python loops.\n    for _ in range(N):\n        # Find the node `u` with the minimum cost that is unvisited in the MST.\n        # [B, 1]\n        u_idx = torch.argmin(min_cost, dim=1, keepdim=True)\n        # [B]\n        u_cost = torch.gather(min_cost, 1, u_idx).squeeze(1)\n        \n        # Add its cost to the total MST cost, handling inf for disconnected components.\n        mst_cost += torch.where(u_cost == float('inf'), 0, u_cost)\n        \n        # Mark `u` as visited in the MST and remove it from consideration.\n        visited_in_mst.scatter_(1, u_idx, True)\n        min_cost.scatter_(1, u_idx, float('inf'))\n\n        # Update min_costs for neighbors of `u`.\n        # [B, N]\n        dist_from_u = torch.gather(dist_matrix, 1, u_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        \n        # Update only if the new path through `u` is shorter and the neighbor is unvisited in MST.\n        # We also need to ensure the neighbor is part of the unvisited set for the main tour.\n        update_mask = (dist_from_u < min_cost) & ~visited_in_mst & unvisited_mask\n        min_cost[update_mask] = dist_from_u[update_mask]\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    # Mask distances to already visited nodes.\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop).\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Total estimated cost\n    # For the case with only one unvisited node, MST cost is 0. The formula becomes\n    # dist(current -> last) + dist(start -> last), which is correct.\n    value = mst_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # For terminal states, future cost is 0.\n    value.masked_fill_(is_terminal, 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0.\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.18682559706115723, "rmse": 0.4322332669533399, "mse_tsp20": 0.18682559706115723, "rmse_tsp20": 0.4322332669533399, "mse_tsp50": 0.19572340977783204, "rmse_tsp50": 0.4424063853266949, "mse_tsp100": 0.2923147829833984, "rmse_tsp100": 0.5406614310114958, "mse_worst": 0.2923147829833984, "rmse_worst": 0.5406614310114958}, "stats_text": "mse=0.186826; rmse=0.432233; mse_tsp100=0.292315; mse_tsp20=0.186826; mse_tsp50=0.195723; mse_worst=0.292315; rmse_tsp100=0.540661; rmse_tsp20=0.432233; rmse_tsp50=0.442406; rmse_worst=0.540661"}
{"score": 3.406448250786877, "gamma": -0.1, "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.", "code_hash": "a509be98760cefdd1fed21f2974aece62623fff8e8b93600894306f7a87ee209", "code": "# THOUGHT: {Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for a TSP state.\n    The estimation is based on three components:\n    1. The cost of a Minimum Spanning Tree (MST) over all unvisited nodes.\n    2. The minimum cost to connect the current node to one of the unvisited nodes.\n    3. The minimum cost to connect the start node to one of the unvisited nodes.\n    This heuristic approximates the cost of visiting all remaining nodes and returning home.\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # 1. MST cost on unvisited nodes\n    # Create a subgraph distance matrix for unvisited nodes\n    # [B, N, N]\n    unvisited_dist = dist_matrix.clone()\n    # Mask rows and columns for visited nodes by setting distances to infinity\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n\n    # Prim's algorithm for MST cost\n    # [B]\n    num_unvisited = unvisited_mask.sum(dim=1)\n    # [B, N], init with large values\n    min_cost = torch.full_like(unvisited_mask, float('inf'), dtype=dist_matrix.dtype)\n    # [B, N], init with False\n    in_mst = torch.zeros_like(unvisited_mask, dtype=torch.bool)\n    # [B]\n    mst_cost = torch.zeros(B, device=dist_matrix.device)\n\n    # Find the first unvisited node to start Prim's algorithm\n    # [B], indices of first unvisited nodes\n    start_node_idx = torch.where(unvisited_mask.any(1), unvisited_mask.float().argmax(1), -1)\n\n    # Set the cost of the starting node to 0\n    # Use scatter for batched indexing\n    min_cost.scatter_(1, start_node_idx.unsqueeze(1).clamp(min=0), 0)\n\n    # Prim's algorithm loop (vectorized)\n    # This loop runs N times, which is more than necessary but avoids dynamic loops\n    # and is safe because nodes already in MST won't be chosen again.\n    for _ in range(N):\n        # Select node `u` not in MST with the minimum cost\n        # [B, N]\n        cost_if_not_in_mst = min_cost.clone()\n        cost_if_not_in_mst.masked_fill_(in_mst, float('inf'))\n        # [B, 1]\n        u_cost, u_idx = cost_if_not_in_mst.min(dim=1, keepdim=True)\n\n        # Add cost to total and mark node as in MST\n        # This mask handles batches where no unvisited nodes are left (u_cost is inf)\n        is_finite_mask = torch.isfinite(u_cost.squeeze(-1))\n        mst_cost[is_finite_mask] += u_cost[is_finite_mask].squeeze(-1)\n        in_mst.scatter_(1, u_idx.clamp(min=0), True)\n\n        # Update min_cost for neighbors of `u`\n        # [B, 1, N]\n        dist_from_u = torch.gather(unvisited_dist, 1, u_idx.unsqueeze(-1).expand(-1, 1, N))\n        # [B, N]\n        dist_from_u_squeezed = dist_from_u.squeeze(1)\n        # [B, N]\n        min_cost = torch.min(min_cost, dist_from_u_squeezed)\n\n    # 2. Minimum cost from current node to any unvisited node\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_exp = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_exp)\n    # [B, N]\n    dist_from_current_squeezed = dist_from_current.squeeze(1)\n    dist_from_current_squeezed.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_to_unvisited = dist_from_current_squeezed.min(dim=1).values\n    min_to_unvisited.masked_fill_(num_unvisited == 0, 0) # If no unvisited, cost is 0\n\n    # 3. Minimum cost from start node to any unvisited node\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    first_node_exp = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_start = torch.gather(dist_matrix, 1, first_node_exp)\n    # [B, N]\n    dist_from_start_squeezed = dist_from_start.squeeze(1)\n    dist_from_start_squeezed.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_to_return = dist_from_start_squeezed.min(dim=1).values\n    min_to_return.masked_fill_(num_unvisited == 0, 0) # If no unvisited, cost is 0\n\n    # Total estimated cost\n    # Special case: if only one unvisited node, MST cost is 0. The cost is just to go there and back.\n    # [B]\n    is_one_unvisited = (num_unvisited == 1)\n    # [B, 1]\n    first_unvisited_idx = torch.where(is_one_unvisited, unvisited_mask.float().argmax(1).unsqueeze(-1), -1)\n    # [B, 1]\n    dist_curr_to_last = torch.gather(dist_from_current_squeezed, 1, first_unvisited_idx.clamp(min=0))\n    # [B, 1]\n    dist_last_to_start = torch.gather(dist_from_start_squeezed, 1, first_unvisited_idx.clamp(min=0))\n    # [B]\n    one_unvisited_cost = (dist_curr_to_last + dist_last_to_start).squeeze(-1)\n\n    # Combine costs\n    value = torch.where(is_one_unvisited, one_unvisited_cost, mst_cost + min_to_unvisited + min_to_return)\n\n    # Final state: tour complete, cost is 0\n    value.masked_fill_(num_unvisited == 0, 0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.19756102726745606, "rmse": 0.444478376602795, "mse_tsp20": 0.19756102726745606, "rmse_tsp20": 0.444478376602795, "mse_tsp50": 0.20184117449951172, "rmse_tsp50": 0.44926737528949473, "mse_tsp100": 0.29356089580078126, "rmse_tsp100": 0.5418126021059138, "mse_worst": 0.29356089580078126, "rmse_worst": 0.5418126021059138}, "stats_text": "mse=0.197561; rmse=0.444478; mse_tsp100=0.293561; mse_tsp20=0.197561; mse_tsp50=0.201841; mse_worst=0.293561; rmse_tsp100=0.541813; rmse_tsp20=0.444478; rmse_tsp50=0.449267; rmse_worst=0.541813"}
{"score": 3.3781803516081297, "gamma": 1.0, "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.", "code_hash": "54055c1f192cd4960761c781d6f2bc50f9e6fcc45c0de48c9b7057e7a6b4b015", "code": "# THOUGHT: {Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for TSP.\n    The estimate is composed of three parts:\n    1. The cost of a Minimum Spanning Tree (MST) over all unvisited nodes. This approximates\n       the shortest path needed to connect all remaining nodes.\n    2. The cost to connect the current node to the set of unvisited nodes (minimum edge).\n    3. The cost to connect the start node to the set of unvisited nodes (minimum edge).\n    This forms a lower bound on the remaining tour length, as it approximates a path\n    connecting the current node, all unvisited nodes, and returning to the start.\n\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # 1. Calculate the cost of the MST on the subgraph of unvisited nodes.\n    # We use a Prim's algorithm-like approach.\n    # Create a distance matrix for only the unvisited nodes.\n    # Mask rows and columns corresponding to visited nodes.\n    unvisited_dist_matrix = dist_matrix.clone()\n    # Mask rows for visited nodes\n    unvisited_dist_matrix.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n    # Mask columns for visited nodes\n    unvisited_dist_matrix.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n\n    # Prim's algorithm to find MST cost\n    # `in_mst` mask: nodes already included in the MST\n    in_mst = torch.zeros_like(unvisited_mask)\n    # `min_cost` array: min cost to connect each node to the MST\n    min_cost = torch.full((B, N), float('inf'), device=dist_matrix.device, dtype=dist_matrix.dtype)\n\n    # Find the first unvisited node to start Prim's algorithm\n    # This is guaranteed to exist if there are unvisited nodes.\n    first_unvisited_idx = torch.argmax(unvisited_mask.float(), dim=1, keepdim=True)\n\n    # Initialize: select the first unvisited node. Its cost to connect is 0.\n    min_cost.scatter_(1, first_unvisited_idx, 0)\n\n    # Iteratively add N-1 nodes to the MST (or until all unvisited are added)\n    # This loop is fixed to N, which is acceptable as it's not a Python loop.\n    mst_cost = torch.zeros(B, device=dist_matrix.device, dtype=dist_matrix.dtype)\n    for _ in range(N):\n        # Find the node not in MST with the minimum connection cost\n        cost_to_add = min_cost.clone()\n        cost_to_add.masked_fill_(in_mst, float('inf'))\n        # If no nodes are left to add (all unvisited are in mst), cost will be inf\n        min_val, new_node_idx = torch.min(cost_to_add, dim=1)\n\n        # Create a mask for valid additions (cost is not inf)\n        is_valid_addition = min_val != float('inf')\n        \n        # Add its cost to the total MST cost\n        mst_cost += min_val.where(is_valid_addition, torch.tensor(0.0, device=mst_cost.device))\n\n        # Add the new node to the MST\n        new_node_idx = new_node_idx.unsqueeze(1)\n        in_mst.scatter_(1, new_node_idx, True)\n\n        # Update min_cost for all nodes based on the newly added node\n        # Distances from the newly added node to all other nodes\n        dist_from_new = torch.gather(unvisited_dist_matrix, 1, new_node_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        min_cost = torch.min(min_cost, dist_from_new)\n\n    # 2. Find the minimum cost to connect the current node to any unvisited node.\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx)\n    # Mask distances to already visited nodes\n    dist_from_current.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # [B]\n    min_dist_from_current, _ = torch.min(dist_from_current.squeeze(1), dim=1)\n    # If no unvisited nodes, this cost is 0 (or inf, we handle it)\n    min_dist_from_current.masked_fill_(~unvisited_mask.any(dim=1), 0)\n\n    # 3. Find the minimum cost to connect the start node to any unvisited node.\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx)\n    # Mask distances to already visited nodes\n    dist_from_start.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start.squeeze(1), dim=1)\n    # If no unvisited nodes, this cost is 0\n    min_dist_from_start.masked_fill_(~unvisited_mask.any(dim=1), 0)\n    \n    # In terminal states, there are no unvisited nodes. The MST cost will be 0,\n    # and the connection costs will be 0. The only remaining cost is to return to start.\n    is_terminal = ~unvisited_mask.any(dim=1)\n    # [B]\n    dist_to_start_terminal = torch.gather(dist_matrix, 1, state.current_node_index().unsqueeze(1).unsqueeze(2)).squeeze()\n    dist_to_start_terminal = torch.gather(dist_to_start_terminal, 1, state.first_node_index().unsqueeze(1)).squeeze(1)\n\n    # Total estimated future cost\n    value = mst_cost + min_dist_from_current + min_dist_from_start\n    # For terminal states, the value is just the cost to return home\n    value = torch.where(is_terminal, dist_to_start_terminal, value)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.21352034575653075, "rmse": 0.4620826178904923, "mse_tsp20": 0.21352034575653075, "rmse_tsp20": 0.4620826178904923, "mse_tsp50": 0.20358135737304686, "rmse_tsp50": 0.4511999084364345, "mse_tsp100": 0.2960173513305664, "rmse_tsp100": 0.5440747663056672, "mse_worst": 0.2960173513305664, "rmse_worst": 0.5440747663056672}, "stats_text": "mse=0.21352; rmse=0.462083; mse_tsp100=0.296017; mse_tsp20=0.21352; mse_tsp50=0.203581; mse_worst=0.296017; rmse_tsp100=0.544075; rmse_tsp20=0.462083; rmse_tsp50=0.4512; rmse_worst=0.544075"}
{"score": 2.527232641964477, "gamma": 0.1, "algorithm": "Estimate the future tour length by summing the average distance from each unvisited node to its k-nearest unvisited neighbors, plus the cost to connect the current and start nodes to this unvisited cluster.", "code_hash": "dc604ef673fe9a7e63912216f576b19094fd380b26a2e04c3e2c3d74e5ee3b99", "code": "# THOUGHT: {Estimate the future tour length by summing the average distance from each unvisited node to its k-nearest unvisited neighbors, plus the cost to connect the current and start nodes to this unvisited cluster.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on local connectivity of unvisited nodes.\n    The value is the sum of three components:\n    1. For each unvisited node, calculate the average distance to its k-nearest\n       neighbors that are also unvisited. Summing these averages provides a\n       proxy for the sub-tour cost, similar to but simpler than MST.\n    2. The minimum cost to connect the current node to any unvisited node.\n    3. The minimum cost to connect the start node to any unvisited node,\n       approximating the cost of closing the tour.\n    This uses all_node_coords() to get the distance matrix.\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal states where no nodes are unvisited\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n\n    # 1. Estimate sub-tour cost for unvisited nodes using k-nearest neighbors.\n    # [B, N, N]\n    masked_dist = dist_matrix.clone()\n    # Mask connections to/from already visited nodes.\n    # [B, 1, N]\n    unvisited_mask_from = unvisited_mask.unsqueeze(1)\n    # [B, N, 1]\n    unvisited_mask_to = unvisited_mask.unsqueeze(2)\n    # Set distances to/from visited nodes to infinity.\n    masked_dist.masked_fill_(~unvisited_mask_from | ~unvisited_mask_to, float('inf'))\n    # Set diagonal to infinity to exclude self-loops.\n    masked_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n\n    # Sort distances to find k-nearest neighbors for each unvisited node.\n    # [B, N, N]\n    sorted_dist, _ = torch.sort(masked_dist, dim=2)\n\n    # Use a dynamic k, e.g., min(3, number of other unvisited nodes)\n    # This avoids issues when few nodes are left.\n    k = torch.min(torch.tensor(3, device=device), n_unvisited.clamp(min=1) - 1)\n    k = k.clamp(min=1) # Ensure k is at least 1 for non-terminal states.\n\n    # [B, N, k_max=3]\n    k_nearest_dists = sorted_dist[:, :, :3]\n\n    # Create a mask for averaging based on dynamic k.\n    # [B, 1, 3]\n    k_range = torch.arange(3, device=device).view(1, 1, 3)\n    # [B, N, 3]\n    k_mask = k_range < k.view(B, 1, 1)\n\n    # Calculate average distance to k-nearest unvisited neighbors.\n    # [B, N, 3]\n    k_nearest_dists.masked_fill_(~k_mask, 0.0)\n    # [B, N]\n    sum_k_dists = k_nearest_dists.sum(dim=2)\n    # [B, N]\n    avg_k_dist = sum_k_dists / k.view(B, 1).float()\n\n    # Sum these averages only for the unvisited nodes.\n    avg_k_dist.masked_fill_(~unvisited_mask, 0.0)\n    # [B]\n    subtour_cost_estimate = avg_k_dist.sum(dim=1)\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited = torch.min(dist_from_current, dim=1).values\n\n    # 3. Cost to connect the start node to the unvisited set.\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start = torch.min(dist_from_start, dim=1).values\n\n    # Total estimated cost\n    value = subtour_cost_estimate + min_dist_to_unvisited + min_dist_from_start\n\n    # For terminal states, future cost is 0.\n    value.masked_fill_(is_terminal, 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0.\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.39568972930908203, "rmse": 0.6290387343471641, "mse_tsp20": 0.39568972930908203, "rmse_tsp20": 0.6290387343471641, "mse_tsp50": 0.20146149614257813, "rmse_tsp50": 0.4488446236088588, "mse_tsp100": 0.17992913677978514, "rmse_tsp100": 0.42418054738493743, "mse_worst": 0.39568972930908203, "rmse_worst": 0.6290387343471641}, "stats_text": "mse=0.39569; rmse=0.629039; mse_tsp100=0.179929; mse_tsp20=0.39569; mse_tsp50=0.201461; mse_worst=0.39569; rmse_tsp100=0.424181; rmse_tsp20=0.629039; rmse_tsp50=0.448845; rmse_worst=0.629039"}
{"score": 2.423034464838014, "gamma": -0.1, "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.", "code_hash": "1b3b0812ca98a6aa6a8fb459b2e47dca3884b0f5419dcd0d7504221710b3f7b9", "code": "# THOUGHT: {Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length by approximating a path through unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes. For each unvisited node,\n       we find the distance to its two nearest neighbors among the other unvisited nodes.\n       The sum of these distances, averaged over all unvisited nodes, provides an estimate\n       of the local path cost. This is scaled by the number of unvisited nodes.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n    is_last_step = (num_unvisited == 1)\n    is_penultimate = (num_unvisited == 2)\n\n    # 1. Approximate sub-tour length through unvisited nodes\n    # Create a distance matrix only considering unvisited nodes.\n    # We set distances to/from visited nodes to infinity.\n    unvisited_dist = dist_matrix.clone()\n    inf = torch.finfo(dist_matrix.dtype).max\n    # Mask rows (from) and columns (to) corresponding to visited nodes\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), inf)\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), inf)\n\n    # For each unvisited node, find the distances to its two nearest unvisited neighbors.\n    # We use k=3 because the node itself is included with distance 0.\n    # [B, N, 3]\n    k = min(3, N) # handle N < 3 case\n    topk_dists, _ = torch.topk(unvisited_dist, k, dim=2, largest=False)\n\n    # The first value (k=0) is always 0 (distance to self), so we take k=1 and k=2.\n    # Sum of distances to two nearest neighbors for each node.\n    # If less than 3 unvisited nodes, some of these will be inf.\n    if k > 2:\n        two_nn_dist_sum = topk_dists[:, :, 1] + topk_dists[:, :, 2] # [B, N]\n    elif k > 1:\n        two_nn_dist_sum = topk_dists[:, :, 1] # [B, N]\n    else:\n        two_nn_dist_sum = torch.zeros_like(unvisited_mask, dtype=dist_matrix.dtype)\n\n\n    # Mask out the sums for visited nodes\n    two_nn_dist_sum.masked_fill_(~unvisited_mask, 0.0)\n\n    # The sum of these distances over all unvisited nodes, divided by 2 (since each edge is counted twice),\n    # approximates the MST length, which is a lower bound on the tour length.\n    # We use the sum directly as a heuristic.\n    subtour_cost = torch.sum(two_nn_dist_sum, dim=1) / 2.0\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    # [B]\n    min_dist_to_unvisited = torch.min(dist_from_current.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # 3. Cost to connect the start node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    # [B]\n    min_dist_from_start = torch.min(dist_from_start.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # Combine the components\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # Handle edge cases where subtour_cost is not well-defined\n    # If only two unvisited nodes, cost is current->A->B->start or current->B->A->start\n    if torch.any(is_penultimate):\n      # [B_pen, 2]\n      unvisited_indices = unvisited_mask[is_penultimate.squeeze(-1)].long().nonzero(as_tuple=False)[:, 1].view(-1, 2)\n      node_a_idx, node_b_idx = unvisited_indices[:, 0], unvisited_indices[:, 1]\n      \n      current_node_pen = state.current_node_index()[is_penultimate.squeeze(-1)]\n      start_node_pen = state.first_node_index()[is_penultimate.squeeze(-1)]\n      dist_matrix_pen = dist_matrix[is_penultimate.squeeze(-1)]\n\n      dist_curr_a = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_a_idx]\n      dist_curr_b = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_b_idx]\n      dist_a_b = dist_matrix_pen[torch.arange(len(node_a_idx)), node_a_idx, node_b_idx]\n      dist_a_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_a_idx, start_node_pen]\n      dist_b_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_b_idx, start_node_pen]\n      \n      cost1 = dist_curr_a + dist_a_b + dist_b_start\n      cost2 = dist_curr_b + dist_a_b + dist_a_start\n      penultimate_cost = torch.min(cost1, cost2)\n      value[is_penultimate.squeeze(-1)] = penultimate_cost\n\n    # If only one unvisited node, cost is current -> last -> start\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step.squeeze(-1)].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_from_current[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        dist_last_to_start = torch.gather(dist_from_start[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step.squeeze(-1)] = last_step_cost\n    \n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.2396109479522705, "rmse": 0.48950071292314834, "mse_tsp20": 0.2396109479522705, "rmse_tsp20": 0.48950071292314834, "mse_tsp50": 0.24980534642333985, "rmse_tsp50": 0.4998053085185669, "mse_tsp100": 0.41270564431152346, "rmse_tsp100": 0.6424217028646553, "mse_worst": 0.41270564431152346, "rmse_worst": 0.6424217028646553}, "stats_text": "mse=0.239611; rmse=0.489501; mse_tsp100=0.412706; mse_tsp20=0.239611; mse_tsp50=0.249805; mse_worst=0.412706; rmse_tsp100=0.642422; rmse_tsp20=0.489501; rmse_tsp50=0.499805; rmse_worst=0.642422"}
{"score": 0.7280720372806312, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.", "code_hash": "0cc2a43e13841f036b76914d86123d54dbc39c9e3e58d8eeb12c85a3cec64035", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.}\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node_idx = state.current_node_index()\n    # [B]\n    first_node_idx = state.first_node_index()\n    # [B]\n    batch_indices = torch.arange(dist_matrix.size(0), device=dist_matrix.device)\n\n    # Cost to return to the start node from the current node\n    # [B]\n    dist_to_start = dist_matrix[batch_indices, current_node_idx, first_node_idx]\n\n    # For each unvisited node, find its minimum connection cost to any other node.\n    # We set diagonal to infinity to avoid picking the zero-cost self-connection.\n    # [B, N, N]\n    dist_matrix_no_self = dist_matrix + torch.diag(torch.full((dist_matrix.size(1),), float('inf'), device=dist_matrix.device))\n    # [B, N]\n    min_dist_per_node, _ = torch.min(dist_matrix_no_self, dim=2)\n    \n    # Sum these minimum distances only for the unvisited nodes\n    # [B, N]\n    min_dist_per_node.masked_fill_(~unvisited_mask, 0)\n    # [B]\n    sum_min_dists = torch.sum(min_dist_per_node, dim=1)\n    \n    # The total estimated cost is the sum of minimum connection costs for unvisited nodes\n    # plus the cost to return to the start node from the current node.\n    # [B]\n    value = sum_min_dists + dist_to_start\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.4083288623046875, "rmse": 0.6390061520084822, "mse_tsp20": 0.4083288623046875, "rmse_tsp20": 0.6390061520084822, "mse_tsp50": 0.7378879370117187, "rmse_tsp50": 0.8590040378320225, "mse_tsp100": 1.3734904635742187, "rmse_tsp100": 1.1719600947021271, "mse_worst": 1.3734904635742187, "rmse_worst": 1.1719600947021271}, "stats_text": "mse=0.408329; rmse=0.639006; mse_tsp100=1.37349; mse_tsp20=0.408329; mse_tsp50=0.737888; mse_worst=1.37349; rmse_tsp100=1.17196; rmse_tsp20=0.639006; rmse_tsp50=0.859004; rmse_worst=1.17196"}
{"score": 0.5099670467875159, "gamma": 0.1, "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its nearest neighbor among the unvisited, current, and start nodes, plus the minimum cost to connect the current and start nodes into this set.", "code_hash": "c6aa769dbe2000ef83f865ad1a9c3185a3f1e99084e3c90a1ff0a0dfe96f6796", "code": "# THOUGHT: {Estimate the future tour length as the sum of distances from each unvisited node to its nearest neighbor among the unvisited, current, and start nodes, plus the minimum cost to connect the current and start nodes into this set.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length based on a nearest-neighbor heuristic within the unvisited set,\n    also considering connections to the current and start nodes.\n    The cost is the sum of three components:\n    1. For each unvisited node, find the minimum distance to any other unvisited node. Sum these minimum distances.\n       This approximates the cost of connecting all unvisited nodes together.\n    2. The minimum cost to connect the current node to the set of unvisited nodes.\n    3. The minimum cost to connect the start node to the set of unvisited nodes.\n    This differs from MST by using a simpler, more local connection cost approximation.\n    \n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2], used to get B and N\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n\n    # 1. Approximate the cost to connect all unvisited nodes.\n    # For each unvisited node, find the distance to its nearest neighbor *that is also unvisited*.\n    # [B, N, N]\n    unvisited_dist = dist_matrix.clone()\n    # Mask rows and columns corresponding to visited nodes.\n    # To find min distance from unvisited `i` to unvisited `j`, we need row `i` and col `j` to be valid.\n    unvisited_row_mask = unvisited_mask.unsqueeze(2).expand(-1, -1, N)\n    unvisited_col_mask = unvisited_mask.unsqueeze(1).expand(-1, N, -1)\n    # Set distances to/from visited nodes to infinity.\n    unvisited_dist.masked_fill_(~unvisited_row_mask, float('inf'))\n    unvisited_dist.masked_fill_(~unvisited_col_mask, float('inf'))\n    # Set diagonal to infinity to avoid picking the node itself.\n    unvisited_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n    \n    # [B, N], min distance for each node to its nearest unvisited neighbor.\n    min_dists_to_unvisited, _ = torch.min(unvisited_dist, dim=2)\n    \n    # Sum these minimum distances. This is our approximation of the sub-tour cost.\n    # We only sum over the unvisited nodes.\n    # Replace inf with 0 for visited nodes so they don't contribute to the sum.\n    min_dists_to_unvisited.masked_fill_(~unvisited_mask, 0.0)\n    # [B]\n    subtour_cost_approx = min_dists_to_unvisited.sum(dim=1)\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set.\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Total estimated cost\n    value = subtour_cost_approx + min_dist_to_unvisited + min_dist_from_start\n\n    # Handle terminal states and potential infs\n    value.masked_fill_(is_terminal, 0.0)\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.49089173599243163, "rmse": 0.7006366647503053, "mse_tsp20": 0.49089173599243163, "rmse_tsp20": 0.7006366647503053, "mse_tsp50": 1.0416986204589844, "rmse_tsp50": 1.0206363801369145, "mse_tsp100": 1.9609110163085937, "rmse_tsp100": 1.4003253251686172, "mse_worst": 1.9609110163085937, "rmse_worst": 1.4003253251686172}, "stats_text": "mse=0.490892; rmse=0.700637; mse_tsp100=1.96091; mse_tsp20=0.490892; mse_tsp50=1.0417; mse_worst=1.96091; rmse_tsp100=1.40033; rmse_tsp20=0.700637; rmse_tsp50=1.02064; rmse_worst=1.40033"}
{"score": 0.14442194401455405, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The algorithm estimates the remaining tour length by multiplying the number of unvisited nodes by the average minimum distance from each unvisited node to any other unvisited node.", "code_hash": "948da801474913ef9ed2db71f330b186f78363384b494b85e41c1da0b92ac1a8", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The algorithm estimates the remaining tour length by multiplying the number of unvisited nodes by the average minimum distance from each unvisited node to any other unvisited node.}\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    n_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # For terminal states, the future cost is zero.\n    is_not_terminal = n_unvisited > 1\n    if not is_not_terminal.any():\n        return torch.zeros(dist_matrix.size(0), 1, device=dist_matrix.device)\n\n    # A large value to mask out irrelevant distances\n    large_value = dist_matrix.max() * 2 + 1 if dist_matrix.numel() > 0 else 1e9\n\n    # Create a temporary distance matrix where distances to/from visited nodes are masked\n    # [B, N, N]\n    temp_dist_matrix = dist_matrix.clone()\n    # Mask rows and columns corresponding to visited nodes\n    visited_mask = ~unvisited_mask\n    temp_dist_matrix[visited_mask, :] = large_value\n    temp_dist_matrix[:, visited_mask] = large_value\n    # Mask self-loops\n    temp_dist_matrix.diagonal(dim1=-2, dim2=-1).fill_(large_value)\n\n    # Find the minimum distance from each unvisited node to another unvisited node\n    # [B, N]\n    min_dists, _ = temp_dist_matrix.min(dim=2)\n\n    # Set distances from visited nodes to 0 so they don't affect the sum\n    min_dists.masked_fill_(visited_mask, 0)\n\n    # Calculate the average of these minimum distances\n    # Use a safe divisor to avoid division by zero for terminal states\n    safe_n_unvisited = torch.where(n_unvisited > 0, n_unvisited, torch.ones_like(n_unvisited))\n    # [B]\n    avg_min_dist = min_dists.sum(dim=1) / safe_n_unvisited\n\n    # Estimate the remaining tour length\n    # [B]\n    remaining_tour_length = n_unvisited * avg_min_dist\n\n    # Ensure terminal states have zero value\n    value = torch.where(is_not_terminal, remaining_tour_length, torch.tensor(0.0, device=dist_matrix.device))\n\n    return value.unsqueeze(-1)", "stats": {"mse": 1.8778033940429688, "rmse": 1.3703296661909385, "mse_tsp20": 1.8778033940429688, "rmse_tsp20": 1.3703296661909385, "mse_tsp50": 3.856727740234375, "rmse_tsp50": 1.9638553256883193, "mse_tsp100": 6.9241555140625, "rmse_tsp100": 2.6313790137611304, "mse_worst": 6.9241555140625, "rmse_worst": 2.6313790137611304}, "stats_text": "mse=1.8778; rmse=1.37033; mse_tsp100=6.92416; mse_tsp20=1.8778; mse_tsp50=3.85673; mse_worst=6.92416; rmse_tsp100=2.63138; rmse_tsp20=1.37033; rmse_tsp50=1.96386; rmse_worst=2.63138"}
{"score": 0.11230624864292459, "gamma": -0.1, "algorithm": "Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.", "code_hash": "0e7601ed649dfde68fc9175671d4df815cf1f6e8088ee79de00b3b2d9f6dd931", "code": "# THOUGHT: {Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on the geometric properties of unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes using the area of their convex hull.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n    This combines a geometric heuristic for the bulk of the path with connection costs.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n\n    # 1. Approximate sub-tour length using convex hull area of unvisited nodes\n    # A heuristic for tour length is related to the square root of the area of the convex hull.\n    # We use a simplified proxy: the area of the bounding box of unvisited nodes.\n\n    # Mask coordinates of visited nodes to exclude them from min/max calculations\n    # [B, N, 2]\n    masked_coords = coords.clone()\n    # Use a large value for visited nodes so they don't affect min, and a small value for max\n    large_val = torch.finfo(coords.dtype).max\n    small_val = torch.finfo(coords.dtype).min\n    # [B, N, 1]\n    unvisited_mask_exp = unvisited_mask.unsqueeze(-1)\n    masked_coords.masked_fill_(~unvisited_mask_exp, large_val)\n    min_coords, _ = torch.min(masked_coords, dim=1)  # [B, 2]\n\n    masked_coords = coords.clone()\n    masked_coords.masked_fill_(~unvisited_mask_exp, small_val)\n    max_coords, _ = torch.max(masked_coords, dim=1)  # [B, 2]\n\n    # Calculate width and height of the bounding box\n    # [B, 2]\n    span = max_coords - min_coords\n    # Clamp to avoid negative span if only one node is left\n    span = torch.clamp(span, min=0.0)\n    # [B]\n    area = span[:, 0] * span[:, 1]\n    # Heuristic for tour length: k * sqrt(Area * num_unvisited), k is an empirical factor\n    # For a unit square with N points, E[tour_len] ~ beta * sqrt(N), and Area=1.\n    # We use a simplified form: sqrt(Area) as a proxy for the spatial scale.\n    # The sum of two sides of the bounding box is a reasonable perimeter proxy.\n    subtour_cost = span[:, 0] + span[:, 1]\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, torch.finfo(dist_from_current.dtype).max)\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop)\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, torch.finfo(dist_from_start.dtype).max)\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Combine the components\n    # [B]\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n    \n    # Handle edge case where only one unvisited node remains\n    # The cost is just from current -> last_unvisited -> start\n    is_last_step = (num_unvisited.squeeze(-1) == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step]\n\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix[is_last_step, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix[is_last_step, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step] = last_step_cost\n\n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set if num_unvisited=0) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.9090601949462891, "rmse": 0.9534464824762264, "mse_tsp20": 0.9090601949462891, "rmse_tsp20": 0.9534464824762264, "mse_tsp50": 3.432229481640625, "rmse_tsp50": 1.852627723435182, "mse_tsp100": 8.904224048828125, "rmse_tsp100": 2.9839946462465585, "mse_worst": 8.904224048828125, "rmse_worst": 2.9839946462465585}, "stats_text": "mse=0.90906; rmse=0.953446; mse_tsp100=8.90422; mse_tsp20=0.90906; mse_tsp50=3.43223; mse_worst=8.90422; rmse_tsp100=2.98399; rmse_tsp20=0.953446; rmse_tsp50=1.85263; rmse_worst=2.98399"}
{"score": 0.07782706118698951, "gamma": -0.1, "algorithm": "Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.", "code_hash": "5fd3309104022111fb964be45f064a888499b1e8ed8f66c21cadfee07bffcee5", "code": "# THOUGHT: {Estimate the future tour length by summing the average distance from the current node to all unvisited nodes and the average distance from the start node to all unvisited nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length by averaging connection costs to the unvisited set.\n    The value is the sum of two components:\n    1. The average distance from the current node to all unvisited nodes.\n    2. The average distance from the start node to all unvisited nodes (to close the tour).\n    This heuristic focuses on the expected cost of the next and final connections.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N = unvisited_mask.shape\n    device = unvisited_mask.device\n    \n    # [B, 1]\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)\n    is_done = (num_unvisited == 0)\n\n    # Use a small epsilon to avoid division by zero when no nodes are unvisited\n    # The result for this case will be masked out later anyway.\n    num_unvisited_safe = num_unvisited.clamp(min=1.0)\n\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n\n    # 1. Average distance from the current node to the unvisited set\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    \n    # Mask out distances to already visited nodes\n    dist_from_current_unvisited = dist_from_current.masked_fill(~unvisited_mask, 0.0)\n    \n    # [B, 1]\n    sum_dist_from_current = dist_from_current_unvisited.sum(dim=1, keepdim=True)\n    avg_dist_from_current = sum_dist_from_current / num_unvisited_safe\n\n    # 2. Average distance from the start node to the unvisited set (for closing the loop)\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n\n    # Mask out distances to already visited nodes\n    dist_from_start_unvisited = dist_from_start.masked_fill(~unvisited_mask, 0.0)\n\n    # [B, 1]\n    sum_dist_from_start = dist_from_start_unvisited.sum(dim=1, keepdim=True)\n    avg_dist_from_start = sum_dist_from_start / num_unvisited_safe\n\n    # Combine the components\n    # [B, 1]\n    value = avg_dist_from_current + avg_dist_from_start\n    \n    # Handle the special case where only one unvisited node remains.\n    # The cost is exactly current -> last -> start.\n    is_last_step = (num_unvisited == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step.squeeze(-1)].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step.squeeze(-1)]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step.squeeze(-1)]\n        \n        # [B_last, N, N]\n        dist_matrix_last = dist_matrix[is_last_step.squeeze(-1)]\n        \n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix_last[:, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix_last[:, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = (dist_curr_to_last + dist_last_to_start).unsqueeze(-1)\n        value = torch.where(is_last_step, last_step_cost, value)\n\n    # If the tour is done, the future cost is zero.\n    value.masked_fill_(is_done, 0.0)\n\n    return value", "stats": {"mse": 1.5873716700439453, "rmse": 1.2599093896165492, "mse_tsp20": 1.5873716700439453, "rmse_tsp20": 1.2599093896165492, "mse_tsp50": 4.672369123242188, "rmse_tsp50": 2.161566358741315, "mse_tsp100": 12.849001166796874, "rmse_tsp100": 3.58455034373865, "mse_worst": 12.849001166796874, "rmse_worst": 3.58455034373865}, "stats_text": "mse=1.58737; rmse=1.25991; mse_tsp100=12.849; mse_tsp20=1.58737; mse_tsp50=4.67237; mse_worst=12.849; rmse_tsp100=3.58455; rmse_tsp20=1.25991; rmse_tsp50=2.16157; rmse_worst=3.58455"}
{"score": 3.4209696471518978, "gamma": -0.1, "algorithm": "Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.", "code_hash": "d5014fe6247751116f6de4174accdec9f7c2eafdcfcbe2f724c5ad25941cb364", "code": "# THOUGHT: {Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length using a Minimum Spanning Tree (MST) based heuristic.\n    The cost is the sum of three components:\n    1. The cost of the MST of the subgraph formed by the unvisited nodes. This provides a\n       tight lower bound on the optimal sub-tour length for these nodes.\n    2. The minimum cost to connect the current node to the set of unvisited nodes.\n    3. The minimum cost to connect the start node to the set of unvisited nodes,\n       which is necessary for closing the tour.\n    \n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n    \n    # 1. Calculate the cost of the MST on the unvisited nodes.\n    # Prim's algorithm for dense graphs.\n    # We will compute this only for batches where there are unvisited nodes.\n    # [B, N]\n    min_cost = torch.full((B, N), float('inf'), device=device)\n    # [B, N]\n    visited_in_mst = torch.zeros_like(unvisited_mask)\n    # [B]\n    mst_cost = torch.zeros(B, device=device)\n    \n    # Initialize Prim's: pick the first unvisited node as the starting point for the MST.\n    # Find the index of the first 'True' in unvisited_mask for each batch item.\n    first_unvisited_idx = torch.argmax(unvisited_mask.int(), dim=1)\n    \n    # Set the min_cost for the starting node of the MST to 0.\n    # This ensures it's the first one picked.\n    min_cost.scatter_(1, first_unvisited_idx.unsqueeze(1), 0)\n    \n    # Mask min_cost for nodes that are already visited in the main tour.\n    min_cost.masked_fill_(~unvisited_mask, float('inf'))\n\n    # Prim's algorithm loop executed in a parallelized way over N-1 steps.\n    # This is a fixed-iteration loop, avoiding dynamic Python loops.\n    for _ in range(N):\n        # Find the node `u` with the minimum cost that is unvisited in the MST.\n        # [B, 1]\n        u_idx = torch.argmin(min_cost, dim=1, keepdim=True)\n        # [B]\n        u_cost = torch.gather(min_cost, 1, u_idx).squeeze(1)\n        \n        # Add its cost to the total MST cost, handling inf for disconnected components.\n        mst_cost += torch.where(u_cost == float('inf'), 0, u_cost)\n        \n        # Mark `u` as visited in the MST and remove it from consideration.\n        visited_in_mst.scatter_(1, u_idx, True)\n        min_cost.scatter_(1, u_idx, float('inf'))\n\n        # Update min_costs for neighbors of `u`.\n        # [B, N]\n        dist_from_u = torch.gather(dist_matrix, 1, u_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        \n        # Update only if the new path through `u` is shorter and the neighbor is unvisited in MST.\n        # We also need to ensure the neighbor is part of the unvisited set for the main tour.\n        update_mask = (dist_from_u < min_cost) & ~visited_in_mst & unvisited_mask\n        min_cost[update_mask] = dist_from_u[update_mask]\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    # Mask distances to already visited nodes.\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop).\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Total estimated cost\n    # For the case with only one unvisited node, MST cost is 0. The formula becomes\n    # dist(current -> last) + dist(start -> last), which is correct.\n    value = mst_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # For terminal states, future cost is 0.\n    value.masked_fill_(is_terminal, 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0.\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.18682559706115723, "rmse": 0.4322332669533399, "mse_tsp20": 0.18682559706115723, "rmse_tsp20": 0.4322332669533399, "mse_tsp50": 0.19572340977783204, "rmse_tsp50": 0.4424063853266949, "mse_tsp100": 0.2923147829833984, "rmse_tsp100": 0.5406614310114958, "mse_worst": 0.2923147829833984, "rmse_worst": 0.5406614310114958}, "stats_text": "mse=0.186826; rmse=0.432233; mse_tsp100=0.292315; mse_tsp20=0.186826; mse_tsp50=0.195723; mse_worst=0.292315; rmse_tsp100=0.540661; rmse_tsp20=0.432233; rmse_tsp50=0.442406; rmse_worst=0.540661"}
{"score": 3.406448250786877, "gamma": -0.1, "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.", "code_hash": "a509be98760cefdd1fed21f2974aece62623fff8e8b93600894306f7a87ee209", "code": "# THOUGHT: {Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for a TSP state.\n    The estimation is based on three components:\n    1. The cost of a Minimum Spanning Tree (MST) over all unvisited nodes.\n    2. The minimum cost to connect the current node to one of the unvisited nodes.\n    3. The minimum cost to connect the start node to one of the unvisited nodes.\n    This heuristic approximates the cost of visiting all remaining nodes and returning home.\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # 1. MST cost on unvisited nodes\n    # Create a subgraph distance matrix for unvisited nodes\n    # [B, N, N]\n    unvisited_dist = dist_matrix.clone()\n    # Mask rows and columns for visited nodes by setting distances to infinity\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n\n    # Prim's algorithm for MST cost\n    # [B]\n    num_unvisited = unvisited_mask.sum(dim=1)\n    # [B, N], init with large values\n    min_cost = torch.full_like(unvisited_mask, float('inf'), dtype=dist_matrix.dtype)\n    # [B, N], init with False\n    in_mst = torch.zeros_like(unvisited_mask, dtype=torch.bool)\n    # [B]\n    mst_cost = torch.zeros(B, device=dist_matrix.device)\n\n    # Find the first unvisited node to start Prim's algorithm\n    # [B], indices of first unvisited nodes\n    start_node_idx = torch.where(unvisited_mask.any(1), unvisited_mask.float().argmax(1), -1)\n\n    # Set the cost of the starting node to 0\n    # Use scatter for batched indexing\n    min_cost.scatter_(1, start_node_idx.unsqueeze(1).clamp(min=0), 0)\n\n    # Prim's algorithm loop (vectorized)\n    # This loop runs N times, which is more than necessary but avoids dynamic loops\n    # and is safe because nodes already in MST won't be chosen again.\n    for _ in range(N):\n        # Select node `u` not in MST with the minimum cost\n        # [B, N]\n        cost_if_not_in_mst = min_cost.clone()\n        cost_if_not_in_mst.masked_fill_(in_mst, float('inf'))\n        # [B, 1]\n        u_cost, u_idx = cost_if_not_in_mst.min(dim=1, keepdim=True)\n\n        # Add cost to total and mark node as in MST\n        # This mask handles batches where no unvisited nodes are left (u_cost is inf)\n        is_finite_mask = torch.isfinite(u_cost.squeeze(-1))\n        mst_cost[is_finite_mask] += u_cost[is_finite_mask].squeeze(-1)\n        in_mst.scatter_(1, u_idx.clamp(min=0), True)\n\n        # Update min_cost for neighbors of `u`\n        # [B, 1, N]\n        dist_from_u = torch.gather(unvisited_dist, 1, u_idx.unsqueeze(-1).expand(-1, 1, N))\n        # [B, N]\n        dist_from_u_squeezed = dist_from_u.squeeze(1)\n        # [B, N]\n        min_cost = torch.min(min_cost, dist_from_u_squeezed)\n\n    # 2. Minimum cost from current node to any unvisited node\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_exp = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_exp)\n    # [B, N]\n    dist_from_current_squeezed = dist_from_current.squeeze(1)\n    dist_from_current_squeezed.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_to_unvisited = dist_from_current_squeezed.min(dim=1).values\n    min_to_unvisited.masked_fill_(num_unvisited == 0, 0) # If no unvisited, cost is 0\n\n    # 3. Minimum cost from start node to any unvisited node\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    first_node_exp = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_start = torch.gather(dist_matrix, 1, first_node_exp)\n    # [B, N]\n    dist_from_start_squeezed = dist_from_start.squeeze(1)\n    dist_from_start_squeezed.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_to_return = dist_from_start_squeezed.min(dim=1).values\n    min_to_return.masked_fill_(num_unvisited == 0, 0) # If no unvisited, cost is 0\n\n    # Total estimated cost\n    # Special case: if only one unvisited node, MST cost is 0. The cost is just to go there and back.\n    # [B]\n    is_one_unvisited = (num_unvisited == 1)\n    # [B, 1]\n    first_unvisited_idx = torch.where(is_one_unvisited, unvisited_mask.float().argmax(1).unsqueeze(-1), -1)\n    # [B, 1]\n    dist_curr_to_last = torch.gather(dist_from_current_squeezed, 1, first_unvisited_idx.clamp(min=0))\n    # [B, 1]\n    dist_last_to_start = torch.gather(dist_from_start_squeezed, 1, first_unvisited_idx.clamp(min=0))\n    # [B]\n    one_unvisited_cost = (dist_curr_to_last + dist_last_to_start).squeeze(-1)\n\n    # Combine costs\n    value = torch.where(is_one_unvisited, one_unvisited_cost, mst_cost + min_to_unvisited + min_to_return)\n\n    # Final state: tour complete, cost is 0\n    value.masked_fill_(num_unvisited == 0, 0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.19756102726745606, "rmse": 0.444478376602795, "mse_tsp20": 0.19756102726745606, "rmse_tsp20": 0.444478376602795, "mse_tsp50": 0.20184117449951172, "rmse_tsp50": 0.44926737528949473, "mse_tsp100": 0.29356089580078126, "rmse_tsp100": 0.5418126021059138, "mse_worst": 0.29356089580078126, "rmse_worst": 0.5418126021059138}, "stats_text": "mse=0.197561; rmse=0.444478; mse_tsp100=0.293561; mse_tsp20=0.197561; mse_tsp50=0.201841; mse_worst=0.293561; rmse_tsp100=0.541813; rmse_tsp20=0.444478; rmse_tsp50=0.449267; rmse_worst=0.541813"}
{"score": 3.3781803516081297, "gamma": 1.0, "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.", "code_hash": "54055c1f192cd4960761c781d6f2bc50f9e6fcc45c0de48c9b7057e7a6b4b015", "code": "# THOUGHT: {Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for TSP.\n    The estimate is composed of three parts:\n    1. The cost of a Minimum Spanning Tree (MST) over all unvisited nodes. This approximates\n       the shortest path needed to connect all remaining nodes.\n    2. The cost to connect the current node to the set of unvisited nodes (minimum edge).\n    3. The cost to connect the start node to the set of unvisited nodes (minimum edge).\n    This forms a lower bound on the remaining tour length, as it approximates a path\n    connecting the current node, all unvisited nodes, and returning to the start.\n\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # 1. Calculate the cost of the MST on the subgraph of unvisited nodes.\n    # We use a Prim's algorithm-like approach.\n    # Create a distance matrix for only the unvisited nodes.\n    # Mask rows and columns corresponding to visited nodes.\n    unvisited_dist_matrix = dist_matrix.clone()\n    # Mask rows for visited nodes\n    unvisited_dist_matrix.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n    # Mask columns for visited nodes\n    unvisited_dist_matrix.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n\n    # Prim's algorithm to find MST cost\n    # `in_mst` mask: nodes already included in the MST\n    in_mst = torch.zeros_like(unvisited_mask)\n    # `min_cost` array: min cost to connect each node to the MST\n    min_cost = torch.full((B, N), float('inf'), device=dist_matrix.device, dtype=dist_matrix.dtype)\n\n    # Find the first unvisited node to start Prim's algorithm\n    # This is guaranteed to exist if there are unvisited nodes.\n    first_unvisited_idx = torch.argmax(unvisited_mask.float(), dim=1, keepdim=True)\n\n    # Initialize: select the first unvisited node. Its cost to connect is 0.\n    min_cost.scatter_(1, first_unvisited_idx, 0)\n\n    # Iteratively add N-1 nodes to the MST (or until all unvisited are added)\n    # This loop is fixed to N, which is acceptable as it's not a Python loop.\n    mst_cost = torch.zeros(B, device=dist_matrix.device, dtype=dist_matrix.dtype)\n    for _ in range(N):\n        # Find the node not in MST with the minimum connection cost\n        cost_to_add = min_cost.clone()\n        cost_to_add.masked_fill_(in_mst, float('inf'))\n        # If no nodes are left to add (all unvisited are in mst), cost will be inf\n        min_val, new_node_idx = torch.min(cost_to_add, dim=1)\n\n        # Create a mask for valid additions (cost is not inf)\n        is_valid_addition = min_val != float('inf')\n        \n        # Add its cost to the total MST cost\n        mst_cost += min_val.where(is_valid_addition, torch.tensor(0.0, device=mst_cost.device))\n\n        # Add the new node to the MST\n        new_node_idx = new_node_idx.unsqueeze(1)\n        in_mst.scatter_(1, new_node_idx, True)\n\n        # Update min_cost for all nodes based on the newly added node\n        # Distances from the newly added node to all other nodes\n        dist_from_new = torch.gather(unvisited_dist_matrix, 1, new_node_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        min_cost = torch.min(min_cost, dist_from_new)\n\n    # 2. Find the minimum cost to connect the current node to any unvisited node.\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx)\n    # Mask distances to already visited nodes\n    dist_from_current.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # [B]\n    min_dist_from_current, _ = torch.min(dist_from_current.squeeze(1), dim=1)\n    # If no unvisited nodes, this cost is 0 (or inf, we handle it)\n    min_dist_from_current.masked_fill_(~unvisited_mask.any(dim=1), 0)\n\n    # 3. Find the minimum cost to connect the start node to any unvisited node.\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx)\n    # Mask distances to already visited nodes\n    dist_from_start.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start.squeeze(1), dim=1)\n    # If no unvisited nodes, this cost is 0\n    min_dist_from_start.masked_fill_(~unvisited_mask.any(dim=1), 0)\n    \n    # In terminal states, there are no unvisited nodes. The MST cost will be 0,\n    # and the connection costs will be 0. The only remaining cost is to return to start.\n    is_terminal = ~unvisited_mask.any(dim=1)\n    # [B]\n    dist_to_start_terminal = torch.gather(dist_matrix, 1, state.current_node_index().unsqueeze(1).unsqueeze(2)).squeeze()\n    dist_to_start_terminal = torch.gather(dist_to_start_terminal, 1, state.first_node_index().unsqueeze(1)).squeeze(1)\n\n    # Total estimated future cost\n    value = mst_cost + min_dist_from_current + min_dist_from_start\n    # For terminal states, the value is just the cost to return home\n    value = torch.where(is_terminal, dist_to_start_terminal, value)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.21352034575653075, "rmse": 0.4620826178904923, "mse_tsp20": 0.21352034575653075, "rmse_tsp20": 0.4620826178904923, "mse_tsp50": 0.20358135737304686, "rmse_tsp50": 0.4511999084364345, "mse_tsp100": 0.2960173513305664, "rmse_tsp100": 0.5440747663056672, "mse_worst": 0.2960173513305664, "rmse_worst": 0.5440747663056672}, "stats_text": "mse=0.21352; rmse=0.462083; mse_tsp100=0.296017; mse_tsp20=0.21352; mse_tsp50=0.203581; mse_worst=0.296017; rmse_tsp100=0.544075; rmse_tsp20=0.462083; rmse_tsp50=0.4512; rmse_worst=0.544075"}
{"score": 2.527232641964477, "gamma": 0.1, "algorithm": "Estimate the future tour length by summing the average distance from each unvisited node to its k-nearest unvisited neighbors, plus the cost to connect the current and start nodes to this unvisited cluster.", "code_hash": "dc604ef673fe9a7e63912216f576b19094fd380b26a2e04c3e2c3d74e5ee3b99", "code": "# THOUGHT: {Estimate the future tour length by summing the average distance from each unvisited node to its k-nearest unvisited neighbors, plus the cost to connect the current and start nodes to this unvisited cluster.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on local connectivity of unvisited nodes.\n    The value is the sum of three components:\n    1. For each unvisited node, calculate the average distance to its k-nearest\n       neighbors that are also unvisited. Summing these averages provides a\n       proxy for the sub-tour cost, similar to but simpler than MST.\n    2. The minimum cost to connect the current node to any unvisited node.\n    3. The minimum cost to connect the start node to any unvisited node,\n       approximating the cost of closing the tour.\n    This uses all_node_coords() to get the distance matrix.\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal states where no nodes are unvisited\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n\n    # 1. Estimate sub-tour cost for unvisited nodes using k-nearest neighbors.\n    # [B, N, N]\n    masked_dist = dist_matrix.clone()\n    # Mask connections to/from already visited nodes.\n    # [B, 1, N]\n    unvisited_mask_from = unvisited_mask.unsqueeze(1)\n    # [B, N, 1]\n    unvisited_mask_to = unvisited_mask.unsqueeze(2)\n    # Set distances to/from visited nodes to infinity.\n    masked_dist.masked_fill_(~unvisited_mask_from | ~unvisited_mask_to, float('inf'))\n    # Set diagonal to infinity to exclude self-loops.\n    masked_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n\n    # Sort distances to find k-nearest neighbors for each unvisited node.\n    # [B, N, N]\n    sorted_dist, _ = torch.sort(masked_dist, dim=2)\n\n    # Use a dynamic k, e.g., min(3, number of other unvisited nodes)\n    # This avoids issues when few nodes are left.\n    k = torch.min(torch.tensor(3, device=device), n_unvisited.clamp(min=1) - 1)\n    k = k.clamp(min=1) # Ensure k is at least 1 for non-terminal states.\n\n    # [B, N, k_max=3]\n    k_nearest_dists = sorted_dist[:, :, :3]\n\n    # Create a mask for averaging based on dynamic k.\n    # [B, 1, 3]\n    k_range = torch.arange(3, device=device).view(1, 1, 3)\n    # [B, N, 3]\n    k_mask = k_range < k.view(B, 1, 1)\n\n    # Calculate average distance to k-nearest unvisited neighbors.\n    # [B, N, 3]\n    k_nearest_dists.masked_fill_(~k_mask, 0.0)\n    # [B, N]\n    sum_k_dists = k_nearest_dists.sum(dim=2)\n    # [B, N]\n    avg_k_dist = sum_k_dists / k.view(B, 1).float()\n\n    # Sum these averages only for the unvisited nodes.\n    avg_k_dist.masked_fill_(~unvisited_mask, 0.0)\n    # [B]\n    subtour_cost_estimate = avg_k_dist.sum(dim=1)\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited = torch.min(dist_from_current, dim=1).values\n\n    # 3. Cost to connect the start node to the unvisited set.\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start = torch.min(dist_from_start, dim=1).values\n\n    # Total estimated cost\n    value = subtour_cost_estimate + min_dist_to_unvisited + min_dist_from_start\n\n    # For terminal states, future cost is 0.\n    value.masked_fill_(is_terminal, 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0.\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.39568972930908203, "rmse": 0.6290387343471641, "mse_tsp20": 0.39568972930908203, "rmse_tsp20": 0.6290387343471641, "mse_tsp50": 0.20146149614257813, "rmse_tsp50": 0.4488446236088588, "mse_tsp100": 0.17992913677978514, "rmse_tsp100": 0.42418054738493743, "mse_worst": 0.39568972930908203, "rmse_worst": 0.6290387343471641}, "stats_text": "mse=0.39569; rmse=0.629039; mse_tsp100=0.179929; mse_tsp20=0.39569; mse_tsp50=0.201461; mse_worst=0.39569; rmse_tsp100=0.424181; rmse_tsp20=0.629039; rmse_tsp50=0.448845; rmse_worst=0.629039"}
{"score": 2.423034464838014, "gamma": -0.1, "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.", "code_hash": "1b3b0812ca98a6aa6a8fb459b2e47dca3884b0f5419dcd0d7504221710b3f7b9", "code": "# THOUGHT: {Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length by approximating a path through unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes. For each unvisited node,\n       we find the distance to its two nearest neighbors among the other unvisited nodes.\n       The sum of these distances, averaged over all unvisited nodes, provides an estimate\n       of the local path cost. This is scaled by the number of unvisited nodes.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n    is_last_step = (num_unvisited == 1)\n    is_penultimate = (num_unvisited == 2)\n\n    # 1. Approximate sub-tour length through unvisited nodes\n    # Create a distance matrix only considering unvisited nodes.\n    # We set distances to/from visited nodes to infinity.\n    unvisited_dist = dist_matrix.clone()\n    inf = torch.finfo(dist_matrix.dtype).max\n    # Mask rows (from) and columns (to) corresponding to visited nodes\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), inf)\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), inf)\n\n    # For each unvisited node, find the distances to its two nearest unvisited neighbors.\n    # We use k=3 because the node itself is included with distance 0.\n    # [B, N, 3]\n    k = min(3, N) # handle N < 3 case\n    topk_dists, _ = torch.topk(unvisited_dist, k, dim=2, largest=False)\n\n    # The first value (k=0) is always 0 (distance to self), so we take k=1 and k=2.\n    # Sum of distances to two nearest neighbors for each node.\n    # If less than 3 unvisited nodes, some of these will be inf.\n    if k > 2:\n        two_nn_dist_sum = topk_dists[:, :, 1] + topk_dists[:, :, 2] # [B, N]\n    elif k > 1:\n        two_nn_dist_sum = topk_dists[:, :, 1] # [B, N]\n    else:\n        two_nn_dist_sum = torch.zeros_like(unvisited_mask, dtype=dist_matrix.dtype)\n\n\n    # Mask out the sums for visited nodes\n    two_nn_dist_sum.masked_fill_(~unvisited_mask, 0.0)\n\n    # The sum of these distances over all unvisited nodes, divided by 2 (since each edge is counted twice),\n    # approximates the MST length, which is a lower bound on the tour length.\n    # We use the sum directly as a heuristic.\n    subtour_cost = torch.sum(two_nn_dist_sum, dim=1) / 2.0\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    # [B]\n    min_dist_to_unvisited = torch.min(dist_from_current.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # 3. Cost to connect the start node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    # [B]\n    min_dist_from_start = torch.min(dist_from_start.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # Combine the components\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # Handle edge cases where subtour_cost is not well-defined\n    # If only two unvisited nodes, cost is current->A->B->start or current->B->A->start\n    if torch.any(is_penultimate):\n      # [B_pen, 2]\n      unvisited_indices = unvisited_mask[is_penultimate.squeeze(-1)].long().nonzero(as_tuple=False)[:, 1].view(-1, 2)\n      node_a_idx, node_b_idx = unvisited_indices[:, 0], unvisited_indices[:, 1]\n      \n      current_node_pen = state.current_node_index()[is_penultimate.squeeze(-1)]\n      start_node_pen = state.first_node_index()[is_penultimate.squeeze(-1)]\n      dist_matrix_pen = dist_matrix[is_penultimate.squeeze(-1)]\n\n      dist_curr_a = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_a_idx]\n      dist_curr_b = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_b_idx]\n      dist_a_b = dist_matrix_pen[torch.arange(len(node_a_idx)), node_a_idx, node_b_idx]\n      dist_a_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_a_idx, start_node_pen]\n      dist_b_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_b_idx, start_node_pen]\n      \n      cost1 = dist_curr_a + dist_a_b + dist_b_start\n      cost2 = dist_curr_b + dist_a_b + dist_a_start\n      penultimate_cost = torch.min(cost1, cost2)\n      value[is_penultimate.squeeze(-1)] = penultimate_cost\n\n    # If only one unvisited node, cost is current -> last -> start\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step.squeeze(-1)].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_from_current[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        dist_last_to_start = torch.gather(dist_from_start[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step.squeeze(-1)] = last_step_cost\n    \n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.2396109479522705, "rmse": 0.48950071292314834, "mse_tsp20": 0.2396109479522705, "rmse_tsp20": 0.48950071292314834, "mse_tsp50": 0.24980534642333985, "rmse_tsp50": 0.4998053085185669, "mse_tsp100": 0.41270564431152346, "rmse_tsp100": 0.6424217028646553, "mse_worst": 0.41270564431152346, "rmse_worst": 0.6424217028646553}, "stats_text": "mse=0.239611; rmse=0.489501; mse_tsp100=0.412706; mse_tsp20=0.239611; mse_tsp50=0.249805; mse_worst=0.412706; rmse_tsp100=0.642422; rmse_tsp20=0.489501; rmse_tsp50=0.499805; rmse_worst=0.642422"}
{"score": 0.7280720372806312, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.", "code_hash": "0cc2a43e13841f036b76914d86123d54dbc39c9e3e58d8eeb12c85a3cec64035", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.}\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node_idx = state.current_node_index()\n    # [B]\n    first_node_idx = state.first_node_index()\n    # [B]\n    batch_indices = torch.arange(dist_matrix.size(0), device=dist_matrix.device)\n\n    # Cost to return to the start node from the current node\n    # [B]\n    dist_to_start = dist_matrix[batch_indices, current_node_idx, first_node_idx]\n\n    # For each unvisited node, find its minimum connection cost to any other node.\n    # We set diagonal to infinity to avoid picking the zero-cost self-connection.\n    # [B, N, N]\n    dist_matrix_no_self = dist_matrix + torch.diag(torch.full((dist_matrix.size(1),), float('inf'), device=dist_matrix.device))\n    # [B, N]\n    min_dist_per_node, _ = torch.min(dist_matrix_no_self, dim=2)\n    \n    # Sum these minimum distances only for the unvisited nodes\n    # [B, N]\n    min_dist_per_node.masked_fill_(~unvisited_mask, 0)\n    # [B]\n    sum_min_dists = torch.sum(min_dist_per_node, dim=1)\n    \n    # The total estimated cost is the sum of minimum connection costs for unvisited nodes\n    # plus the cost to return to the start node from the current node.\n    # [B]\n    value = sum_min_dists + dist_to_start\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.4083288623046875, "rmse": 0.6390061520084822, "mse_tsp20": 0.4083288623046875, "rmse_tsp20": 0.6390061520084822, "mse_tsp50": 0.7378879370117187, "rmse_tsp50": 0.8590040378320225, "mse_tsp100": 1.3734904635742187, "rmse_tsp100": 1.1719600947021271, "mse_worst": 1.3734904635742187, "rmse_worst": 1.1719600947021271}, "stats_text": "mse=0.408329; rmse=0.639006; mse_tsp100=1.37349; mse_tsp20=0.408329; mse_tsp50=0.737888; mse_worst=1.37349; rmse_tsp100=1.17196; rmse_tsp20=0.639006; rmse_tsp50=0.859004; rmse_worst=1.17196"}
{"score": 0.5099670467875159, "gamma": 0.1, "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its nearest neighbor among the unvisited, current, and start nodes, plus the minimum cost to connect the current and start nodes into this set.", "code_hash": "c6aa769dbe2000ef83f865ad1a9c3185a3f1e99084e3c90a1ff0a0dfe96f6796", "code": "# THOUGHT: {Estimate the future tour length as the sum of distances from each unvisited node to its nearest neighbor among the unvisited, current, and start nodes, plus the minimum cost to connect the current and start nodes into this set.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length based on a nearest-neighbor heuristic within the unvisited set,\n    also considering connections to the current and start nodes.\n    The cost is the sum of three components:\n    1. For each unvisited node, find the minimum distance to any other unvisited node. Sum these minimum distances.\n       This approximates the cost of connecting all unvisited nodes together.\n    2. The minimum cost to connect the current node to the set of unvisited nodes.\n    3. The minimum cost to connect the start node to the set of unvisited nodes.\n    This differs from MST by using a simpler, more local connection cost approximation.\n    \n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2], used to get B and N\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n\n    # 1. Approximate the cost to connect all unvisited nodes.\n    # For each unvisited node, find the distance to its nearest neighbor *that is also unvisited*.\n    # [B, N, N]\n    unvisited_dist = dist_matrix.clone()\n    # Mask rows and columns corresponding to visited nodes.\n    # To find min distance from unvisited `i` to unvisited `j`, we need row `i` and col `j` to be valid.\n    unvisited_row_mask = unvisited_mask.unsqueeze(2).expand(-1, -1, N)\n    unvisited_col_mask = unvisited_mask.unsqueeze(1).expand(-1, N, -1)\n    # Set distances to/from visited nodes to infinity.\n    unvisited_dist.masked_fill_(~unvisited_row_mask, float('inf'))\n    unvisited_dist.masked_fill_(~unvisited_col_mask, float('inf'))\n    # Set diagonal to infinity to avoid picking the node itself.\n    unvisited_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n    \n    # [B, N], min distance for each node to its nearest unvisited neighbor.\n    min_dists_to_unvisited, _ = torch.min(unvisited_dist, dim=2)\n    \n    # Sum these minimum distances. This is our approximation of the sub-tour cost.\n    # We only sum over the unvisited nodes.\n    # Replace inf with 0 for visited nodes so they don't contribute to the sum.\n    min_dists_to_unvisited.masked_fill_(~unvisited_mask, 0.0)\n    # [B]\n    subtour_cost_approx = min_dists_to_unvisited.sum(dim=1)\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set.\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Total estimated cost\n    value = subtour_cost_approx + min_dist_to_unvisited + min_dist_from_start\n\n    # Handle terminal states and potential infs\n    value.masked_fill_(is_terminal, 0.0)\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.49089173599243163, "rmse": 0.7006366647503053, "mse_tsp20": 0.49089173599243163, "rmse_tsp20": 0.7006366647503053, "mse_tsp50": 1.0416986204589844, "rmse_tsp50": 1.0206363801369145, "mse_tsp100": 1.9609110163085937, "rmse_tsp100": 1.4003253251686172, "mse_worst": 1.9609110163085937, "rmse_worst": 1.4003253251686172}, "stats_text": "mse=0.490892; rmse=0.700637; mse_tsp100=1.96091; mse_tsp20=0.490892; mse_tsp50=1.0417; mse_worst=1.96091; rmse_tsp100=1.40033; rmse_tsp20=0.700637; rmse_tsp50=1.02064; rmse_worst=1.40033"}
{"score": 0.3754282050779197, "gamma": -0.1, "algorithm": "Estimate future tour length by finding the convex hull of unvisited nodes, adding the current and start nodes, and approximating the tour length of this reduced set.", "code_hash": "f9ca596711c451807e7294379e191f66401b10e6ea8572da9b04c1ab8062bfab", "code": "# THOUGHT: {Estimate future tour length by finding the convex hull of unvisited nodes, adding the current and start nodes, and approximating the tour length of this reduced set.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for TSP using a convex hull approximation.\n    1. Identify all unvisited nodes.\n    2. Find the convex hull of these unvisited nodes.\n    3. Add the current node and the start node to this set of hull points.\n    4. Calculate the perimeter of the convex hull of this combined set of points,\n       which serves as a lower-bound estimate for the path length needed to\n       connect these critical outer points.\n    5. Add the sum of minimum distances from each non-hull unvisited node to its\n       nearest node on the hull, approximating the cost to connect internal points.\n\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = coords.shape\n    device = coords.device\n    dtype = coords.dtype\n\n    # Handle terminal states: future cost is distance from current to start\n    is_terminal = ~unvisited_mask.any(dim=1)\n    dist_matrix = state.distance_matrix()\n    current_idx = state.current_node_index()\n    start_idx = state.first_node_index()\n    # Using gather for robust indexing\n    dist_to_start_terminal = torch.gather(dist_matrix, 1, current_idx.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_to_start_terminal = torch.gather(dist_to_start_terminal, 1, start_idx.view(B, 1)).squeeze(1)\n\n    # For non-terminal states\n    # Create a large coordinate value for visited nodes so they don't affect the hull\n    large_coord = coords.abs().max() + 1.0\n    unvisited_coords = coords.where(unvisited_mask.unsqueeze(-1), torch.full_like(coords, large_coord))\n\n    # Find the bottom-most point among unvisited nodes to start Graham scan\n    # In case of a tie, take the left-most one\n    y_coords = unvisited_coords[:, :, 1]\n    min_y, _ = y_coords.min(dim=1, keepdim=True)\n    is_min_y = (y_coords == min_y)\n    x_coords_at_min_y = torch.where(is_min_y, unvisited_coords[:, :, 0], torch.full_like(unvisited_coords[:, :, 0], float('inf')))\n    min_x_at_min_y, start_node_idx = x_coords_at_min_y.min(dim=1, keepdim=True)\n    \n    start_node_coords = torch.gather(coords, 1, start_node_idx.unsqueeze(-1).expand(-1, -1, 2))\n\n    # Calculate polar angles with respect to the start point\n    delta = unvisited_coords - start_node_coords\n    angles = torch.atan2(delta[:, :, 1], delta[:, :, 0])\n    # Mask out the start point itself from sorting\n    angles.scatter_(1, start_node_idx, float('inf'))\n    # Sort unvisited nodes by angle\n    sorted_indices = torch.argsort(angles, dim=1)\n    sorted_coords = torch.gather(coords, 1, sorted_indices.unsqueeze(-1).expand(-1, -1, 2))\n\n    # Build the convex hull using a batched Graham scan\n    hull_indices = torch.full((B, N + 1), -1, dtype=torch.long, device=device)\n    hull_indices[:, 0] = start_node_idx.squeeze(1)\n    hull_indices[:, 1] = sorted_indices[:, 0]\n    \n    # This part is tricky to fully vectorize without a loop, but we can approximate\n    # For simplicity and to avoid loops, we approximate the hull tour length\n    # by taking the sorted points. This is an overestimation but captures the shape.\n    # A true Graham scan is iterative. Let's use a simpler heuristic:\n    # Perimeter of the convex hull of a point set is a good lower bound.\n    # We will approximate this by creating a \"critical set\" of points.\n    \n    # 1. Critical points = current_node, start_node, and unvisited nodes\n    critical_mask = unvisited_mask.clone()\n    critical_mask.scatter_(1, current_idx.unsqueeze(1), True)\n    critical_mask.scatter_(1, start_idx.unsqueeze(1), True)\n\n    # 2. Find min/max x/y coordinates among these critical points\n    masked_coords = coords.where(critical_mask.unsqueeze(-1), torch.full_like(coords, float('inf')))\n    neg_masked_coords = coords.where(critical_mask.unsqueeze(-1), torch.full_like(coords, float('-inf')))\n    \n    min_x, _ = masked_coords[:, :, 0].min(dim=1)\n    max_x, _ = neg_masked_coords[:, :, 0].max(dim=1)\n    min_y, _ = masked_coords[:, :, 1].min(dim=1)\n    max_y, _ = neg_masked_coords[:, :, 1].max(dim=1)\n\n    # 3. Estimate perimeter of the bounding box as a proxy for hull perimeter\n    # This is a simple, permutation-invariant lower bound.\n    perimeter_approx = 2 * ((max_x - min_x) + (max_y - min_y))\n    # Replace inf with 0 for cases with no unvisited nodes\n    perimeter_approx = torch.nan_to_num(perimeter_approx, nan=0.0, posinf=0.0, neginf=0.0)\n\n    # 4. For unvisited nodes not on the \"bounding box\", add cost to connect to the closest point\n    # on the bounding box. We approximate this with min distance to any other unvisited node.\n    unvisited_dist = dist_matrix.clone()\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # Set diagonal to infinity to find nearest *other* unvisited node\n    unvisited_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n    \n    min_dists, _ = unvisited_dist.min(dim=2)\n    # Only sum costs for unvisited nodes\n    min_dists.masked_fill_(~unvisited_mask, 0)\n    \n    internal_cost = min_dists.sum(dim=1) * 0.5 # Each edge is counted twice, so halve it.\n\n    value = perimeter_approx + internal_cost\n    \n    # Combine terminal and non-terminal values\n    final_value = torch.where(is_terminal, dist_to_start_terminal, value)\n    \n    return final_value.unsqueeze(-1)", "stats": {"mse": 2.6636251258544923, "rmse": 1.6320616182774756, "mse_tsp20": 2.6636251258544923, "rmse_tsp20": 1.6320616182774756, "mse_tsp50": 1.59096461484375, "rmse_tsp50": 1.2613344579625778, "mse_tsp100": 1.3190233102539062, "rmse_tsp100": 1.1484874009992039, "mse_worst": 2.6636251258544923, "rmse_worst": 1.6320616182774756}, "stats_text": "mse=2.66363; rmse=1.63206; mse_tsp100=1.31902; mse_tsp20=2.66363; mse_tsp50=1.59096; mse_worst=2.66363; rmse_tsp100=1.14849; rmse_tsp20=1.63206; rmse_tsp50=1.26133; rmse_worst=1.63206"}
{"score": 0.14442194401455405, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The algorithm estimates the remaining tour length by multiplying the number of unvisited nodes by the average minimum distance from each unvisited node to any other unvisited node.", "code_hash": "948da801474913ef9ed2db71f330b186f78363384b494b85e41c1da0b92ac1a8", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The algorithm estimates the remaining tour length by multiplying the number of unvisited nodes by the average minimum distance from each unvisited node to any other unvisited node.}\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    n_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # For terminal states, the future cost is zero.\n    is_not_terminal = n_unvisited > 1\n    if not is_not_terminal.any():\n        return torch.zeros(dist_matrix.size(0), 1, device=dist_matrix.device)\n\n    # A large value to mask out irrelevant distances\n    large_value = dist_matrix.max() * 2 + 1 if dist_matrix.numel() > 0 else 1e9\n\n    # Create a temporary distance matrix where distances to/from visited nodes are masked\n    # [B, N, N]\n    temp_dist_matrix = dist_matrix.clone()\n    # Mask rows and columns corresponding to visited nodes\n    visited_mask = ~unvisited_mask\n    temp_dist_matrix[visited_mask, :] = large_value\n    temp_dist_matrix[:, visited_mask] = large_value\n    # Mask self-loops\n    temp_dist_matrix.diagonal(dim1=-2, dim2=-1).fill_(large_value)\n\n    # Find the minimum distance from each unvisited node to another unvisited node\n    # [B, N]\n    min_dists, _ = temp_dist_matrix.min(dim=2)\n\n    # Set distances from visited nodes to 0 so they don't affect the sum\n    min_dists.masked_fill_(visited_mask, 0)\n\n    # Calculate the average of these minimum distances\n    # Use a safe divisor to avoid division by zero for terminal states\n    safe_n_unvisited = torch.where(n_unvisited > 0, n_unvisited, torch.ones_like(n_unvisited))\n    # [B]\n    avg_min_dist = min_dists.sum(dim=1) / safe_n_unvisited\n\n    # Estimate the remaining tour length\n    # [B]\n    remaining_tour_length = n_unvisited * avg_min_dist\n\n    # Ensure terminal states have zero value\n    value = torch.where(is_not_terminal, remaining_tour_length, torch.tensor(0.0, device=dist_matrix.device))\n\n    return value.unsqueeze(-1)", "stats": {"mse": 1.8778033940429688, "rmse": 1.3703296661909385, "mse_tsp20": 1.8778033940429688, "rmse_tsp20": 1.3703296661909385, "mse_tsp50": 3.856727740234375, "rmse_tsp50": 1.9638553256883193, "mse_tsp100": 6.9241555140625, "rmse_tsp100": 2.6313790137611304, "mse_worst": 6.9241555140625, "rmse_worst": 2.6313790137611304}, "stats_text": "mse=1.8778; rmse=1.37033; mse_tsp100=6.92416; mse_tsp20=1.8778; mse_tsp50=3.85673; mse_worst=6.92416; rmse_tsp100=2.63138; rmse_tsp20=1.37033; rmse_tsp50=1.96386; rmse_worst=2.63138"}
{"score": 0.11230624864292459, "gamma": -0.1, "algorithm": "Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.", "code_hash": "0e7601ed649dfde68fc9175671d4df815cf1f6e8088ee79de00b3b2d9f6dd931", "code": "# THOUGHT: {Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on the geometric properties of unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes using the area of their convex hull.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n    This combines a geometric heuristic for the bulk of the path with connection costs.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n\n    # 1. Approximate sub-tour length using convex hull area of unvisited nodes\n    # A heuristic for tour length is related to the square root of the area of the convex hull.\n    # We use a simplified proxy: the area of the bounding box of unvisited nodes.\n\n    # Mask coordinates of visited nodes to exclude them from min/max calculations\n    # [B, N, 2]\n    masked_coords = coords.clone()\n    # Use a large value for visited nodes so they don't affect min, and a small value for max\n    large_val = torch.finfo(coords.dtype).max\n    small_val = torch.finfo(coords.dtype).min\n    # [B, N, 1]\n    unvisited_mask_exp = unvisited_mask.unsqueeze(-1)\n    masked_coords.masked_fill_(~unvisited_mask_exp, large_val)\n    min_coords, _ = torch.min(masked_coords, dim=1)  # [B, 2]\n\n    masked_coords = coords.clone()\n    masked_coords.masked_fill_(~unvisited_mask_exp, small_val)\n    max_coords, _ = torch.max(masked_coords, dim=1)  # [B, 2]\n\n    # Calculate width and height of the bounding box\n    # [B, 2]\n    span = max_coords - min_coords\n    # Clamp to avoid negative span if only one node is left\n    span = torch.clamp(span, min=0.0)\n    # [B]\n    area = span[:, 0] * span[:, 1]\n    # Heuristic for tour length: k * sqrt(Area * num_unvisited), k is an empirical factor\n    # For a unit square with N points, E[tour_len] ~ beta * sqrt(N), and Area=1.\n    # We use a simplified form: sqrt(Area) as a proxy for the spatial scale.\n    # The sum of two sides of the bounding box is a reasonable perimeter proxy.\n    subtour_cost = span[:, 0] + span[:, 1]\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, torch.finfo(dist_from_current.dtype).max)\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop)\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, torch.finfo(dist_from_start.dtype).max)\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Combine the components\n    # [B]\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n    \n    # Handle edge case where only one unvisited node remains\n    # The cost is just from current -> last_unvisited -> start\n    is_last_step = (num_unvisited.squeeze(-1) == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step]\n\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix[is_last_step, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix[is_last_step, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step] = last_step_cost\n\n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set if num_unvisited=0) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.9090601949462891, "rmse": 0.9534464824762264, "mse_tsp20": 0.9090601949462891, "rmse_tsp20": 0.9534464824762264, "mse_tsp50": 3.432229481640625, "rmse_tsp50": 1.852627723435182, "mse_tsp100": 8.904224048828125, "rmse_tsp100": 2.9839946462465585, "mse_worst": 8.904224048828125, "rmse_worst": 2.9839946462465585}, "stats_text": "mse=0.90906; rmse=0.953446; mse_tsp100=8.90422; mse_tsp20=0.90906; mse_tsp50=3.43223; mse_worst=8.90422; rmse_tsp100=2.98399; rmse_tsp20=0.953446; rmse_tsp50=1.85263; rmse_worst=2.98399"}
{"score": 3.4209696471518978, "gamma": -0.1, "algorithm": "Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.", "code_hash": "d5014fe6247751116f6de4174accdec9f7c2eafdcfcbe2f724c5ad25941cb364", "code": "# THOUGHT: {Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length using a Minimum Spanning Tree (MST) based heuristic.\n    The cost is the sum of three components:\n    1. The cost of the MST of the subgraph formed by the unvisited nodes. This provides a\n       tight lower bound on the optimal sub-tour length for these nodes.\n    2. The minimum cost to connect the current node to the set of unvisited nodes.\n    3. The minimum cost to connect the start node to the set of unvisited nodes,\n       which is necessary for closing the tour.\n    \n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n    \n    # 1. Calculate the cost of the MST on the unvisited nodes.\n    # Prim's algorithm for dense graphs.\n    # We will compute this only for batches where there are unvisited nodes.\n    # [B, N]\n    min_cost = torch.full((B, N), float('inf'), device=device)\n    # [B, N]\n    visited_in_mst = torch.zeros_like(unvisited_mask)\n    # [B]\n    mst_cost = torch.zeros(B, device=device)\n    \n    # Initialize Prim's: pick the first unvisited node as the starting point for the MST.\n    # Find the index of the first 'True' in unvisited_mask for each batch item.\n    first_unvisited_idx = torch.argmax(unvisited_mask.int(), dim=1)\n    \n    # Set the min_cost for the starting node of the MST to 0.\n    # This ensures it's the first one picked.\n    min_cost.scatter_(1, first_unvisited_idx.unsqueeze(1), 0)\n    \n    # Mask min_cost for nodes that are already visited in the main tour.\n    min_cost.masked_fill_(~unvisited_mask, float('inf'))\n\n    # Prim's algorithm loop executed in a parallelized way over N-1 steps.\n    # This is a fixed-iteration loop, avoiding dynamic Python loops.\n    for _ in range(N):\n        # Find the node `u` with the minimum cost that is unvisited in the MST.\n        # [B, 1]\n        u_idx = torch.argmin(min_cost, dim=1, keepdim=True)\n        # [B]\n        u_cost = torch.gather(min_cost, 1, u_idx).squeeze(1)\n        \n        # Add its cost to the total MST cost, handling inf for disconnected components.\n        mst_cost += torch.where(u_cost == float('inf'), 0, u_cost)\n        \n        # Mark `u` as visited in the MST and remove it from consideration.\n        visited_in_mst.scatter_(1, u_idx, True)\n        min_cost.scatter_(1, u_idx, float('inf'))\n\n        # Update min_costs for neighbors of `u`.\n        # [B, N]\n        dist_from_u = torch.gather(dist_matrix, 1, u_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        \n        # Update only if the new path through `u` is shorter and the neighbor is unvisited in MST.\n        # We also need to ensure the neighbor is part of the unvisited set for the main tour.\n        update_mask = (dist_from_u < min_cost) & ~visited_in_mst & unvisited_mask\n        min_cost[update_mask] = dist_from_u[update_mask]\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    # Mask distances to already visited nodes.\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop).\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Total estimated cost\n    # For the case with only one unvisited node, MST cost is 0. The formula becomes\n    # dist(current -> last) + dist(start -> last), which is correct.\n    value = mst_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # For terminal states, future cost is 0.\n    value.masked_fill_(is_terminal, 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0.\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.18682559706115723, "rmse": 0.4322332669533399, "mse_tsp20": 0.18682559706115723, "rmse_tsp20": 0.4322332669533399, "mse_tsp50": 0.19572340977783204, "rmse_tsp50": 0.4424063853266949, "mse_tsp100": 0.2923147829833984, "rmse_tsp100": 0.5406614310114958, "mse_worst": 0.2923147829833984, "rmse_worst": 0.5406614310114958}, "stats_text": "mse=0.186826; rmse=0.432233; mse_tsp100=0.292315; mse_tsp20=0.186826; mse_tsp50=0.195723; mse_worst=0.292315; rmse_tsp100=0.540661; rmse_tsp20=0.432233; rmse_tsp50=0.442406; rmse_worst=0.540661"}
{"score": 3.406448250786877, "gamma": -0.1, "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.", "code_hash": "a509be98760cefdd1fed21f2974aece62623fff8e8b93600894306f7a87ee209", "code": "# THOUGHT: {Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for a TSP state.\n    The estimation is based on three components:\n    1. The cost of a Minimum Spanning Tree (MST) over all unvisited nodes.\n    2. The minimum cost to connect the current node to one of the unvisited nodes.\n    3. The minimum cost to connect the start node to one of the unvisited nodes.\n    This heuristic approximates the cost of visiting all remaining nodes and returning home.\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # 1. MST cost on unvisited nodes\n    # Create a subgraph distance matrix for unvisited nodes\n    # [B, N, N]\n    unvisited_dist = dist_matrix.clone()\n    # Mask rows and columns for visited nodes by setting distances to infinity\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n\n    # Prim's algorithm for MST cost\n    # [B]\n    num_unvisited = unvisited_mask.sum(dim=1)\n    # [B, N], init with large values\n    min_cost = torch.full_like(unvisited_mask, float('inf'), dtype=dist_matrix.dtype)\n    # [B, N], init with False\n    in_mst = torch.zeros_like(unvisited_mask, dtype=torch.bool)\n    # [B]\n    mst_cost = torch.zeros(B, device=dist_matrix.device)\n\n    # Find the first unvisited node to start Prim's algorithm\n    # [B], indices of first unvisited nodes\n    start_node_idx = torch.where(unvisited_mask.any(1), unvisited_mask.float().argmax(1), -1)\n\n    # Set the cost of the starting node to 0\n    # Use scatter for batched indexing\n    min_cost.scatter_(1, start_node_idx.unsqueeze(1).clamp(min=0), 0)\n\n    # Prim's algorithm loop (vectorized)\n    # This loop runs N times, which is more than necessary but avoids dynamic loops\n    # and is safe because nodes already in MST won't be chosen again.\n    for _ in range(N):\n        # Select node `u` not in MST with the minimum cost\n        # [B, N]\n        cost_if_not_in_mst = min_cost.clone()\n        cost_if_not_in_mst.masked_fill_(in_mst, float('inf'))\n        # [B, 1]\n        u_cost, u_idx = cost_if_not_in_mst.min(dim=1, keepdim=True)\n\n        # Add cost to total and mark node as in MST\n        # This mask handles batches where no unvisited nodes are left (u_cost is inf)\n        is_finite_mask = torch.isfinite(u_cost.squeeze(-1))\n        mst_cost[is_finite_mask] += u_cost[is_finite_mask].squeeze(-1)\n        in_mst.scatter_(1, u_idx.clamp(min=0), True)\n\n        # Update min_cost for neighbors of `u`\n        # [B, 1, N]\n        dist_from_u = torch.gather(unvisited_dist, 1, u_idx.unsqueeze(-1).expand(-1, 1, N))\n        # [B, N]\n        dist_from_u_squeezed = dist_from_u.squeeze(1)\n        # [B, N]\n        min_cost = torch.min(min_cost, dist_from_u_squeezed)\n\n    # 2. Minimum cost from current node to any unvisited node\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_exp = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_exp)\n    # [B, N]\n    dist_from_current_squeezed = dist_from_current.squeeze(1)\n    dist_from_current_squeezed.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_to_unvisited = dist_from_current_squeezed.min(dim=1).values\n    min_to_unvisited.masked_fill_(num_unvisited == 0, 0) # If no unvisited, cost is 0\n\n    # 3. Minimum cost from start node to any unvisited node\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    first_node_exp = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_start = torch.gather(dist_matrix, 1, first_node_exp)\n    # [B, N]\n    dist_from_start_squeezed = dist_from_start.squeeze(1)\n    dist_from_start_squeezed.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_to_return = dist_from_start_squeezed.min(dim=1).values\n    min_to_return.masked_fill_(num_unvisited == 0, 0) # If no unvisited, cost is 0\n\n    # Total estimated cost\n    # Special case: if only one unvisited node, MST cost is 0. The cost is just to go there and back.\n    # [B]\n    is_one_unvisited = (num_unvisited == 1)\n    # [B, 1]\n    first_unvisited_idx = torch.where(is_one_unvisited, unvisited_mask.float().argmax(1).unsqueeze(-1), -1)\n    # [B, 1]\n    dist_curr_to_last = torch.gather(dist_from_current_squeezed, 1, first_unvisited_idx.clamp(min=0))\n    # [B, 1]\n    dist_last_to_start = torch.gather(dist_from_start_squeezed, 1, first_unvisited_idx.clamp(min=0))\n    # [B]\n    one_unvisited_cost = (dist_curr_to_last + dist_last_to_start).squeeze(-1)\n\n    # Combine costs\n    value = torch.where(is_one_unvisited, one_unvisited_cost, mst_cost + min_to_unvisited + min_to_return)\n\n    # Final state: tour complete, cost is 0\n    value.masked_fill_(num_unvisited == 0, 0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.19756102726745606, "rmse": 0.444478376602795, "mse_tsp20": 0.19756102726745606, "rmse_tsp20": 0.444478376602795, "mse_tsp50": 0.20184117449951172, "rmse_tsp50": 0.44926737528949473, "mse_tsp100": 0.29356089580078126, "rmse_tsp100": 0.5418126021059138, "mse_worst": 0.29356089580078126, "rmse_worst": 0.5418126021059138}, "stats_text": "mse=0.197561; rmse=0.444478; mse_tsp100=0.293561; mse_tsp20=0.197561; mse_tsp50=0.201841; mse_worst=0.293561; rmse_tsp100=0.541813; rmse_tsp20=0.444478; rmse_tsp50=0.449267; rmse_worst=0.541813"}
{"score": 3.3781803516081297, "gamma": 1.0, "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.", "code_hash": "54055c1f192cd4960761c781d6f2bc50f9e6fcc45c0de48c9b7057e7a6b4b015", "code": "# THOUGHT: {Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for TSP.\n    The estimate is composed of three parts:\n    1. The cost of a Minimum Spanning Tree (MST) over all unvisited nodes. This approximates\n       the shortest path needed to connect all remaining nodes.\n    2. The cost to connect the current node to the set of unvisited nodes (minimum edge).\n    3. The cost to connect the start node to the set of unvisited nodes (minimum edge).\n    This forms a lower bound on the remaining tour length, as it approximates a path\n    connecting the current node, all unvisited nodes, and returning to the start.\n\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # 1. Calculate the cost of the MST on the subgraph of unvisited nodes.\n    # We use a Prim's algorithm-like approach.\n    # Create a distance matrix for only the unvisited nodes.\n    # Mask rows and columns corresponding to visited nodes.\n    unvisited_dist_matrix = dist_matrix.clone()\n    # Mask rows for visited nodes\n    unvisited_dist_matrix.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n    # Mask columns for visited nodes\n    unvisited_dist_matrix.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n\n    # Prim's algorithm to find MST cost\n    # `in_mst` mask: nodes already included in the MST\n    in_mst = torch.zeros_like(unvisited_mask)\n    # `min_cost` array: min cost to connect each node to the MST\n    min_cost = torch.full((B, N), float('inf'), device=dist_matrix.device, dtype=dist_matrix.dtype)\n\n    # Find the first unvisited node to start Prim's algorithm\n    # This is guaranteed to exist if there are unvisited nodes.\n    first_unvisited_idx = torch.argmax(unvisited_mask.float(), dim=1, keepdim=True)\n\n    # Initialize: select the first unvisited node. Its cost to connect is 0.\n    min_cost.scatter_(1, first_unvisited_idx, 0)\n\n    # Iteratively add N-1 nodes to the MST (or until all unvisited are added)\n    # This loop is fixed to N, which is acceptable as it's not a Python loop.\n    mst_cost = torch.zeros(B, device=dist_matrix.device, dtype=dist_matrix.dtype)\n    for _ in range(N):\n        # Find the node not in MST with the minimum connection cost\n        cost_to_add = min_cost.clone()\n        cost_to_add.masked_fill_(in_mst, float('inf'))\n        # If no nodes are left to add (all unvisited are in mst), cost will be inf\n        min_val, new_node_idx = torch.min(cost_to_add, dim=1)\n\n        # Create a mask for valid additions (cost is not inf)\n        is_valid_addition = min_val != float('inf')\n        \n        # Add its cost to the total MST cost\n        mst_cost += min_val.where(is_valid_addition, torch.tensor(0.0, device=mst_cost.device))\n\n        # Add the new node to the MST\n        new_node_idx = new_node_idx.unsqueeze(1)\n        in_mst.scatter_(1, new_node_idx, True)\n\n        # Update min_cost for all nodes based on the newly added node\n        # Distances from the newly added node to all other nodes\n        dist_from_new = torch.gather(unvisited_dist_matrix, 1, new_node_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        min_cost = torch.min(min_cost, dist_from_new)\n\n    # 2. Find the minimum cost to connect the current node to any unvisited node.\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx)\n    # Mask distances to already visited nodes\n    dist_from_current.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # [B]\n    min_dist_from_current, _ = torch.min(dist_from_current.squeeze(1), dim=1)\n    # If no unvisited nodes, this cost is 0 (or inf, we handle it)\n    min_dist_from_current.masked_fill_(~unvisited_mask.any(dim=1), 0)\n\n    # 3. Find the minimum cost to connect the start node to any unvisited node.\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx)\n    # Mask distances to already visited nodes\n    dist_from_start.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start.squeeze(1), dim=1)\n    # If no unvisited nodes, this cost is 0\n    min_dist_from_start.masked_fill_(~unvisited_mask.any(dim=1), 0)\n    \n    # In terminal states, there are no unvisited nodes. The MST cost will be 0,\n    # and the connection costs will be 0. The only remaining cost is to return to start.\n    is_terminal = ~unvisited_mask.any(dim=1)\n    # [B]\n    dist_to_start_terminal = torch.gather(dist_matrix, 1, state.current_node_index().unsqueeze(1).unsqueeze(2)).squeeze()\n    dist_to_start_terminal = torch.gather(dist_to_start_terminal, 1, state.first_node_index().unsqueeze(1)).squeeze(1)\n\n    # Total estimated future cost\n    value = mst_cost + min_dist_from_current + min_dist_from_start\n    # For terminal states, the value is just the cost to return home\n    value = torch.where(is_terminal, dist_to_start_terminal, value)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.21352034575653075, "rmse": 0.4620826178904923, "mse_tsp20": 0.21352034575653075, "rmse_tsp20": 0.4620826178904923, "mse_tsp50": 0.20358135737304686, "rmse_tsp50": 0.4511999084364345, "mse_tsp100": 0.2960173513305664, "rmse_tsp100": 0.5440747663056672, "mse_worst": 0.2960173513305664, "rmse_worst": 0.5440747663056672}, "stats_text": "mse=0.21352; rmse=0.462083; mse_tsp100=0.296017; mse_tsp20=0.21352; mse_tsp50=0.203581; mse_worst=0.296017; rmse_tsp100=0.544075; rmse_tsp20=0.462083; rmse_tsp50=0.4512; rmse_worst=0.544075"}
{"score": 2.527232641964477, "gamma": 0.1, "algorithm": "Estimate the future tour length by summing the average distance from each unvisited node to its k-nearest unvisited neighbors, plus the cost to connect the current and start nodes to this unvisited cluster.", "code_hash": "dc604ef673fe9a7e63912216f576b19094fd380b26a2e04c3e2c3d74e5ee3b99", "code": "# THOUGHT: {Estimate the future tour length by summing the average distance from each unvisited node to its k-nearest unvisited neighbors, plus the cost to connect the current and start nodes to this unvisited cluster.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on local connectivity of unvisited nodes.\n    The value is the sum of three components:\n    1. For each unvisited node, calculate the average distance to its k-nearest\n       neighbors that are also unvisited. Summing these averages provides a\n       proxy for the sub-tour cost, similar to but simpler than MST.\n    2. The minimum cost to connect the current node to any unvisited node.\n    3. The minimum cost to connect the start node to any unvisited node,\n       approximating the cost of closing the tour.\n    This uses all_node_coords() to get the distance matrix.\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal states where no nodes are unvisited\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n\n    # 1. Estimate sub-tour cost for unvisited nodes using k-nearest neighbors.\n    # [B, N, N]\n    masked_dist = dist_matrix.clone()\n    # Mask connections to/from already visited nodes.\n    # [B, 1, N]\n    unvisited_mask_from = unvisited_mask.unsqueeze(1)\n    # [B, N, 1]\n    unvisited_mask_to = unvisited_mask.unsqueeze(2)\n    # Set distances to/from visited nodes to infinity.\n    masked_dist.masked_fill_(~unvisited_mask_from | ~unvisited_mask_to, float('inf'))\n    # Set diagonal to infinity to exclude self-loops.\n    masked_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n\n    # Sort distances to find k-nearest neighbors for each unvisited node.\n    # [B, N, N]\n    sorted_dist, _ = torch.sort(masked_dist, dim=2)\n\n    # Use a dynamic k, e.g., min(3, number of other unvisited nodes)\n    # This avoids issues when few nodes are left.\n    k = torch.min(torch.tensor(3, device=device), n_unvisited.clamp(min=1) - 1)\n    k = k.clamp(min=1) # Ensure k is at least 1 for non-terminal states.\n\n    # [B, N, k_max=3]\n    k_nearest_dists = sorted_dist[:, :, :3]\n\n    # Create a mask for averaging based on dynamic k.\n    # [B, 1, 3]\n    k_range = torch.arange(3, device=device).view(1, 1, 3)\n    # [B, N, 3]\n    k_mask = k_range < k.view(B, 1, 1)\n\n    # Calculate average distance to k-nearest unvisited neighbors.\n    # [B, N, 3]\n    k_nearest_dists.masked_fill_(~k_mask, 0.0)\n    # [B, N]\n    sum_k_dists = k_nearest_dists.sum(dim=2)\n    # [B, N]\n    avg_k_dist = sum_k_dists / k.view(B, 1).float()\n\n    # Sum these averages only for the unvisited nodes.\n    avg_k_dist.masked_fill_(~unvisited_mask, 0.0)\n    # [B]\n    subtour_cost_estimate = avg_k_dist.sum(dim=1)\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited = torch.min(dist_from_current, dim=1).values\n\n    # 3. Cost to connect the start node to the unvisited set.\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start = torch.min(dist_from_start, dim=1).values\n\n    # Total estimated cost\n    value = subtour_cost_estimate + min_dist_to_unvisited + min_dist_from_start\n\n    # For terminal states, future cost is 0.\n    value.masked_fill_(is_terminal, 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0.\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.39568972930908203, "rmse": 0.6290387343471641, "mse_tsp20": 0.39568972930908203, "rmse_tsp20": 0.6290387343471641, "mse_tsp50": 0.20146149614257813, "rmse_tsp50": 0.4488446236088588, "mse_tsp100": 0.17992913677978514, "rmse_tsp100": 0.42418054738493743, "mse_worst": 0.39568972930908203, "rmse_worst": 0.6290387343471641}, "stats_text": "mse=0.39569; rmse=0.629039; mse_tsp100=0.179929; mse_tsp20=0.39569; mse_tsp50=0.201461; mse_worst=0.39569; rmse_tsp100=0.424181; rmse_tsp20=0.629039; rmse_tsp50=0.448845; rmse_worst=0.629039"}
{"score": 2.423034464838014, "gamma": -0.1, "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.", "code_hash": "1b3b0812ca98a6aa6a8fb459b2e47dca3884b0f5419dcd0d7504221710b3f7b9", "code": "# THOUGHT: {Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length by approximating a path through unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes. For each unvisited node,\n       we find the distance to its two nearest neighbors among the other unvisited nodes.\n       The sum of these distances, averaged over all unvisited nodes, provides an estimate\n       of the local path cost. This is scaled by the number of unvisited nodes.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n    is_last_step = (num_unvisited == 1)\n    is_penultimate = (num_unvisited == 2)\n\n    # 1. Approximate sub-tour length through unvisited nodes\n    # Create a distance matrix only considering unvisited nodes.\n    # We set distances to/from visited nodes to infinity.\n    unvisited_dist = dist_matrix.clone()\n    inf = torch.finfo(dist_matrix.dtype).max\n    # Mask rows (from) and columns (to) corresponding to visited nodes\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), inf)\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), inf)\n\n    # For each unvisited node, find the distances to its two nearest unvisited neighbors.\n    # We use k=3 because the node itself is included with distance 0.\n    # [B, N, 3]\n    k = min(3, N) # handle N < 3 case\n    topk_dists, _ = torch.topk(unvisited_dist, k, dim=2, largest=False)\n\n    # The first value (k=0) is always 0 (distance to self), so we take k=1 and k=2.\n    # Sum of distances to two nearest neighbors for each node.\n    # If less than 3 unvisited nodes, some of these will be inf.\n    if k > 2:\n        two_nn_dist_sum = topk_dists[:, :, 1] + topk_dists[:, :, 2] # [B, N]\n    elif k > 1:\n        two_nn_dist_sum = topk_dists[:, :, 1] # [B, N]\n    else:\n        two_nn_dist_sum = torch.zeros_like(unvisited_mask, dtype=dist_matrix.dtype)\n\n\n    # Mask out the sums for visited nodes\n    two_nn_dist_sum.masked_fill_(~unvisited_mask, 0.0)\n\n    # The sum of these distances over all unvisited nodes, divided by 2 (since each edge is counted twice),\n    # approximates the MST length, which is a lower bound on the tour length.\n    # We use the sum directly as a heuristic.\n    subtour_cost = torch.sum(two_nn_dist_sum, dim=1) / 2.0\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    # [B]\n    min_dist_to_unvisited = torch.min(dist_from_current.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # 3. Cost to connect the start node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    # [B]\n    min_dist_from_start = torch.min(dist_from_start.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # Combine the components\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # Handle edge cases where subtour_cost is not well-defined\n    # If only two unvisited nodes, cost is current->A->B->start or current->B->A->start\n    if torch.any(is_penultimate):\n      # [B_pen, 2]\n      unvisited_indices = unvisited_mask[is_penultimate.squeeze(-1)].long().nonzero(as_tuple=False)[:, 1].view(-1, 2)\n      node_a_idx, node_b_idx = unvisited_indices[:, 0], unvisited_indices[:, 1]\n      \n      current_node_pen = state.current_node_index()[is_penultimate.squeeze(-1)]\n      start_node_pen = state.first_node_index()[is_penultimate.squeeze(-1)]\n      dist_matrix_pen = dist_matrix[is_penultimate.squeeze(-1)]\n\n      dist_curr_a = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_a_idx]\n      dist_curr_b = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_b_idx]\n      dist_a_b = dist_matrix_pen[torch.arange(len(node_a_idx)), node_a_idx, node_b_idx]\n      dist_a_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_a_idx, start_node_pen]\n      dist_b_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_b_idx, start_node_pen]\n      \n      cost1 = dist_curr_a + dist_a_b + dist_b_start\n      cost2 = dist_curr_b + dist_a_b + dist_a_start\n      penultimate_cost = torch.min(cost1, cost2)\n      value[is_penultimate.squeeze(-1)] = penultimate_cost\n\n    # If only one unvisited node, cost is current -> last -> start\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step.squeeze(-1)].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_from_current[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        dist_last_to_start = torch.gather(dist_from_start[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step.squeeze(-1)] = last_step_cost\n    \n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.2396109479522705, "rmse": 0.48950071292314834, "mse_tsp20": 0.2396109479522705, "rmse_tsp20": 0.48950071292314834, "mse_tsp50": 0.24980534642333985, "rmse_tsp50": 0.4998053085185669, "mse_tsp100": 0.41270564431152346, "rmse_tsp100": 0.6424217028646553, "mse_worst": 0.41270564431152346, "rmse_worst": 0.6424217028646553}, "stats_text": "mse=0.239611; rmse=0.489501; mse_tsp100=0.412706; mse_tsp20=0.239611; mse_tsp50=0.249805; mse_worst=0.412706; rmse_tsp100=0.642422; rmse_tsp20=0.489501; rmse_tsp50=0.499805; rmse_worst=0.642422"}
{"score": 0.7280720372806312, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.", "code_hash": "0cc2a43e13841f036b76914d86123d54dbc39c9e3e58d8eeb12c85a3cec64035", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.}\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node_idx = state.current_node_index()\n    # [B]\n    first_node_idx = state.first_node_index()\n    # [B]\n    batch_indices = torch.arange(dist_matrix.size(0), device=dist_matrix.device)\n\n    # Cost to return to the start node from the current node\n    # [B]\n    dist_to_start = dist_matrix[batch_indices, current_node_idx, first_node_idx]\n\n    # For each unvisited node, find its minimum connection cost to any other node.\n    # We set diagonal to infinity to avoid picking the zero-cost self-connection.\n    # [B, N, N]\n    dist_matrix_no_self = dist_matrix + torch.diag(torch.full((dist_matrix.size(1),), float('inf'), device=dist_matrix.device))\n    # [B, N]\n    min_dist_per_node, _ = torch.min(dist_matrix_no_self, dim=2)\n    \n    # Sum these minimum distances only for the unvisited nodes\n    # [B, N]\n    min_dist_per_node.masked_fill_(~unvisited_mask, 0)\n    # [B]\n    sum_min_dists = torch.sum(min_dist_per_node, dim=1)\n    \n    # The total estimated cost is the sum of minimum connection costs for unvisited nodes\n    # plus the cost to return to the start node from the current node.\n    # [B]\n    value = sum_min_dists + dist_to_start\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.4083288623046875, "rmse": 0.6390061520084822, "mse_tsp20": 0.4083288623046875, "rmse_tsp20": 0.6390061520084822, "mse_tsp50": 0.7378879370117187, "rmse_tsp50": 0.8590040378320225, "mse_tsp100": 1.3734904635742187, "rmse_tsp100": 1.1719600947021271, "mse_worst": 1.3734904635742187, "rmse_worst": 1.1719600947021271}, "stats_text": "mse=0.408329; rmse=0.639006; mse_tsp100=1.37349; mse_tsp20=0.408329; mse_tsp50=0.737888; mse_worst=1.37349; rmse_tsp100=1.17196; rmse_tsp20=0.639006; rmse_tsp50=0.859004; rmse_worst=1.17196"}
{"score": 0.5099670467875159, "gamma": 0.1, "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its nearest neighbor among the unvisited, current, and start nodes, plus the minimum cost to connect the current and start nodes into this set.", "code_hash": "c6aa769dbe2000ef83f865ad1a9c3185a3f1e99084e3c90a1ff0a0dfe96f6796", "code": "# THOUGHT: {Estimate the future tour length as the sum of distances from each unvisited node to its nearest neighbor among the unvisited, current, and start nodes, plus the minimum cost to connect the current and start nodes into this set.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length based on a nearest-neighbor heuristic within the unvisited set,\n    also considering connections to the current and start nodes.\n    The cost is the sum of three components:\n    1. For each unvisited node, find the minimum distance to any other unvisited node. Sum these minimum distances.\n       This approximates the cost of connecting all unvisited nodes together.\n    2. The minimum cost to connect the current node to the set of unvisited nodes.\n    3. The minimum cost to connect the start node to the set of unvisited nodes.\n    This differs from MST by using a simpler, more local connection cost approximation.\n    \n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2], used to get B and N\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n\n    # 1. Approximate the cost to connect all unvisited nodes.\n    # For each unvisited node, find the distance to its nearest neighbor *that is also unvisited*.\n    # [B, N, N]\n    unvisited_dist = dist_matrix.clone()\n    # Mask rows and columns corresponding to visited nodes.\n    # To find min distance from unvisited `i` to unvisited `j`, we need row `i` and col `j` to be valid.\n    unvisited_row_mask = unvisited_mask.unsqueeze(2).expand(-1, -1, N)\n    unvisited_col_mask = unvisited_mask.unsqueeze(1).expand(-1, N, -1)\n    # Set distances to/from visited nodes to infinity.\n    unvisited_dist.masked_fill_(~unvisited_row_mask, float('inf'))\n    unvisited_dist.masked_fill_(~unvisited_col_mask, float('inf'))\n    # Set diagonal to infinity to avoid picking the node itself.\n    unvisited_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n    \n    # [B, N], min distance for each node to its nearest unvisited neighbor.\n    min_dists_to_unvisited, _ = torch.min(unvisited_dist, dim=2)\n    \n    # Sum these minimum distances. This is our approximation of the sub-tour cost.\n    # We only sum over the unvisited nodes.\n    # Replace inf with 0 for visited nodes so they don't contribute to the sum.\n    min_dists_to_unvisited.masked_fill_(~unvisited_mask, 0.0)\n    # [B]\n    subtour_cost_approx = min_dists_to_unvisited.sum(dim=1)\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set.\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Total estimated cost\n    value = subtour_cost_approx + min_dist_to_unvisited + min_dist_from_start\n\n    # Handle terminal states and potential infs\n    value.masked_fill_(is_terminal, 0.0)\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.49089173599243163, "rmse": 0.7006366647503053, "mse_tsp20": 0.49089173599243163, "rmse_tsp20": 0.7006366647503053, "mse_tsp50": 1.0416986204589844, "rmse_tsp50": 1.0206363801369145, "mse_tsp100": 1.9609110163085937, "rmse_tsp100": 1.4003253251686172, "mse_worst": 1.9609110163085937, "rmse_worst": 1.4003253251686172}, "stats_text": "mse=0.490892; rmse=0.700637; mse_tsp100=1.96091; mse_tsp20=0.490892; mse_tsp50=1.0417; mse_worst=1.96091; rmse_tsp100=1.40033; rmse_tsp20=0.700637; rmse_tsp50=1.02064; rmse_worst=1.40033"}
{"score": 0.3754282050779197, "gamma": -0.1, "algorithm": "Estimate future tour length by finding the convex hull of unvisited nodes, adding the current and start nodes, and approximating the tour length of this reduced set.", "code_hash": "f9ca596711c451807e7294379e191f66401b10e6ea8572da9b04c1ab8062bfab", "code": "# THOUGHT: {Estimate future tour length by finding the convex hull of unvisited nodes, adding the current and start nodes, and approximating the tour length of this reduced set.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for TSP using a convex hull approximation.\n    1. Identify all unvisited nodes.\n    2. Find the convex hull of these unvisited nodes.\n    3. Add the current node and the start node to this set of hull points.\n    4. Calculate the perimeter of the convex hull of this combined set of points,\n       which serves as a lower-bound estimate for the path length needed to\n       connect these critical outer points.\n    5. Add the sum of minimum distances from each non-hull unvisited node to its\n       nearest node on the hull, approximating the cost to connect internal points.\n\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = coords.shape\n    device = coords.device\n    dtype = coords.dtype\n\n    # Handle terminal states: future cost is distance from current to start\n    is_terminal = ~unvisited_mask.any(dim=1)\n    dist_matrix = state.distance_matrix()\n    current_idx = state.current_node_index()\n    start_idx = state.first_node_index()\n    # Using gather for robust indexing\n    dist_to_start_terminal = torch.gather(dist_matrix, 1, current_idx.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_to_start_terminal = torch.gather(dist_to_start_terminal, 1, start_idx.view(B, 1)).squeeze(1)\n\n    # For non-terminal states\n    # Create a large coordinate value for visited nodes so they don't affect the hull\n    large_coord = coords.abs().max() + 1.0\n    unvisited_coords = coords.where(unvisited_mask.unsqueeze(-1), torch.full_like(coords, large_coord))\n\n    # Find the bottom-most point among unvisited nodes to start Graham scan\n    # In case of a tie, take the left-most one\n    y_coords = unvisited_coords[:, :, 1]\n    min_y, _ = y_coords.min(dim=1, keepdim=True)\n    is_min_y = (y_coords == min_y)\n    x_coords_at_min_y = torch.where(is_min_y, unvisited_coords[:, :, 0], torch.full_like(unvisited_coords[:, :, 0], float('inf')))\n    min_x_at_min_y, start_node_idx = x_coords_at_min_y.min(dim=1, keepdim=True)\n    \n    start_node_coords = torch.gather(coords, 1, start_node_idx.unsqueeze(-1).expand(-1, -1, 2))\n\n    # Calculate polar angles with respect to the start point\n    delta = unvisited_coords - start_node_coords\n    angles = torch.atan2(delta[:, :, 1], delta[:, :, 0])\n    # Mask out the start point itself from sorting\n    angles.scatter_(1, start_node_idx, float('inf'))\n    # Sort unvisited nodes by angle\n    sorted_indices = torch.argsort(angles, dim=1)\n    sorted_coords = torch.gather(coords, 1, sorted_indices.unsqueeze(-1).expand(-1, -1, 2))\n\n    # Build the convex hull using a batched Graham scan\n    hull_indices = torch.full((B, N + 1), -1, dtype=torch.long, device=device)\n    hull_indices[:, 0] = start_node_idx.squeeze(1)\n    hull_indices[:, 1] = sorted_indices[:, 0]\n    \n    # This part is tricky to fully vectorize without a loop, but we can approximate\n    # For simplicity and to avoid loops, we approximate the hull tour length\n    # by taking the sorted points. This is an overestimation but captures the shape.\n    # A true Graham scan is iterative. Let's use a simpler heuristic:\n    # Perimeter of the convex hull of a point set is a good lower bound.\n    # We will approximate this by creating a \"critical set\" of points.\n    \n    # 1. Critical points = current_node, start_node, and unvisited nodes\n    critical_mask = unvisited_mask.clone()\n    critical_mask.scatter_(1, current_idx.unsqueeze(1), True)\n    critical_mask.scatter_(1, start_idx.unsqueeze(1), True)\n\n    # 2. Find min/max x/y coordinates among these critical points\n    masked_coords = coords.where(critical_mask.unsqueeze(-1), torch.full_like(coords, float('inf')))\n    neg_masked_coords = coords.where(critical_mask.unsqueeze(-1), torch.full_like(coords, float('-inf')))\n    \n    min_x, _ = masked_coords[:, :, 0].min(dim=1)\n    max_x, _ = neg_masked_coords[:, :, 0].max(dim=1)\n    min_y, _ = masked_coords[:, :, 1].min(dim=1)\n    max_y, _ = neg_masked_coords[:, :, 1].max(dim=1)\n\n    # 3. Estimate perimeter of the bounding box as a proxy for hull perimeter\n    # This is a simple, permutation-invariant lower bound.\n    perimeter_approx = 2 * ((max_x - min_x) + (max_y - min_y))\n    # Replace inf with 0 for cases with no unvisited nodes\n    perimeter_approx = torch.nan_to_num(perimeter_approx, nan=0.0, posinf=0.0, neginf=0.0)\n\n    # 4. For unvisited nodes not on the \"bounding box\", add cost to connect to the closest point\n    # on the bounding box. We approximate this with min distance to any other unvisited node.\n    unvisited_dist = dist_matrix.clone()\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # Set diagonal to infinity to find nearest *other* unvisited node\n    unvisited_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n    \n    min_dists, _ = unvisited_dist.min(dim=2)\n    # Only sum costs for unvisited nodes\n    min_dists.masked_fill_(~unvisited_mask, 0)\n    \n    internal_cost = min_dists.sum(dim=1) * 0.5 # Each edge is counted twice, so halve it.\n\n    value = perimeter_approx + internal_cost\n    \n    # Combine terminal and non-terminal values\n    final_value = torch.where(is_terminal, dist_to_start_terminal, value)\n    \n    return final_value.unsqueeze(-1)", "stats": {"mse": 2.6636251258544923, "rmse": 1.6320616182774756, "mse_tsp20": 2.6636251258544923, "rmse_tsp20": 1.6320616182774756, "mse_tsp50": 1.59096461484375, "rmse_tsp50": 1.2613344579625778, "mse_tsp100": 1.3190233102539062, "rmse_tsp100": 1.1484874009992039, "mse_worst": 2.6636251258544923, "rmse_worst": 1.6320616182774756}, "stats_text": "mse=2.66363; rmse=1.63206; mse_tsp100=1.31902; mse_tsp20=2.66363; mse_tsp50=1.59096; mse_worst=2.66363; rmse_tsp100=1.14849; rmse_tsp20=1.63206; rmse_tsp50=1.26133; rmse_worst=1.63206"}
{"score": 0.14442194401455405, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The algorithm estimates the remaining tour length by multiplying the number of unvisited nodes by the average minimum distance from each unvisited node to any other unvisited node.", "code_hash": "948da801474913ef9ed2db71f330b186f78363384b494b85e41c1da0b92ac1a8", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The algorithm estimates the remaining tour length by multiplying the number of unvisited nodes by the average minimum distance from each unvisited node to any other unvisited node.}\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    n_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # For terminal states, the future cost is zero.\n    is_not_terminal = n_unvisited > 1\n    if not is_not_terminal.any():\n        return torch.zeros(dist_matrix.size(0), 1, device=dist_matrix.device)\n\n    # A large value to mask out irrelevant distances\n    large_value = dist_matrix.max() * 2 + 1 if dist_matrix.numel() > 0 else 1e9\n\n    # Create a temporary distance matrix where distances to/from visited nodes are masked\n    # [B, N, N]\n    temp_dist_matrix = dist_matrix.clone()\n    # Mask rows and columns corresponding to visited nodes\n    visited_mask = ~unvisited_mask\n    temp_dist_matrix[visited_mask, :] = large_value\n    temp_dist_matrix[:, visited_mask] = large_value\n    # Mask self-loops\n    temp_dist_matrix.diagonal(dim1=-2, dim2=-1).fill_(large_value)\n\n    # Find the minimum distance from each unvisited node to another unvisited node\n    # [B, N]\n    min_dists, _ = temp_dist_matrix.min(dim=2)\n\n    # Set distances from visited nodes to 0 so they don't affect the sum\n    min_dists.masked_fill_(visited_mask, 0)\n\n    # Calculate the average of these minimum distances\n    # Use a safe divisor to avoid division by zero for terminal states\n    safe_n_unvisited = torch.where(n_unvisited > 0, n_unvisited, torch.ones_like(n_unvisited))\n    # [B]\n    avg_min_dist = min_dists.sum(dim=1) / safe_n_unvisited\n\n    # Estimate the remaining tour length\n    # [B]\n    remaining_tour_length = n_unvisited * avg_min_dist\n\n    # Ensure terminal states have zero value\n    value = torch.where(is_not_terminal, remaining_tour_length, torch.tensor(0.0, device=dist_matrix.device))\n\n    return value.unsqueeze(-1)", "stats": {"mse": 1.8778033940429688, "rmse": 1.3703296661909385, "mse_tsp20": 1.8778033940429688, "rmse_tsp20": 1.3703296661909385, "mse_tsp50": 3.856727740234375, "rmse_tsp50": 1.9638553256883193, "mse_tsp100": 6.9241555140625, "rmse_tsp100": 2.6313790137611304, "mse_worst": 6.9241555140625, "rmse_worst": 2.6313790137611304}, "stats_text": "mse=1.8778; rmse=1.37033; mse_tsp100=6.92416; mse_tsp20=1.8778; mse_tsp50=3.85673; mse_worst=6.92416; rmse_tsp100=2.63138; rmse_tsp20=1.37033; rmse_tsp50=1.96386; rmse_worst=2.63138"}
{"score": 0.11230624864292459, "gamma": -0.1, "algorithm": "Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.", "code_hash": "0e7601ed649dfde68fc9175671d4df815cf1f6e8088ee79de00b3b2d9f6dd931", "code": "# THOUGHT: {Estimate the future tour length by calculating the area of the convex hull of unvisited nodes and adding the cost to connect the current node and the starting node to this hull.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on the geometric properties of unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes using the area of their convex hull.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n    This combines a geometric heuristic for the bulk of the path with connection costs.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n\n    # 1. Approximate sub-tour length using convex hull area of unvisited nodes\n    # A heuristic for tour length is related to the square root of the area of the convex hull.\n    # We use a simplified proxy: the area of the bounding box of unvisited nodes.\n\n    # Mask coordinates of visited nodes to exclude them from min/max calculations\n    # [B, N, 2]\n    masked_coords = coords.clone()\n    # Use a large value for visited nodes so they don't affect min, and a small value for max\n    large_val = torch.finfo(coords.dtype).max\n    small_val = torch.finfo(coords.dtype).min\n    # [B, N, 1]\n    unvisited_mask_exp = unvisited_mask.unsqueeze(-1)\n    masked_coords.masked_fill_(~unvisited_mask_exp, large_val)\n    min_coords, _ = torch.min(masked_coords, dim=1)  # [B, 2]\n\n    masked_coords = coords.clone()\n    masked_coords.masked_fill_(~unvisited_mask_exp, small_val)\n    max_coords, _ = torch.max(masked_coords, dim=1)  # [B, 2]\n\n    # Calculate width and height of the bounding box\n    # [B, 2]\n    span = max_coords - min_coords\n    # Clamp to avoid negative span if only one node is left\n    span = torch.clamp(span, min=0.0)\n    # [B]\n    area = span[:, 0] * span[:, 1]\n    # Heuristic for tour length: k * sqrt(Area * num_unvisited), k is an empirical factor\n    # For a unit square with N points, E[tour_len] ~ beta * sqrt(N), and Area=1.\n    # We use a simplified form: sqrt(Area) as a proxy for the spatial scale.\n    # The sum of two sides of the bounding box is a reasonable perimeter proxy.\n    subtour_cost = span[:, 0] + span[:, 1]\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, torch.finfo(dist_from_current.dtype).max)\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop)\n    # [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, torch.finfo(dist_from_start.dtype).max)\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Combine the components\n    # [B]\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n    \n    # Handle edge case where only one unvisited node remains\n    # The cost is just from current -> last_unvisited -> start\n    is_last_step = (num_unvisited.squeeze(-1) == 1)\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        current_node_last = state.current_node_index()[is_last_step]\n        # [B_last]\n        start_node_last = state.first_node_index()[is_last_step]\n\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_matrix[is_last_step, current_node_last], 1, last_unvisited_idx).squeeze(-1)\n        # [B_last]\n        dist_last_to_start = torch.gather(dist_matrix[is_last_step, start_node_last], 1, last_unvisited_idx).squeeze(-1)\n        \n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step] = last_step_cost\n\n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set if num_unvisited=0) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.9090601949462891, "rmse": 0.9534464824762264, "mse_tsp20": 0.9090601949462891, "rmse_tsp20": 0.9534464824762264, "mse_tsp50": 3.432229481640625, "rmse_tsp50": 1.852627723435182, "mse_tsp100": 8.904224048828125, "rmse_tsp100": 2.9839946462465585, "mse_worst": 8.904224048828125, "rmse_worst": 2.9839946462465585}, "stats_text": "mse=0.90906; rmse=0.953446; mse_tsp100=8.90422; mse_tsp20=0.90906; mse_tsp50=3.43223; mse_worst=8.90422; rmse_tsp100=2.98399; rmse_tsp20=0.953446; rmse_tsp50=1.85263; rmse_worst=2.98399"}
{"score": 3.4209696471518978, "gamma": -0.1, "algorithm": "Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.", "code_hash": "d5014fe6247751116f6de4174accdec9f7c2eafdcfcbe2f724c5ad25941cb364", "code": "# THOUGHT: {Estimate the future tour length by summing the MST cost of the unvisited nodes, the cost to connect the current node to this MST, and the cost to connect the start node to this MST for the return trip.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length using a Minimum Spanning Tree (MST) based heuristic.\n    The cost is the sum of three components:\n    1. The cost of the MST of the subgraph formed by the unvisited nodes. This provides a\n       tight lower bound on the optimal sub-tour length for these nodes.\n    2. The minimum cost to connect the current node to the set of unvisited nodes.\n    3. The minimum cost to connect the start node to the set of unvisited nodes,\n       which is necessary for closing the tour.\n    \n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n    \n    # 1. Calculate the cost of the MST on the unvisited nodes.\n    # Prim's algorithm for dense graphs.\n    # We will compute this only for batches where there are unvisited nodes.\n    # [B, N]\n    min_cost = torch.full((B, N), float('inf'), device=device)\n    # [B, N]\n    visited_in_mst = torch.zeros_like(unvisited_mask)\n    # [B]\n    mst_cost = torch.zeros(B, device=device)\n    \n    # Initialize Prim's: pick the first unvisited node as the starting point for the MST.\n    # Find the index of the first 'True' in unvisited_mask for each batch item.\n    first_unvisited_idx = torch.argmax(unvisited_mask.int(), dim=1)\n    \n    # Set the min_cost for the starting node of the MST to 0.\n    # This ensures it's the first one picked.\n    min_cost.scatter_(1, first_unvisited_idx.unsqueeze(1), 0)\n    \n    # Mask min_cost for nodes that are already visited in the main tour.\n    min_cost.masked_fill_(~unvisited_mask, float('inf'))\n\n    # Prim's algorithm loop executed in a parallelized way over N-1 steps.\n    # This is a fixed-iteration loop, avoiding dynamic Python loops.\n    for _ in range(N):\n        # Find the node `u` with the minimum cost that is unvisited in the MST.\n        # [B, 1]\n        u_idx = torch.argmin(min_cost, dim=1, keepdim=True)\n        # [B]\n        u_cost = torch.gather(min_cost, 1, u_idx).squeeze(1)\n        \n        # Add its cost to the total MST cost, handling inf for disconnected components.\n        mst_cost += torch.where(u_cost == float('inf'), 0, u_cost)\n        \n        # Mark `u` as visited in the MST and remove it from consideration.\n        visited_in_mst.scatter_(1, u_idx, True)\n        min_cost.scatter_(1, u_idx, float('inf'))\n\n        # Update min_costs for neighbors of `u`.\n        # [B, N]\n        dist_from_u = torch.gather(dist_matrix, 1, u_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        \n        # Update only if the new path through `u` is shorter and the neighbor is unvisited in MST.\n        # We also need to ensure the neighbor is part of the unvisited set for the main tour.\n        update_mask = (dist_from_u < min_cost) & ~visited_in_mst & unvisited_mask\n        min_cost[update_mask] = dist_from_u[update_mask]\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    # Mask distances to already visited nodes.\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set (for closing the loop).\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Total estimated cost\n    # For the case with only one unvisited node, MST cost is 0. The formula becomes\n    # dist(current -> last) + dist(start -> last), which is correct.\n    value = mst_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # For terminal states, future cost is 0.\n    value.masked_fill_(is_terminal, 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0.\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.18682559706115723, "rmse": 0.4322332669533399, "mse_tsp20": 0.18682559706115723, "rmse_tsp20": 0.4322332669533399, "mse_tsp50": 0.19572340977783204, "rmse_tsp50": 0.4424063853266949, "mse_tsp100": 0.2923147829833984, "rmse_tsp100": 0.5406614310114958, "mse_worst": 0.2923147829833984, "rmse_worst": 0.5406614310114958}, "stats_text": "mse=0.186826; rmse=0.432233; mse_tsp100=0.292315; mse_tsp20=0.186826; mse_tsp50=0.195723; mse_worst=0.292315; rmse_tsp100=0.540661; rmse_tsp20=0.432233; rmse_tsp50=0.442406; rmse_worst=0.540661"}
{"score": 3.406448250786877, "gamma": -0.1, "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.", "code_hash": "a509be98760cefdd1fed21f2974aece62623fff8e8b93600894306f7a87ee209", "code": "# THOUGHT: {Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current and start nodes to this MST.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for a TSP state.\n    The estimation is based on three components:\n    1. The cost of a Minimum Spanning Tree (MST) over all unvisited nodes.\n    2. The minimum cost to connect the current node to one of the unvisited nodes.\n    3. The minimum cost to connect the start node to one of the unvisited nodes.\n    This heuristic approximates the cost of visiting all remaining nodes and returning home.\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # 1. MST cost on unvisited nodes\n    # Create a subgraph distance matrix for unvisited nodes\n    # [B, N, N]\n    unvisited_dist = dist_matrix.clone()\n    # Mask rows and columns for visited nodes by setting distances to infinity\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n\n    # Prim's algorithm for MST cost\n    # [B]\n    num_unvisited = unvisited_mask.sum(dim=1)\n    # [B, N], init with large values\n    min_cost = torch.full_like(unvisited_mask, float('inf'), dtype=dist_matrix.dtype)\n    # [B, N], init with False\n    in_mst = torch.zeros_like(unvisited_mask, dtype=torch.bool)\n    # [B]\n    mst_cost = torch.zeros(B, device=dist_matrix.device)\n\n    # Find the first unvisited node to start Prim's algorithm\n    # [B], indices of first unvisited nodes\n    start_node_idx = torch.where(unvisited_mask.any(1), unvisited_mask.float().argmax(1), -1)\n\n    # Set the cost of the starting node to 0\n    # Use scatter for batched indexing\n    min_cost.scatter_(1, start_node_idx.unsqueeze(1).clamp(min=0), 0)\n\n    # Prim's algorithm loop (vectorized)\n    # This loop runs N times, which is more than necessary but avoids dynamic loops\n    # and is safe because nodes already in MST won't be chosen again.\n    for _ in range(N):\n        # Select node `u` not in MST with the minimum cost\n        # [B, N]\n        cost_if_not_in_mst = min_cost.clone()\n        cost_if_not_in_mst.masked_fill_(in_mst, float('inf'))\n        # [B, 1]\n        u_cost, u_idx = cost_if_not_in_mst.min(dim=1, keepdim=True)\n\n        # Add cost to total and mark node as in MST\n        # This mask handles batches where no unvisited nodes are left (u_cost is inf)\n        is_finite_mask = torch.isfinite(u_cost.squeeze(-1))\n        mst_cost[is_finite_mask] += u_cost[is_finite_mask].squeeze(-1)\n        in_mst.scatter_(1, u_idx.clamp(min=0), True)\n\n        # Update min_cost for neighbors of `u`\n        # [B, 1, N]\n        dist_from_u = torch.gather(unvisited_dist, 1, u_idx.unsqueeze(-1).expand(-1, 1, N))\n        # [B, N]\n        dist_from_u_squeezed = dist_from_u.squeeze(1)\n        # [B, N]\n        min_cost = torch.min(min_cost, dist_from_u_squeezed)\n\n    # 2. Minimum cost from current node to any unvisited node\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_exp = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_exp)\n    # [B, N]\n    dist_from_current_squeezed = dist_from_current.squeeze(1)\n    dist_from_current_squeezed.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_to_unvisited = dist_from_current_squeezed.min(dim=1).values\n    min_to_unvisited.masked_fill_(num_unvisited == 0, 0) # If no unvisited, cost is 0\n\n    # 3. Minimum cost from start node to any unvisited node\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    first_node_exp = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_start = torch.gather(dist_matrix, 1, first_node_exp)\n    # [B, N]\n    dist_from_start_squeezed = dist_from_start.squeeze(1)\n    dist_from_start_squeezed.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_to_return = dist_from_start_squeezed.min(dim=1).values\n    min_to_return.masked_fill_(num_unvisited == 0, 0) # If no unvisited, cost is 0\n\n    # Total estimated cost\n    # Special case: if only one unvisited node, MST cost is 0. The cost is just to go there and back.\n    # [B]\n    is_one_unvisited = (num_unvisited == 1)\n    # [B, 1]\n    first_unvisited_idx = torch.where(is_one_unvisited, unvisited_mask.float().argmax(1).unsqueeze(-1), -1)\n    # [B, 1]\n    dist_curr_to_last = torch.gather(dist_from_current_squeezed, 1, first_unvisited_idx.clamp(min=0))\n    # [B, 1]\n    dist_last_to_start = torch.gather(dist_from_start_squeezed, 1, first_unvisited_idx.clamp(min=0))\n    # [B]\n    one_unvisited_cost = (dist_curr_to_last + dist_last_to_start).squeeze(-1)\n\n    # Combine costs\n    value = torch.where(is_one_unvisited, one_unvisited_cost, mst_cost + min_to_unvisited + min_to_return)\n\n    # Final state: tour complete, cost is 0\n    value.masked_fill_(num_unvisited == 0, 0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.19756102726745606, "rmse": 0.444478376602795, "mse_tsp20": 0.19756102726745606, "rmse_tsp20": 0.444478376602795, "mse_tsp50": 0.20184117449951172, "rmse_tsp50": 0.44926737528949473, "mse_tsp100": 0.29356089580078126, "rmse_tsp100": 0.5418126021059138, "mse_worst": 0.29356089580078126, "rmse_worst": 0.5418126021059138}, "stats_text": "mse=0.197561; rmse=0.444478; mse_tsp100=0.293561; mse_tsp20=0.197561; mse_tsp50=0.201841; mse_worst=0.293561; rmse_tsp100=0.541813; rmse_tsp20=0.444478; rmse_tsp50=0.449267; rmse_worst=0.541813"}
{"score": 3.3781803516081297, "gamma": 1.0, "algorithm": "Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.", "code_hash": "54055c1f192cd4960761c781d6f2bc50f9e6fcc45c0de48c9b7057e7a6b4b015", "code": "# THOUGHT: {Estimate future tour length by summing the minimum spanning tree cost of unvisited nodes and adding the costs to connect the current node and start node to this MST.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for TSP.\n    The estimate is composed of three parts:\n    1. The cost of a Minimum Spanning Tree (MST) over all unvisited nodes. This approximates\n       the shortest path needed to connect all remaining nodes.\n    2. The cost to connect the current node to the set of unvisited nodes (minimum edge).\n    3. The cost to connect the start node to the set of unvisited nodes (minimum edge).\n    This forms a lower bound on the remaining tour length, as it approximates a path\n    connecting the current node, all unvisited nodes, and returning to the start.\n\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # 1. Calculate the cost of the MST on the subgraph of unvisited nodes.\n    # We use a Prim's algorithm-like approach.\n    # Create a distance matrix for only the unvisited nodes.\n    # Mask rows and columns corresponding to visited nodes.\n    unvisited_dist_matrix = dist_matrix.clone()\n    # Mask rows for visited nodes\n    unvisited_dist_matrix.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n    # Mask columns for visited nodes\n    unvisited_dist_matrix.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n\n    # Prim's algorithm to find MST cost\n    # `in_mst` mask: nodes already included in the MST\n    in_mst = torch.zeros_like(unvisited_mask)\n    # `min_cost` array: min cost to connect each node to the MST\n    min_cost = torch.full((B, N), float('inf'), device=dist_matrix.device, dtype=dist_matrix.dtype)\n\n    # Find the first unvisited node to start Prim's algorithm\n    # This is guaranteed to exist if there are unvisited nodes.\n    first_unvisited_idx = torch.argmax(unvisited_mask.float(), dim=1, keepdim=True)\n\n    # Initialize: select the first unvisited node. Its cost to connect is 0.\n    min_cost.scatter_(1, first_unvisited_idx, 0)\n\n    # Iteratively add N-1 nodes to the MST (or until all unvisited are added)\n    # This loop is fixed to N, which is acceptable as it's not a Python loop.\n    mst_cost = torch.zeros(B, device=dist_matrix.device, dtype=dist_matrix.dtype)\n    for _ in range(N):\n        # Find the node not in MST with the minimum connection cost\n        cost_to_add = min_cost.clone()\n        cost_to_add.masked_fill_(in_mst, float('inf'))\n        # If no nodes are left to add (all unvisited are in mst), cost will be inf\n        min_val, new_node_idx = torch.min(cost_to_add, dim=1)\n\n        # Create a mask for valid additions (cost is not inf)\n        is_valid_addition = min_val != float('inf')\n        \n        # Add its cost to the total MST cost\n        mst_cost += min_val.where(is_valid_addition, torch.tensor(0.0, device=mst_cost.device))\n\n        # Add the new node to the MST\n        new_node_idx = new_node_idx.unsqueeze(1)\n        in_mst.scatter_(1, new_node_idx, True)\n\n        # Update min_cost for all nodes based on the newly added node\n        # Distances from the newly added node to all other nodes\n        dist_from_new = torch.gather(unvisited_dist_matrix, 1, new_node_idx.unsqueeze(2).expand(-1, -1, N)).squeeze(1)\n        min_cost = torch.min(min_cost, dist_from_new)\n\n    # 2. Find the minimum cost to connect the current node to any unvisited node.\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx)\n    # Mask distances to already visited nodes\n    dist_from_current.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # [B]\n    min_dist_from_current, _ = torch.min(dist_from_current.squeeze(1), dim=1)\n    # If no unvisited nodes, this cost is 0 (or inf, we handle it)\n    min_dist_from_current.masked_fill_(~unvisited_mask.any(dim=1), 0)\n\n    # 3. Find the minimum cost to connect the start node to any unvisited node.\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, 1, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx)\n    # Mask distances to already visited nodes\n    dist_from_start.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start.squeeze(1), dim=1)\n    # If no unvisited nodes, this cost is 0\n    min_dist_from_start.masked_fill_(~unvisited_mask.any(dim=1), 0)\n    \n    # In terminal states, there are no unvisited nodes. The MST cost will be 0,\n    # and the connection costs will be 0. The only remaining cost is to return to start.\n    is_terminal = ~unvisited_mask.any(dim=1)\n    # [B]\n    dist_to_start_terminal = torch.gather(dist_matrix, 1, state.current_node_index().unsqueeze(1).unsqueeze(2)).squeeze()\n    dist_to_start_terminal = torch.gather(dist_to_start_terminal, 1, state.first_node_index().unsqueeze(1)).squeeze(1)\n\n    # Total estimated future cost\n    value = mst_cost + min_dist_from_current + min_dist_from_start\n    # For terminal states, the value is just the cost to return home\n    value = torch.where(is_terminal, dist_to_start_terminal, value)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.21352034575653075, "rmse": 0.4620826178904923, "mse_tsp20": 0.21352034575653075, "rmse_tsp20": 0.4620826178904923, "mse_tsp50": 0.20358135737304686, "rmse_tsp50": 0.4511999084364345, "mse_tsp100": 0.2960173513305664, "rmse_tsp100": 0.5440747663056672, "mse_worst": 0.2960173513305664, "rmse_worst": 0.5440747663056672}, "stats_text": "mse=0.21352; rmse=0.462083; mse_tsp100=0.296017; mse_tsp20=0.21352; mse_tsp50=0.203581; mse_worst=0.296017; rmse_tsp100=0.544075; rmse_tsp20=0.462083; rmse_tsp50=0.4512; rmse_worst=0.544075"}
{"score": 2.527232641964477, "gamma": 0.1, "algorithm": "Estimate the future tour length by summing the average distance from each unvisited node to its k-nearest unvisited neighbors, plus the cost to connect the current and start nodes to this unvisited cluster.", "code_hash": "dc604ef673fe9a7e63912216f576b19094fd380b26a2e04c3e2c3d74e5ee3b99", "code": "# THOUGHT: {Estimate the future tour length by summing the average distance from each unvisited node to its k-nearest unvisited neighbors, plus the cost to connect the current and start nodes to this unvisited cluster.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length based on local connectivity of unvisited nodes.\n    The value is the sum of three components:\n    1. For each unvisited node, calculate the average distance to its k-nearest\n       neighbors that are also unvisited. Summing these averages provides a\n       proxy for the sub-tour cost, similar to but simpler than MST.\n    2. The minimum cost to connect the current node to any unvisited node.\n    3. The minimum cost to connect the start node to any unvisited node,\n       approximating the cost of closing the tour.\n    This uses all_node_coords() to get the distance matrix.\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    # Handle terminal states where no nodes are unvisited\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n\n    # 1. Estimate sub-tour cost for unvisited nodes using k-nearest neighbors.\n    # [B, N, N]\n    masked_dist = dist_matrix.clone()\n    # Mask connections to/from already visited nodes.\n    # [B, 1, N]\n    unvisited_mask_from = unvisited_mask.unsqueeze(1)\n    # [B, N, 1]\n    unvisited_mask_to = unvisited_mask.unsqueeze(2)\n    # Set distances to/from visited nodes to infinity.\n    masked_dist.masked_fill_(~unvisited_mask_from | ~unvisited_mask_to, float('inf'))\n    # Set diagonal to infinity to exclude self-loops.\n    masked_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n\n    # Sort distances to find k-nearest neighbors for each unvisited node.\n    # [B, N, N]\n    sorted_dist, _ = torch.sort(masked_dist, dim=2)\n\n    # Use a dynamic k, e.g., min(3, number of other unvisited nodes)\n    # This avoids issues when few nodes are left.\n    k = torch.min(torch.tensor(3, device=device), n_unvisited.clamp(min=1) - 1)\n    k = k.clamp(min=1) # Ensure k is at least 1 for non-terminal states.\n\n    # [B, N, k_max=3]\n    k_nearest_dists = sorted_dist[:, :, :3]\n\n    # Create a mask for averaging based on dynamic k.\n    # [B, 1, 3]\n    k_range = torch.arange(3, device=device).view(1, 1, 3)\n    # [B, N, 3]\n    k_mask = k_range < k.view(B, 1, 1)\n\n    # Calculate average distance to k-nearest unvisited neighbors.\n    # [B, N, 3]\n    k_nearest_dists.masked_fill_(~k_mask, 0.0)\n    # [B, N]\n    sum_k_dists = k_nearest_dists.sum(dim=2)\n    # [B, N]\n    avg_k_dist = sum_k_dists / k.view(B, 1).float()\n\n    # Sum these averages only for the unvisited nodes.\n    avg_k_dist.masked_fill_(~unvisited_mask, 0.0)\n    # [B]\n    subtour_cost_estimate = avg_k_dist.sum(dim=1)\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited = torch.min(dist_from_current, dim=1).values\n\n    # 3. Cost to connect the start node to the unvisited set.\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start = torch.min(dist_from_start, dim=1).values\n\n    # Total estimated cost\n    value = subtour_cost_estimate + min_dist_to_unvisited + min_dist_from_start\n\n    # For terminal states, future cost is 0.\n    value.masked_fill_(is_terminal, 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0.\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.39568972930908203, "rmse": 0.6290387343471641, "mse_tsp20": 0.39568972930908203, "rmse_tsp20": 0.6290387343471641, "mse_tsp50": 0.20146149614257813, "rmse_tsp50": 0.4488446236088588, "mse_tsp100": 0.17992913677978514, "rmse_tsp100": 0.42418054738493743, "mse_worst": 0.39568972930908203, "rmse_worst": 0.6290387343471641}, "stats_text": "mse=0.39569; rmse=0.629039; mse_tsp100=0.179929; mse_tsp20=0.39569; mse_tsp50=0.201461; mse_worst=0.39569; rmse_tsp100=0.424181; rmse_tsp20=0.629039; rmse_tsp50=0.448845; rmse_worst=0.629039"}
{"score": 2.423034464838014, "gamma": -0.1, "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.", "code_hash": "1b3b0812ca98a6aa6a8fb459b2e47dca3884b0f5419dcd0d7504221710b3f7b9", "code": "# THOUGHT: {Estimate the future tour length as the sum of distances from each unvisited node to its two nearest unvisited neighbors, plus connection costs from the current and start nodes.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length by approximating a path through unvisited nodes.\n    The value is composed of three parts:\n    1. An approximation of the sub-tour length for unvisited nodes. For each unvisited node,\n       we find the distance to its two nearest neighbors among the other unvisited nodes.\n       The sum of these distances, averaged over all unvisited nodes, provides an estimate\n       of the local path cost. This is scaled by the number of unvisited nodes.\n    2. The minimum distance from the current node to any of the unvisited nodes.\n    3. The minimum distance from the start node to any of the unvisited nodes.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar tensor [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = dist_matrix.shape\n\n    # Handle terminal and near-terminal states\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True)  # [B, 1]\n    is_done = (num_unvisited == 0)\n    is_last_step = (num_unvisited == 1)\n    is_penultimate = (num_unvisited == 2)\n\n    # 1. Approximate sub-tour length through unvisited nodes\n    # Create a distance matrix only considering unvisited nodes.\n    # We set distances to/from visited nodes to infinity.\n    unvisited_dist = dist_matrix.clone()\n    inf = torch.finfo(dist_matrix.dtype).max\n    # Mask rows (from) and columns (to) corresponding to visited nodes\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), inf)\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), inf)\n\n    # For each unvisited node, find the distances to its two nearest unvisited neighbors.\n    # We use k=3 because the node itself is included with distance 0.\n    # [B, N, 3]\n    k = min(3, N) # handle N < 3 case\n    topk_dists, _ = torch.topk(unvisited_dist, k, dim=2, largest=False)\n\n    # The first value (k=0) is always 0 (distance to self), so we take k=1 and k=2.\n    # Sum of distances to two nearest neighbors for each node.\n    # If less than 3 unvisited nodes, some of these will be inf.\n    if k > 2:\n        two_nn_dist_sum = topk_dists[:, :, 1] + topk_dists[:, :, 2] # [B, N]\n    elif k > 1:\n        two_nn_dist_sum = topk_dists[:, :, 1] # [B, N]\n    else:\n        two_nn_dist_sum = torch.zeros_like(unvisited_mask, dtype=dist_matrix.dtype)\n\n\n    # Mask out the sums for visited nodes\n    two_nn_dist_sum.masked_fill_(~unvisited_mask, 0.0)\n\n    # The sum of these distances over all unvisited nodes, divided by 2 (since each edge is counted twice),\n    # approximates the MST length, which is a lower bound on the tour length.\n    # We use the sum directly as a heuristic.\n    subtour_cost = torch.sum(two_nn_dist_sum, dim=1) / 2.0\n\n    # 2. Cost to connect the current node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    current_node_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx).squeeze(1)\n    # [B]\n    min_dist_to_unvisited = torch.min(dist_from_current.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # 3. Cost to connect the start node to the unvisited set\n    # [B] -> [B, 1, 1] -> [B, 1, N]\n    start_node_idx = state.first_node_index().view(B, 1, 1).expand(-1, 1, N)\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node_idx).squeeze(1)\n    # [B]\n    min_dist_from_start = torch.min(dist_from_start.masked_fill(~unvisited_mask, inf), dim=1).values\n\n    # Combine the components\n    value = subtour_cost + min_dist_to_unvisited + min_dist_from_start\n\n    # Handle edge cases where subtour_cost is not well-defined\n    # If only two unvisited nodes, cost is current->A->B->start or current->B->A->start\n    if torch.any(is_penultimate):\n      # [B_pen, 2]\n      unvisited_indices = unvisited_mask[is_penultimate.squeeze(-1)].long().nonzero(as_tuple=False)[:, 1].view(-1, 2)\n      node_a_idx, node_b_idx = unvisited_indices[:, 0], unvisited_indices[:, 1]\n      \n      current_node_pen = state.current_node_index()[is_penultimate.squeeze(-1)]\n      start_node_pen = state.first_node_index()[is_penultimate.squeeze(-1)]\n      dist_matrix_pen = dist_matrix[is_penultimate.squeeze(-1)]\n\n      dist_curr_a = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_a_idx]\n      dist_curr_b = dist_matrix_pen[torch.arange(len(current_node_pen)), current_node_pen, node_b_idx]\n      dist_a_b = dist_matrix_pen[torch.arange(len(node_a_idx)), node_a_idx, node_b_idx]\n      dist_a_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_a_idx, start_node_pen]\n      dist_b_start = dist_matrix_pen[torch.arange(len(start_node_pen)), node_b_idx, start_node_pen]\n      \n      cost1 = dist_curr_a + dist_a_b + dist_b_start\n      cost2 = dist_curr_b + dist_a_b + dist_a_start\n      penultimate_cost = torch.min(cost1, cost2)\n      value[is_penultimate.squeeze(-1)] = penultimate_cost\n\n    # If only one unvisited node, cost is current -> last -> start\n    if torch.any(is_last_step):\n        # [B_last, 1]\n        last_unvisited_idx = unvisited_mask[is_last_step.squeeze(-1)].long().argmax(dim=1, keepdim=True)\n        # [B_last]\n        dist_curr_to_last = torch.gather(dist_from_current[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        dist_last_to_start = torch.gather(dist_from_start[is_last_step.squeeze(-1)], 1, last_unvisited_idx).squeeze(-1)\n        last_step_cost = dist_curr_to_last + dist_last_to_start\n        value[is_last_step.squeeze(-1)] = last_step_cost\n    \n    # If the tour is done, future cost is 0\n    value.masked_fill_(is_done.squeeze(-1), 0.0)\n    # Replace any remaining infs (e.g., from min over empty set) with 0\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.2396109479522705, "rmse": 0.48950071292314834, "mse_tsp20": 0.2396109479522705, "rmse_tsp20": 0.48950071292314834, "mse_tsp50": 0.24980534642333985, "rmse_tsp50": 0.4998053085185669, "mse_tsp100": 0.41270564431152346, "rmse_tsp100": 0.6424217028646553, "mse_worst": 0.41270564431152346, "rmse_worst": 0.6424217028646553}, "stats_text": "mse=0.239611; rmse=0.489501; mse_tsp100=0.412706; mse_tsp20=0.239611; mse_tsp50=0.249805; mse_worst=0.412706; rmse_tsp100=0.642422; rmse_tsp20=0.489501; rmse_tsp50=0.499805; rmse_worst=0.642422"}
{"score": 0.7280720372806312, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.", "code_hash": "0cc2a43e13841f036b76914d86123d54dbc39c9e3e58d8eeb12c85a3cec64035", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimate future tour length by summing the minimum connection cost for each unvisited node and adding the cost to return to the start.}\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node_idx = state.current_node_index()\n    # [B]\n    first_node_idx = state.first_node_index()\n    # [B]\n    batch_indices = torch.arange(dist_matrix.size(0), device=dist_matrix.device)\n\n    # Cost to return to the start node from the current node\n    # [B]\n    dist_to_start = dist_matrix[batch_indices, current_node_idx, first_node_idx]\n\n    # For each unvisited node, find its minimum connection cost to any other node.\n    # We set diagonal to infinity to avoid picking the zero-cost self-connection.\n    # [B, N, N]\n    dist_matrix_no_self = dist_matrix + torch.diag(torch.full((dist_matrix.size(1),), float('inf'), device=dist_matrix.device))\n    # [B, N]\n    min_dist_per_node, _ = torch.min(dist_matrix_no_self, dim=2)\n    \n    # Sum these minimum distances only for the unvisited nodes\n    # [B, N]\n    min_dist_per_node.masked_fill_(~unvisited_mask, 0)\n    # [B]\n    sum_min_dists = torch.sum(min_dist_per_node, dim=1)\n    \n    # The total estimated cost is the sum of minimum connection costs for unvisited nodes\n    # plus the cost to return to the start node from the current node.\n    # [B]\n    value = sum_min_dists + dist_to_start\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.4083288623046875, "rmse": 0.6390061520084822, "mse_tsp20": 0.4083288623046875, "rmse_tsp20": 0.6390061520084822, "mse_tsp50": 0.7378879370117187, "rmse_tsp50": 0.8590040378320225, "mse_tsp100": 1.3734904635742187, "rmse_tsp100": 1.1719600947021271, "mse_worst": 1.3734904635742187, "rmse_worst": 1.1719600947021271}, "stats_text": "mse=0.408329; rmse=0.639006; mse_tsp100=1.37349; mse_tsp20=0.408329; mse_tsp50=0.737888; mse_worst=1.37349; rmse_tsp100=1.17196; rmse_tsp20=0.639006; rmse_tsp50=0.859004; rmse_worst=1.17196"}
{"score": 0.5099670467875159, "gamma": 0.1, "algorithm": "Estimate the future tour length as the sum of distances from each unvisited node to its nearest neighbor among the unvisited, current, and start nodes, plus the minimum cost to connect the current and start nodes into this set.", "code_hash": "c6aa769dbe2000ef83f865ad1a9c3185a3f1e99084e3c90a1ff0a0dfe96f6796", "code": "# THOUGHT: {Estimate the future tour length as the sum of distances from each unvisited node to its nearest neighbor among the unvisited, current, and start nodes, plus the minimum cost to connect the current and start nodes into this set.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length based on a nearest-neighbor heuristic within the unvisited set,\n    also considering connections to the current and start nodes.\n    The cost is the sum of three components:\n    1. For each unvisited node, find the minimum distance to any other unvisited node. Sum these minimum distances.\n       This approximates the cost of connecting all unvisited nodes together.\n    2. The minimum cost to connect the current node to the set of unvisited nodes.\n    3. The minimum cost to connect the start node to the set of unvisited nodes.\n    This differs from MST by using a simpler, more local connection cost approximation.\n    \n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    start_node = state.first_node_index()\n    # [B, N, 2], used to get B and N\n    coords = state.all_node_coords()\n    B, N, _ = coords.shape\n\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n\n    # 1. Approximate the cost to connect all unvisited nodes.\n    # For each unvisited node, find the distance to its nearest neighbor *that is also unvisited*.\n    # [B, N, N]\n    unvisited_dist = dist_matrix.clone()\n    # Mask rows and columns corresponding to visited nodes.\n    # To find min distance from unvisited `i` to unvisited `j`, we need row `i` and col `j` to be valid.\n    unvisited_row_mask = unvisited_mask.unsqueeze(2).expand(-1, -1, N)\n    unvisited_col_mask = unvisited_mask.unsqueeze(1).expand(-1, N, -1)\n    # Set distances to/from visited nodes to infinity.\n    unvisited_dist.masked_fill_(~unvisited_row_mask, float('inf'))\n    unvisited_dist.masked_fill_(~unvisited_col_mask, float('inf'))\n    # Set diagonal to infinity to avoid picking the node itself.\n    unvisited_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n    \n    # [B, N], min distance for each node to its nearest unvisited neighbor.\n    min_dists_to_unvisited, _ = torch.min(unvisited_dist, dim=2)\n    \n    # Sum these minimum distances. This is our approximation of the sub-tour cost.\n    # We only sum over the unvisited nodes.\n    # Replace inf with 0 for visited nodes so they don't contribute to the sum.\n    min_dists_to_unvisited.masked_fill_(~unvisited_mask, 0.0)\n    # [B]\n    subtour_cost_approx = min_dists_to_unvisited.sum(dim=1)\n\n    # 2. Cost to connect the current node to the unvisited set.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    # 3. Cost to connect the start node to the unvisited set.\n    # [B, N]\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(-1, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    # [B]\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Total estimated cost\n    value = subtour_cost_approx + min_dist_to_unvisited + min_dist_from_start\n\n    # Handle terminal states and potential infs\n    value.masked_fill_(is_terminal, 0.0)\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.49089173599243163, "rmse": 0.7006366647503053, "mse_tsp20": 0.49089173599243163, "rmse_tsp20": 0.7006366647503053, "mse_tsp50": 1.0416986204589844, "rmse_tsp50": 1.0206363801369145, "mse_tsp100": 1.9609110163085937, "rmse_tsp100": 1.4003253251686172, "mse_worst": 1.9609110163085937, "rmse_worst": 1.4003253251686172}, "stats_text": "mse=0.490892; rmse=0.700637; mse_tsp100=1.96091; mse_tsp20=0.490892; mse_tsp50=1.0417; mse_worst=1.96091; rmse_tsp100=1.40033; rmse_tsp20=0.700637; rmse_tsp50=1.02064; rmse_worst=1.40033"}
{"score": 0.3754282050779197, "gamma": -0.1, "algorithm": "Estimate future tour length by finding the convex hull of unvisited nodes, adding the current and start nodes, and approximating the tour length of this reduced set.", "code_hash": "f9ca596711c451807e7294379e191f66401b10e6ea8572da9b04c1ab8062bfab", "code": "# THOUGHT: {Estimate future tour length by finding the convex hull of unvisited nodes, adding the current and start nodes, and approximating the tour length of this reduced set.}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for TSP using a convex hull approximation.\n    1. Identify all unvisited nodes.\n    2. Find the convex hull of these unvisited nodes.\n    3. Add the current node and the start node to this set of hull points.\n    4. Calculate the perimeter of the convex hull of this combined set of points,\n       which serves as a lower-bound estimate for the path length needed to\n       connect these critical outer points.\n    5. Add the sum of minimum distances from each non-hull unvisited node to its\n       nearest node on the hull, approximating the cost to connect internal points.\n\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = coords.shape\n    device = coords.device\n    dtype = coords.dtype\n\n    # Handle terminal states: future cost is distance from current to start\n    is_terminal = ~unvisited_mask.any(dim=1)\n    dist_matrix = state.distance_matrix()\n    current_idx = state.current_node_index()\n    start_idx = state.first_node_index()\n    # Using gather for robust indexing\n    dist_to_start_terminal = torch.gather(dist_matrix, 1, current_idx.view(B, 1, 1).expand(-1, 1, N)).squeeze(1)\n    dist_to_start_terminal = torch.gather(dist_to_start_terminal, 1, start_idx.view(B, 1)).squeeze(1)\n\n    # For non-terminal states\n    # Create a large coordinate value for visited nodes so they don't affect the hull\n    large_coord = coords.abs().max() + 1.0\n    unvisited_coords = coords.where(unvisited_mask.unsqueeze(-1), torch.full_like(coords, large_coord))\n\n    # Find the bottom-most point among unvisited nodes to start Graham scan\n    # In case of a tie, take the left-most one\n    y_coords = unvisited_coords[:, :, 1]\n    min_y, _ = y_coords.min(dim=1, keepdim=True)\n    is_min_y = (y_coords == min_y)\n    x_coords_at_min_y = torch.where(is_min_y, unvisited_coords[:, :, 0], torch.full_like(unvisited_coords[:, :, 0], float('inf')))\n    min_x_at_min_y, start_node_idx = x_coords_at_min_y.min(dim=1, keepdim=True)\n    \n    start_node_coords = torch.gather(coords, 1, start_node_idx.unsqueeze(-1).expand(-1, -1, 2))\n\n    # Calculate polar angles with respect to the start point\n    delta = unvisited_coords - start_node_coords\n    angles = torch.atan2(delta[:, :, 1], delta[:, :, 0])\n    # Mask out the start point itself from sorting\n    angles.scatter_(1, start_node_idx, float('inf'))\n    # Sort unvisited nodes by angle\n    sorted_indices = torch.argsort(angles, dim=1)\n    sorted_coords = torch.gather(coords, 1, sorted_indices.unsqueeze(-1).expand(-1, -1, 2))\n\n    # Build the convex hull using a batched Graham scan\n    hull_indices = torch.full((B, N + 1), -1, dtype=torch.long, device=device)\n    hull_indices[:, 0] = start_node_idx.squeeze(1)\n    hull_indices[:, 1] = sorted_indices[:, 0]\n    \n    # This part is tricky to fully vectorize without a loop, but we can approximate\n    # For simplicity and to avoid loops, we approximate the hull tour length\n    # by taking the sorted points. This is an overestimation but captures the shape.\n    # A true Graham scan is iterative. Let's use a simpler heuristic:\n    # Perimeter of the convex hull of a point set is a good lower bound.\n    # We will approximate this by creating a \"critical set\" of points.\n    \n    # 1. Critical points = current_node, start_node, and unvisited nodes\n    critical_mask = unvisited_mask.clone()\n    critical_mask.scatter_(1, current_idx.unsqueeze(1), True)\n    critical_mask.scatter_(1, start_idx.unsqueeze(1), True)\n\n    # 2. Find min/max x/y coordinates among these critical points\n    masked_coords = coords.where(critical_mask.unsqueeze(-1), torch.full_like(coords, float('inf')))\n    neg_masked_coords = coords.where(critical_mask.unsqueeze(-1), torch.full_like(coords, float('-inf')))\n    \n    min_x, _ = masked_coords[:, :, 0].min(dim=1)\n    max_x, _ = neg_masked_coords[:, :, 0].max(dim=1)\n    min_y, _ = masked_coords[:, :, 1].min(dim=1)\n    max_y, _ = neg_masked_coords[:, :, 1].max(dim=1)\n\n    # 3. Estimate perimeter of the bounding box as a proxy for hull perimeter\n    # This is a simple, permutation-invariant lower bound.\n    perimeter_approx = 2 * ((max_x - min_x) + (max_y - min_y))\n    # Replace inf with 0 for cases with no unvisited nodes\n    perimeter_approx = torch.nan_to_num(perimeter_approx, nan=0.0, posinf=0.0, neginf=0.0)\n\n    # 4. For unvisited nodes not on the \"bounding box\", add cost to connect to the closest point\n    # on the bounding box. We approximate this with min distance to any other unvisited node.\n    unvisited_dist = dist_matrix.clone()\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(2), float('inf'))\n    unvisited_dist.masked_fill_(~unvisited_mask.unsqueeze(1), float('inf'))\n    # Set diagonal to infinity to find nearest *other* unvisited node\n    unvisited_dist.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n    \n    min_dists, _ = unvisited_dist.min(dim=2)\n    # Only sum costs for unvisited nodes\n    min_dists.masked_fill_(~unvisited_mask, 0)\n    \n    internal_cost = min_dists.sum(dim=1) * 0.5 # Each edge is counted twice, so halve it.\n\n    value = perimeter_approx + internal_cost\n    \n    # Combine terminal and non-terminal values\n    final_value = torch.where(is_terminal, dist_to_start_terminal, value)\n    \n    return final_value.unsqueeze(-1)", "stats": {"mse": 2.6636251258544923, "rmse": 1.6320616182774756, "mse_tsp20": 2.6636251258544923, "rmse_tsp20": 1.6320616182774756, "mse_tsp50": 1.59096461484375, "rmse_tsp50": 1.2613344579625778, "mse_tsp100": 1.3190233102539062, "rmse_tsp100": 1.1484874009992039, "mse_worst": 2.6636251258544923, "rmse_worst": 1.6320616182774756}, "stats_text": "mse=2.66363; rmse=1.63206; mse_tsp100=1.31902; mse_tsp20=2.66363; mse_tsp50=1.59096; mse_worst=2.66363; rmse_tsp100=1.14849; rmse_tsp20=1.63206; rmse_tsp50=1.26133; rmse_worst=1.63206"}
{"score": 0.2543256500584503, "gamma": 0.1, "algorithm": "Estimate future tour length by calculating the convex hull area of unvisited nodes and scaling it by the average node density, adding costs to connect the current and start nodes to this hull.} def phi(state): \"\"\" Estimates future tour length using a convex hull-based geometric heuristic. The cost is the sum of three components: 1. An estimate of the sub-tour length for unvisited nodes, derived from the area of their convex hull. The intuition is that tour length scales with the square root of the area covered. This is scaled by node density. 2. The minimum cost to connect the current node to the convex hull. 3. The minimum cost to connect the start node to the convex hull, for the return trip. \"\"\" coords = state.all_node_coords() unvisited_mask = state.unvisited_mask() B, N, _ = coords.shape device = coords.device n_unvisited = unvisited_mask.sum(dim=1) is_terminal = (n_unvisited == 0) has_enough_nodes = (n_unvisited >= 3) # 1. Estimate sub-tour length for unvisited nodes using convex hull. # Create a copy of coords and mask out visited nodes for hull calculation. unvisited_coords = coords.clone() # Set visited nodes to a far-away point so they don't affect the hull. # A single point (e.g., origin) could cause issues if it's inside the hull. large_val = coords.abs().max() + 1.0 unvisited_coords.masked_fill_(~unvisited_mask.unsqueeze(-1), large_val) # Find the bottom-most, then left-most point to start Graham scan. # Using y-coord then x-coord as tie-breaker. sort_keys = torch.stack([unvisited_coords[..., 1], unvisited_coords[..., 0]], dim=-1) # A large value for masked nodes ensures they are sorted last. sort_keys.masked_fill_(~unvisited_mask.unsqueeze(-1), float('inf')) # Find the index of the start point for each batch item. start_pt_idx = torch.lexsort(dims=-1, keys=sort_keys.permute(2, 0, 1))[0] # Get coordinates of the start point. p0 = torch.gather(coords, 1, start_pt_idx.view(B, 1, 1).expand(-1, -1, 2)) # Calculate angles of all other points with respect to p0. # Subtract p0 to center the coordinate system. centered_coords = coords - p0 # Use atan2 for stable angle calculation. angles = torch.atan2(centered_coords[..., 1], centered_coords[..., 0]) # Mask out visited nodes and the start point itself. angles.masked_fill_(~unvisited_mask, float('inf')) angles.scatter_(1, start_pt_idx.unsqueeze(1), float('inf')) # Sort points by angle to get the hull vertices in order. # The sorted indices give the order of vertices in the convex hull. _, sorted_indices = torch.sort(angles, dim=1) # Gather the coordinates of the sorted unvisited points. sorted_unvisited_coords = torch.gather(coords, 1, sorted_indices.unsqueeze(-1).expand(-1, -1, 2)) # Prepend the starting point to form a closed polygon path. # Path: p0 -> sorted_p1 -> sorted_p2 ... -> p0 hull_path_coords = torch.cat([p0, sorted_unvisited_coords], dim=1) # Calculate polygon area using the shoelace formula. x, y = hull_path_coords[..., 0], hull_path_coords[..., 1] # This computes sum(x_i * y_{i+1} - x_{i+1", "code_hash": "b5692d3078bbaa95c8199d4acf4dfb8313a5b628da94d9fd8ac264f2af08cf33", "code": "# THOUGHT: {Estimate future tour length by calculating the convex hull area of unvisited nodes and scaling it by the average node density, adding costs to connect the current and start nodes to this hull.}\ndef phi(state):\n    \"\"\"\n    Estimates future tour length using a convex hull-based geometric heuristic.\n    The cost is the sum of three components:\n    1. An estimate of the sub-tour length for unvisited nodes, derived from the\n       area of their convex hull. The intuition is that tour length scales with\n       the square root of the area covered. This is scaled by node density.\n    2. The minimum cost to connect the current node to the convex hull.\n    3. The minimum cost to connect the start node to the convex hull, for the return trip.\n    \"\"\"\n    coords = state.all_node_coords()\n    unvisited_mask = state.unvisited_mask()\n    B, N, _ = coords.shape\n    device = coords.device\n\n    n_unvisited = unvisited_mask.sum(dim=1)\n    is_terminal = (n_unvisited == 0)\n    has_enough_nodes = (n_unvisited >= 3)\n\n    # 1. Estimate sub-tour length for unvisited nodes using convex hull.\n    # Create a copy of coords and mask out visited nodes for hull calculation.\n    unvisited_coords = coords.clone()\n    # Set visited nodes to a far-away point so they don't affect the hull.\n    # A single point (e.g., origin) could cause issues if it's inside the hull.\n    large_val = coords.abs().max() + 1.0\n    unvisited_coords.masked_fill_(~unvisited_mask.unsqueeze(-1), large_val)\n\n    # Find the bottom-most, then left-most point to start Graham scan.\n    # Using y-coord then x-coord as tie-breaker.\n    sort_keys = torch.stack([unvisited_coords[..., 1], unvisited_coords[..., 0]], dim=-1)\n    # A large value for masked nodes ensures they are sorted last.\n    sort_keys.masked_fill_(~unvisited_mask.unsqueeze(-1), float('inf'))\n    # Find the index of the start point for each batch item.\n    start_pt_idx = torch.lexsort(dims=-1, keys=sort_keys.permute(2, 0, 1))[0]\n\n    # Get coordinates of the start point.\n    p0 = torch.gather(coords, 1, start_pt_idx.view(B, 1, 1).expand(-1, -1, 2))\n\n    # Calculate angles of all other points with respect to p0.\n    # Subtract p0 to center the coordinate system.\n    centered_coords = coords - p0\n    # Use atan2 for stable angle calculation.\n    angles = torch.atan2(centered_coords[..., 1], centered_coords[..., 0])\n    # Mask out visited nodes and the start point itself.\n    angles.masked_fill_(~unvisited_mask, float('inf'))\n    angles.scatter_(1, start_pt_idx.unsqueeze(1), float('inf'))\n\n    # Sort points by angle to get the hull vertices in order.\n    # The sorted indices give the order of vertices in the convex hull.\n    _, sorted_indices = torch.sort(angles, dim=1)\n\n    # Gather the coordinates of the sorted unvisited points.\n    sorted_unvisited_coords = torch.gather(coords, 1, sorted_indices.unsqueeze(-1).expand(-1, -1, 2))\n    # Prepend the starting point to form a closed polygon path.\n    # Path: p0 -> sorted_p1 -> sorted_p2 ... -> p0\n    hull_path_coords = torch.cat([p0, sorted_unvisited_coords], dim=1)\n\n    # Calculate polygon area using the shoelace formula.\n    x, y = hull_path_coords[..., 0], hull_path_coords[..., 1]\n    # This computes sum(x_i * y_{i+1} - x_{i+1} * y_i)\n    area = 0.5 * torch.abs(\n        torch.sum(x[:, :-1] * y[:, 1:] - x[:, 1:] * y[:, :-1], dim=1) +\n        (x[:, -1] * y[:, 0] - x[:, 0] * y[:, -1])\n    )\n\n    # Held's heuristic: length approx. C * sqrt(N * Area)\n    # We use a simplified version: sqrt(Area) * sqrt(N_unvisited)\n    # The constant factor is learned implicitly by the value function network.\n    subtour_len_est = torch.sqrt(area) * torch.sqrt(n_unvisited.float())\n    subtour_len_est.masked_fill_(~has_enough_nodes, 0.0)\n\n    # 2. & 3. Cost to connect current and start nodes to the unvisited set.\n    # This is a simpler and more robust connection cost than connecting to the hull itself.\n    dist_matrix = state.distance_matrix()\n    current_node = state.current_node_index()\n    start_node = state.first_node_index()\n\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(B, 1, 1).expand(-1, -1, N)).squeeze(1)\n    dist_from_current.masked_fill_(~unvisited_mask, float('inf'))\n    min_dist_to_unvisited, _ = torch.min(dist_from_current, dim=1)\n\n    dist_from_start = torch.gather(dist_matrix, 1, start_node.view(B, 1, 1).expand(-1, -1, N)).squeeze(1)\n    dist_from_start.masked_fill_(~unvisited_mask, float('inf'))\n    min_dist_from_start, _ = torch.min(dist_from_start, dim=1)\n\n    # Handle cases with fewer than 3 unvisited nodes separately.\n    # If 1 or 2 unvisited, path is fixed. Calculate exact future cost.\n    # [B, N]\n    dist_curr_unvisited = dist_from_current.clone()\n    dist_curr_unvisited[dist_curr_unvisited == float('inf')] = -1\n    # [B, k] where k is max number of unvisited nodes\n    top_two_dists, top_two_indices = torch.topk(dist_curr_unvisited, k=2, dim=1)\n\n    # Cost for 1 unvisited node: dist(current -> u1) + dist(u1 -> start)\n    u1_idx = top_two_indices[:, 0]\n    dist_u1_start = torch.gather(dist_from_start, 1, u1_idx.unsqueeze(1)).squeeze(1)\n    cost_one_unvisited = top_two_dists[:, 0] + dist_u1_start\n\n    # Cost for 2 unvisited nodes: min(path1, path2)\n    # path1: current -> u1 -> u2 -> start\n    # path2: current -> u2 -> u1 -> start\n    u2_idx = top_two_indices[:, 1]\n    dist_u2_start = torch.gather(dist_from_start, 1, u2_idx.unsqueeze(1)).squeeze(1)\n    dist_u1_u2 = torch.gather(torch.gather(dist_matrix, 1, u1_idx.view(B, 1, 1).expand(-1, -1, N)), 2, u2_idx.view(B, 1, 1)).squeeze()\n    cost_path1 = top_two_dists[:, 0] + dist_u1_u2 + dist_u2_start\n    cost_path2 = top_two_dists[:, 1] + dist_u1_u2 + dist_u1_start\n    cost_two_unvisited = torch.min(cost_path1, cost_path2)\n\n    # Combine all costs\n    connection_cost = min_dist_to_unvisited + min_dist_from_start\n    value = subtour_len_est + connection_cost\n\n    # Apply exact costs for small numbers of unvisited nodes.\n    value = torch.where(n_unvisited == 2, cost_two_unvisited, value)\n    value = torch.where(n_unvisited == 1, cost_one_unvisited, value)\n\n    # For terminal states, future cost is 0.\n    value.masked_fill_(is_terminal, 0.0)\n    # Replace any remaining infs with 0.\n    value = torch.nan_to_num(value, posinf=0.0)\n\n    return value.unsqueeze(-1)", "stats": {"mse": 0.34320918159484864, "rmse": 0.5858405769446571, "mse_tsp20": 0.34320918159484864, "rmse_tsp20": 0.5858405769446571, "mse_tsp50": 1.331045243798828, "rmse_tsp50": 1.1537093411248902, "mse_tsp100": 3.931966751171875, "rmse_tsp100": 1.9829187454789656, "mse_worst": 3.931966751171875, "rmse_worst": 1.9829187454789656}, "stats_text": "mse=0.343209; rmse=0.585841; mse_tsp100=3.93197; mse_tsp20=0.343209; mse_tsp50=1.33105; mse_worst=3.93197; rmse_tsp100=1.98292; rmse_tsp20=0.585841; rmse_tsp50=1.15371; rmse_worst=1.98292"}
{"score": 0.14442194401455405, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The algorithm estimates the remaining tour length by multiplying the number of unvisited nodes by the average minimum distance from each unvisited node to any other unvisited node.", "code_hash": "948da801474913ef9ed2db71f330b186f78363384b494b85e41c1da0b92ac1a8", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The algorithm estimates the remaining tour length by multiplying the number of unvisited nodes by the average minimum distance from each unvisited node to any other unvisited node.}\n\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    n_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # For terminal states, the future cost is zero.\n    is_not_terminal = n_unvisited > 1\n    if not is_not_terminal.any():\n        return torch.zeros(dist_matrix.size(0), 1, device=dist_matrix.device)\n\n    # A large value to mask out irrelevant distances\n    large_value = dist_matrix.max() * 2 + 1 if dist_matrix.numel() > 0 else 1e9\n\n    # Create a temporary distance matrix where distances to/from visited nodes are masked\n    # [B, N, N]\n    temp_dist_matrix = dist_matrix.clone()\n    # Mask rows and columns corresponding to visited nodes\n    visited_mask = ~unvisited_mask\n    temp_dist_matrix[visited_mask, :] = large_value\n    temp_dist_matrix[:, visited_mask] = large_value\n    # Mask self-loops\n    temp_dist_matrix.diagonal(dim1=-2, dim2=-1).fill_(large_value)\n\n    # Find the minimum distance from each unvisited node to another unvisited node\n    # [B, N]\n    min_dists, _ = temp_dist_matrix.min(dim=2)\n\n    # Set distances from visited nodes to 0 so they don't affect the sum\n    min_dists.masked_fill_(visited_mask, 0)\n\n    # Calculate the average of these minimum distances\n    # Use a safe divisor to avoid division by zero for terminal states\n    safe_n_unvisited = torch.where(n_unvisited > 0, n_unvisited, torch.ones_like(n_unvisited))\n    # [B]\n    avg_min_dist = min_dists.sum(dim=1) / safe_n_unvisited\n\n    # Estimate the remaining tour length\n    # [B]\n    remaining_tour_length = n_unvisited * avg_min_dist\n\n    # Ensure terminal states have zero value\n    value = torch.where(is_not_terminal, remaining_tour_length, torch.tensor(0.0, device=dist_matrix.device))\n\n    return value.unsqueeze(-1)", "stats": {"mse": 1.8778033940429688, "rmse": 1.3703296661909385, "mse_tsp20": 1.8778033940429688, "rmse_tsp20": 1.3703296661909385, "mse_tsp50": 3.856727740234375, "rmse_tsp50": 1.9638553256883193, "mse_tsp100": 6.9241555140625, "rmse_tsp100": 2.6313790137611304, "mse_worst": 6.9241555140625, "rmse_worst": 2.6313790137611304}, "stats_text": "mse=1.8778; rmse=1.37033; mse_tsp100=6.92416; mse_tsp20=1.8778; mse_tsp50=3.85673; mse_worst=6.92416; rmse_tsp100=2.63138; rmse_tsp20=1.37033; rmse_tsp50=1.96386; rmse_worst=2.63138"}
