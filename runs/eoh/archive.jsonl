{"score": 0.0, "gamma": 1.0, "algorithm": "auto", "thought": "auto", "code_hash": "8ba7f98f7274bcef85b8c3739a0ef7dd5a776d27646e4d40852f3cead98d2a4b", "code": "# THOUGHT: {auto}\ndef phi(state):\n    unvisited = state.unvisited_mask()                      # [B,N]\n    N = unvisited.shape[1]\n    idx = state.current_node_index()                        # [B]\n    dist = state.distance_matrix()                          # [B,N,N]\n    cur_d = dist[torch.arange(dist.shape[0]), idx]          # [B,N]\n    start_d = dist[torch.arange(dist.shape[0]), state.first_node_index()]  # [B,N]\n    # mask out visited nodes\n    cur_d = cur_d.masked_fill(~unvisited, 0.0)\n    start_d = start_d.masked_fill(~unvisited, 0.0)\n    # mean distance to unvisited\n    avg_cur = cur_d.sum(dim=1) / (unvisited.sum(dim=1).clamp_min(1))\n    avg_start = start_d.sum(dim=1) / (unvisited.sum(dim=1).clamp_min(1))\n    # heuristic: twice average radius plus closing leg\n    rem = 2 * avg_cur * unvisited.sum(dim=1).float() + avg_start\n    return rem.unsqueeze(1)                                 # [B,1]", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": -0.1, "algorithm": "auto", "thought": "auto", "code_hash": "bf51f106ae4c9b9115e3047c69f3cb74b2253a9632a8105f4b09b574d11dec31", "code": "# THOUGHT: {auto}\ndef phi(state):\n    uv = state.unvisited_mask()                               # [B,N]\n    B, N = uv.shape\n    D = state.distance_matrix()                               # [B,N,N]\n    # mask self and visited nodes\n    D_uv = D.masked_fill(~uv.unsqueeze(1), 1e8)               # [B,N,N]\n    # nearest unvisited neighbor per node\n    nn_dst, _ = D_uv.min(dim=-1)                              # [B,N]\n    # average nearest-neighbor distance over unvisited nodes\n    avg_nn = (nn_dst * uv).sum(dim=-1) / (uv.sum(dim=-1) + 1e-6)  # [B]\n    # symmetric return leg: distance from last unvisited to start\n    first_idx = state.first_node_index()                      # [B]\n    last_uv_idx = uv.max(dim=-1)[1]                           # [B] last unvisited index\n    ret_leg = D[torch.arange(B), last_uv_idx, first_idx]      # [B]\n    # estimate remaining length\n    rem_est = avg_nn * uv.sum(dim=-1) + ret_leg               # [B]\n    # add current tour length\n    cur_len = D.gather(1, state.partial_path_indices().unsqueeze(-1).expand(-1,-1,2))\n    cur_len = cur_len[:,:-1,0].gather(1, (state.partial_path_indices()!=-1).sum(dim=-1,keepdim=True)-1).squeeze(-1)\n    cur_len = cur_len.where(cur_len>0, torch.zeros_like(cur_len))\n    total_est = rem_est + cur_len                             # [B]\n    return total_est.unsqueeze(-1)                            # [B,1]", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": -0.1, "algorithm": "auto", "thought": "auto", "code_hash": "082ac34a0d5fa66ebe3a524d09a3f491e7ef485b2f030f0eed509652e18704b6", "code": "# THOUGHT: {auto}\ndef phi(state):\n    unvisited = state.unvisited_mask()  # [B,N]\n    num_unvisited = unvisited.sum(dim=1, keepdim=True).float()  # [B,1]\n    current_idx = state.current_node_index()  # [B]\n    start_idx = state.first_node_index()  # [B]\n    dist = state.distance_matrix()  # [B,N,N]\n    \n    # Gather distances from current node to all nodes\n    cur_dists = dist[torch.arange(dist.size(0)), current_idx]  # [B,N]\n    # Mask to unvisited nodes only\n    cur_to_unvisited = torch.where(unvisited, cur_dists, torch.tensor(float('inf'), device=dist.device))\n    avg_dist_from_current = (cur_to_unvisited.sum(dim=1, keepdim=True) / num_unvisited)  # [B,1]\n    \n    # Nearest unvisited to start\n    start_dists = dist[torch.arange(dist.size(0)), start_idx]  # [B,N]\n    start_to_unvisited = torch.where(unvisited, start_dists, torch.tensor(float('inf'), device=dist.device))\n    min_back_dist = start_to_unvisited.min(dim=1, keepdim=True)[0]  # [B,1]\n    \n    # Estimate remaining length\n    remaining = num_unvisited * avg_dist_from_current + min_back_dist\n    return remaining.unsqueeze(1)  # Ensure [B,1]", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": 1.0, "algorithm": "auto", "thought": "auto", "code_hash": "04783b16e91cec24ee18b14ed1b769c6ba9131d903a136792573a5ed4ecfef5b", "code": "# THOUGHT: {auto}\ndef phi(state):\n    # Fetch data\n    coords = state.all_node_coords()  # [B,N,2]\n    unvisited = state.unvisited_mask()  # [B,N]\n    cur_idx = state.current_node_index()  # [B]\n    first_idx = state.first_node_index()  # [B]\n    B, N, _ = coords.shape\n\n    # Degenerate case: all visited\n    all_done = ~unvisited.any(dim=1, keepdim=True)  # [B,1]\n\n    # 1) Distance from current to nearest unvisited\n    dist_to_cur = torch.linalg.norm(\n        coords - coords[torch.arange(B), cur_idx].unsqueeze(1), dim=2\n    )  # [B,N]\n    dist_to_cur = torch.where(unvisited, dist_to_cur, torch.inf)\n    cur2next = dist_to_cur.min(dim=1, keepdim=True)[0]  # [B,1]\n\n    # 2) Pairwise distances among unvisited nodes\n    u_coords = coords.unsqueeze(2) - coords.unsqueeze(1)  # [B,N,N,2]\n    pairwise = torch.linalg.norm(u_coords, dim=3)  # [B,N,N]\n    pairwise = torch.where(\n        unvisited.unsqueeze(1) & unvisited.unsqueeze(2), pairwise, torch.nan\n    )\n    avg_pair = pairwise.nanmean(dim=(1, 2), keepdim=True)  # [B,1]\n\n    # 3) Distance from last unvisited back to start\n    dist_to_first = torch.linalg.norm(\n        coords - coords[torch.arange(B), first_idx].unsqueeze(1), dim=2\n    )  # [B,N]\n    dist_to_first = torch.where(unvisited, dist_to_first, torch.inf)\n    last2first = dist_to_first.min(dim=1, keepdim=True)[0]  # [B,1]\n\n    # Combine: cur2next + (#unvisited-1)*avg_pair + last2first\n    n_unvis = unvisited.sum(dim=1, keepdim=True).float()  # [B,1]\n    est = cur2next + torch.relu(n_unvis - 1) * avg_pair + last2first\n    est = torch.where(all_done, 0.0, est)  # zero when tour complete\n    return est  # [B,1]", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": 1.0, "algorithm": "auto", "thought": "auto", "code_hash": "5e5f92ae5bf49c7b7a1a8042550ded0bb66616d7b151df7bb688eafd994032c9", "code": "# THOUGHT: {auto}\ndef phi(state):\n    coords = state.all_node_coords()  # [B, N, 2]\n    unvisited = state.unvisited_mask()  # [B, N]\n    current_idx = state.current_node_index()  # [B]\n    B, N, _ = coords.size()\n    \n    # Current node coordinates\n    current_coord = coords[torch.arange(B), current_idx].unsqueeze(1)  # [B, 1, 2]\n    \n    # Unvisited node coordinates\n    unvisited_coords = coords * unvisited.unsqueeze(-1)  # [B, N, 2]\n    unvisited_counts = unvisited.sum(dim=1, keepdim=True).clamp(min=1)  # [B, 1]\n    \n    # Average distance from current node to unvisited nodes\n    dist_to_unvisited = torch.norm(unvisited_coords - current_coord, dim=2)  # [B, N]\n    avg_dist_to_unvisited = (dist_to_unvisited * unvisited).sum(dim=1, keepdim=True) / unvisited_counts  # [B, 1]\n    \n    # Pairwise distances among unvisited nodes\n    unvisited_coords_expanded = unvisited_coords.unsqueeze(2)  # [B, N, 1, 2]\n    unvisited_coords_tiled = unvisited_coords.unsqueeze(1)  # [B, 1, N, 2]\n    pairwise_dists = torch.norm(unvisited_coords_expanded - unvisited_coords_tiled, dim=3)  # [B, N, N]\n    pairwise_mask = unvisited.unsqueeze(2) * unvisited.unsqueeze(1)  # [B, N, N]\n    pairwise_dists = pairwise_dists * pairwise_mask  # Mask out non-unvisited pairs\n    pairwise_counts = pairwise_mask.sum(dim=(1, 2), keepdim=True).clamp(min=1)  # [B, 1]\n    avg_pairwise_dist = pairwise_dists.sum(dim=(1, 2), keepdim=True) / pairwise_counts  # [B, 1]\n    \n    # Combine both terms as an estimate of remaining tour length\n    remaining_estimate = avg_dist_to_unvisited + avg_pairwise_dist\n    return remaining_estimate  # [B, 1]", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": -0.1, "algorithm": "auto", "thought": "auto", "code_hash": "47fe4b4935ba1cdfeb08b631bc6a12bf23744b8f5d5c789f58e3a5f163b585b4", "code": "# THOUGHT: {auto}\ndef phi(state):\n    unvisited = state.unvisited_mask()                      # [B,N]\n    coords = state.all_node_coords()                        # [B,N,2]\n    B, N, _ = coords.shape\n    \n    # Pairwise distances: [B,N,N]\n    delta = coords.unsqueeze(2) - coords.unsqueeze(1)\n    dist = (delta ** 2).sum(-1).sqrt()\n    \n    # Mask out visited nodes for nearest-neighbor search\n    masked = dist.masked_fill(~unvisited.unsqueeze(1), float('inf'))\n    \n    # Nearest unvisited neighbor distance per node (inf for visited)\n    nearest, _ = masked.min(dim=-1)                         # [B,N]\n    nearest = nearest.masked_fill(~unvisited, 0.0)\n    \n    # Average nearest-neighbor distance among unvisited\n    avg_nn = nearest.sum(dim=-1) / unvisited.sum(dim=-1).clamp(min=1)  # [B]\n    \n    # Distance from each unvisited to start\n    start_idx = state.first_node_index()                    # [B]\n    start_coord = coords.gather(1, start_idx.view(B,1,1).expand(B,1,2)).squeeze(1)  # [B,2]\n    delta_start = coords - start_coord.unsqueeze(1)         # [B,N,2]\n    dist_start = (delta_start ** 2).sum(-1).sqrt()          # [B,N]\n    dist_start = dist_start.masked_fill(~unvisited, 0.0)\n    \n    # Minimum distance back to start among unvisited\n    min_back, _ = dist_start.max(dim=-1)                    # [B] (use max to avoid 0 when few left)\n    \n    # Remaining length estimate\n    n_unvisited = unvisited.sum(dim=-1).float()             # [B]\n    remaining = avg_nn * n_unvisited + min_back\n    \n    # Normalize by sqrt(N) for scale invariance\n    scale = (N ** 0.5).float()\n    return (remaining / scale).unsqueeze(-1)                # [B,1]", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": -0.1, "algorithm": "auto", "thought": "auto", "code_hash": "101a2da6626d91df4a9e657ee71938c7f8202366bdd7818531107899ddf2c5a9", "code": "# THOUGHT: {auto}\ndef phi(state):\n    unvisited = state.unvisited_mask()                      # [B,N]\n    num_unvisited = unvisited.sum(dim=1, keepdim=True)      # [B,1]\n    dm = state.distance_matrix()                            # [B,N,N]\n    # mask self and visited; inf for invalid\n    masked_dm = dm.masked_fill(~unvisited.unsqueeze(1), float('inf'))\n    # nearest unvisited neighbor distance per node\n    nearest = masked_dm.min(dim=2).values                   # [B,N]\n    # average over unvisited nodes\n    avg_nearest = (nearest * unvisited).sum(dim=1, keepdim=True) / num_unvisited.clamp(min=1)\n    # distance from current node to nearest unvisited\n    cur_idx = state.current_node_index()                    # [B]\n    cur_dist = nearest.gather(1, cur_idx.unsqueeze(1))      # [B,1]\n    # heuristic: (num_unvisited * avg_nearest) + cur_dist\n    return (num_unvisited * avg_nearest) + cur_dist         # [B,1]", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": -0.1, "algorithm": "auto", "thought": "auto", "code_hash": "ff71331ea540fe964c419de5dd8018dd2948f416846d197503cdb090b3520ffc", "code": "# THOUGHT: {auto}\ndef phi(state):\n    B = state.current_node_index().size(0)\n    unvisited = state.unvisited_mask()  # [B, N]\n    N = unvisited.size(1)\n    dist = state.distance_matrix()  # [B, N, N]\n    cur_idx = state.current_node_index()  # [B]\n    # distances from current node to all nodes\n    cur_dists = dist[torch.arange(B), cur_idx]  # [B, N]\n    # mask out visited (set to inf to ignore in min)\n    cur_dists = torch.where(unvisited, cur_dists, torch.tensor(float('inf'), device=cur_dists.device))\n    # nearest unvisited from current\n    nearest_cur = torch.min(cur_dists, dim=1)[0]  # [B]\n    # pairwise distances among unvisited nodes\n    # create a mask [B, N, N] for unvisited pairs\n    unvisited_bcast = unvisited.unsqueeze(1) & unvisited.unsqueeze(2)  # [B, N, N]\n    # set non-unvisited pairs to inf\n    unvisited_dists = torch.where(unvisited_bcast, dist, torch.tensor(float('inf'), device=dist.device))\n    # min outgoing edge per unvisited node (over unvisited only)\n    min_out = torch.min(unvisited_dists, dim=2)[0]  # [B, N]\n    # mask out visited (set to 0 for reduction)\n    min_out = torch.where(unvisited, min_out, torch.tensor(0.0, device=min_out.device))\n    # count unvisited\n    num_unvisited = unvisited.sum(dim=1).float()  # [B]\n    # MST-like lower bound: sum of min outgoing edges divided by 2 (1/2 * sum(min_edges) is a lower bound on MST)\n    mst_bound = 0.5 * min_out.sum(dim=1)  # [B]\n    # fallback when no unvisited\n    mst_bound = torch.where(num_unvisited > 0, mst_bound, torch.tensor(0.0, device=mst_bound.device))\n    # heuristic: nearest from current + mst_bound over unvisited\n    est = nearest_cur + mst_bound\n    # scale to reasonable magnitude (empirically ~ N/2 steps, each ~unit distance)\n    est = est * (num_unvisited + 1).sqrt()\n    # ensure [B, 1] output\n    return est.unsqueeze(1)", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": -0.1, "algorithm": "auto", "thought": "auto", "code_hash": "e1672a8e0a1db77f339615197b5a3b6853fc0d2710ce27f1150d322abf6276f6", "code": "# THOUGHT: {auto}\ndef phi(state):\n    coords = state.all_node_coords()  # [B, N, 2]\n    unvisited = state.unvisited_mask()  # [B, N]\n    current_idx = state.current_node_index()  # [B]\n    B, N, _ = coords.shape\n    # Get current node coordinates\n    cur_coords = coords[torch.arange(B), current_idx].unsqueeze(1)  # [B, 1, 2]\n    # Compute distances from current to all nodes\n    dists = torch.norm(coords - cur_coords, p=2, dim=-1)  # [B, N]\n    # Mask distances to unvisited nodes\n    valid_dists = torch.where(unvisited, dists, torch.tensor(float('nan')).to(dists.device))\n    # Compute mean distance over unvisited nodes\n    mean_dist = torch.nanmean(valid_dists, dim=1, keepdim=True)  # [B, 1]\n    # Scale to approximate expected remaining tour length\n    return mean_dist * unvisited.float().sum(dim=1, keepdim=True)  # [B, 1]", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": -0.1, "algorithm": "auto", "thought": "auto", "code_hash": "a8f2fb51fc819f52ed4efd2ba4c1a9e7e3dee65f3e6e2fba853f0889ddae55f0", "code": "# THOUGHT: {auto}\ndef phi(state):\n    # Extract coordinates and masks\n    coords = state.all_node_coords()  # [B, N, 2]\n    unvisited = state.unvisited_mask()  # [B, N]\n    current_idx = state.current_node_index()  # [B]\n    start_idx = state.first_node_index()  # [B]\n    B, N, _ = coords.shape\n    \n    # Current and start coordinates\n    current_coord = coords[torch.arange(B), current_idx, :]  # [B, 2]\n    start_coord = coords[torch.arange(B), start_idx, :]  # [B, 2]\n    \n    # Compute pairwise distances among all nodes\n    dist_all = state.distance_matrix()  # [B, N, N]\n    \n    # Mask distances for unvisited nodes only\n    unvisited_f = unvisited.float().unsqueeze(1)  # [B, 1, N]\n    dist_unvisited = dist_all * unvisited_f * unvisited_f.transpose(1, 2)  # [B, N, N]\n    # Avoid zero diagonal to prevent softmin collapse\n    dist_unvisited = dist_unvisited + (1 - unvisited_f) * 1e6  # mask out visited\n    \n    # Estimate MST length on unvisited nodes using softmin approximation of sum of smallest edges\n    # Approximate MST as sum of smallest (N_unvisited - 1) edges connecting unvisited nodes\n    # Use softmin to select small edges smoothly\n    k = unvisited.sum(dim=1, keepdim=True) - 1  # [B, 1], number of edges in MST\n    k = torch.clamp(k, min=0)\n    \n    # Flatten upper triangle (no self loops)\n    tri_mask = torch.triu(torch.ones(N, N, device=coords.device, dtype=torch.bool), diagonal=1).unsqueeze(0)  # [1, N, N]\n    flat_dist = torch.where(tri_mask, dist_unvisited, torch.full_like(dist_unvisited, 1e6))  # [B, N, N]\n    flat_dist = flat_dist.view(B, -1)  # [B, N*(N-1)/2]\n    \n    # Softmin to approximate smallest k edges\n    tau = 0.1\n    weights = torch.softmax(-flat_dist / tau, dim=1)  # [B, N*(N-1)/2]\n    sorted_vals, _ = torch.sort(flat_dist, dim=1)\n    k_int = k.squeeze(1).long()\n    mst_approx = torch.zeros(B, device=coords.device)\n    for b in range(B):\n        if k_int[b] > 0:\n            mst_approx[b] = sorted_vals[b, :k_int[b]].sum()\n    \n    # Add distance from current to nearest unvisited\n    dist_from_current = dist_all[torch.arange(B), current_idx, :]  # [B, N]\n    dist_from_current = torch.where(unvisited, dist_from_current, torch.full_like(dist_from_current, 1e6))\n    nearest_unvisited_dist = torch.min(dist_from_current, dim=1)[0]  # [B]\n    \n    # Add distance from last unvisited back to start (approximated as min distance from any unvisited to start)\n    dist_to_start = dist_all[torch.arange(B), start_idx, :]  # [B, N]\n    dist_to_start = torch.where(unvisited, dist_to_start, torch.full_like(dist_to_start, 1e6))\n    min_dist_to_start = torch.min(dist_to_start, dim=1)[0]  # [B]\n    \n    # Total estimate\n    total = mst_approx + nearest_unvisited_dist + min_dist_to_start  # [B]\n    return total.unsqueeze(1)  # [B, 1]", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": 0.1, "algorithm": "auto", "thought": "auto", "code_hash": "d387a1134ce935c96018531b02681c64cc83bf695ed840ee401b59782759111c", "code": "# THOUGHT: {auto}\ndef phi(state):\n    unvisited = state.unvisited_mask()                      # [B,N]\n    visited = state.visited_mask()                          # [B,N]\n    dm = state.distance_matrix()                            # [B,N,N]\n    # min distance from each unvisited node to any visited node (or to start if none)\n    min_to_visited, _ = (dm * visited.unsqueeze(1)).min(dim=2)  # [B,N]\n    min_to_visited = min_to_visited.clamp_min(0.0)\n    # take only unvisited nodes\n    unvisited_sum = (min_to_visited * unvisited).sum(dim=1)     # [B]\n    unvisited_cnt = unvisited.sum(dim=1).clamp_min(1)           # [B]\n    avg_unvisited_cost = unvisited_sum / unvisited_cnt          # [B]\n    # distance from current node to nearest unvisited and back to start\n    cur_idx = state.current_node_index()                        # [B]\n    cur_dists = dm[torch.arange(dm.size(0)), cur_idx]           # [B,N]\n    unvisited_dists = cur_dists * unvisited                     # [B,N]\n    # nearest unvisited\n    unvisited_dists = torch.where(unvisited, unvisited_dists, torch.inf)\n    nearest_unvisited_dist, _ = unvisited_dists.min(dim=1)      # [B]\n    start_idx = state.first_node_index()                        # [B]\n    back_to_start = dm[torch.arange(dm.size(0)), cur_idx, start_idx]  # [B]\n    # combine\n    estimate = avg_unvisited_cost + nearest_unvisited_dist + back_to_start\n    # scale to keep reasonable magnitude\n    return (estimate * 0.1).unsqueeze(1)                        # [B,1]", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": 0.1, "algorithm": "auto", "thought": "auto", "code_hash": "9d3486f7872add595bd26b523f9480f221bfc986e56b1a49f7263e3df4953036", "code": "# THOUGHT: {auto}\ndef phi(state):\n    coords = state.all_node_coords()  # [B,N,2]\n    B, N, _ = coords.shape\n    unvisited = state.unvisited_mask()  # [B,N]\n    num_left = unvisited.sum(dim=1, keepdim=True).clamp(min=1)  # [B,1]\n    frac_left = num_left / N  # [B,1]\n\n    # pairwise distances among unvisited\n    dist_mat = state.distance_matrix()  # [B,N,N]\n    unvisited_f = unvisited.float()\n    mask2d = unvisited.unsqueeze(1) * unvisited.unsqueeze(2)  # [B,N,N]\n    masked_d = dist_mat * mask2d.float()\n    avg_pair = (masked_d.sum(dim=(1,2)) / (num_left.squeeze(1) * (num_left.squeeze(1) - 1)).clamp(min=1)).unsqueeze(1)  # [B,1]\n\n    # distances from current node to unvisited\n    cur_idx = state.current_node_index()  # [B]\n    cur_d = dist_mat[torch.arange(B), cur_idx]  # [B,N]\n    cur_d = cur_d * unvisited_f\n    nearest_d_cur, nearest_idx = cur_d.min(dim=1)  # [B]\n\n    # distance from nearest unvisited to first node\n    first_idx = state.first_node_index()  # [B]\n    back_d = dist_mat[torch.arange(B), nearest_idx, first_idx]  # [B]\n\n    # heuristic: (avg pairwise) + (cur->nearest) + (nearest->start)\n    heuristic = avg_pair + nearest_d_cur.unsqueeze(1) + back_d.unsqueeze(1)\n    # scale by fraction left to ensure terminal consistency\n    return heuristic * frac_left  # [B,1]", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": 1.0, "algorithm": "auto", "thought": "auto", "code_hash": "84dc0532ce6459298f55b24ce7843f8ca10f57accf6446858c4f8f3d1380f112", "code": "# THOUGHT: {auto}\ndef phi(state):\n    unvisited = state.unvisited_mask()                     # [B, N]\n    coords = state.all_node_coords()                       # [B, N, 2]\n    dist = state.distance_matrix()                         # [B, N, N]\n    B, N = unvisited.shape\n\n    # Compute pairwise distances among unvisited nodes\n    unvisited_f = unvisited.float().unsqueeze(-1)          # [B, N, 1]\n    # Mask distances: zero out rows/cols of visited nodes\n    masked_dist = dist * unvisited_f.unsqueeze(1) * unvisited_f.unsqueeze(2)  # [B, N, N]\n    # Count unvisited pairs per batch\n    counts = unvisited.sum(dim=1, keepdim=True)            # [B, 1]\n    valid_pairs = counts * (counts - 1) + 1e-6             # avoid div0\n    avg_pairwise = (masked_dist.sum(dim=(1,2), keepdim=True) / valid_pairs).squeeze(-1)  # [B, 1]\n\n    # Distance from current location to nearest unvisited node\n    cur_idx = state.current_node_index()                   # [B]\n    cur_dists = dist[torch.arange(B), cur_idx]             # [B, N]\n    cur_dists = cur_dists.masked_fill(~unvisited, float('inf'))\n    min_cur = cur_dists.min(dim=1, keepdim=True)[0]        # [B, 1]\n\n    # Distance from start location to nearest unvisited node\n    start_idx = state.first_node_index()                   # [B]\n    start_dists = dist[torch.arange(B), start_idx]         # [B, N]\n    start_dists = start_dists.masked_fill(~unvisited, float('inf'))\n    min_start = start_dists.min(dim=1, keepdim=True)[0]    # [B, 1]\n\n    # Combine components and normalize by unvisited count\n    phi_val = (avg_pairwise + min_cur + min_start) / (counts.unsqueeze(-1) + 1)\n    return phi_val", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": 0.1, "algorithm": "auto", "thought": "auto", "code_hash": "d0d85f46ba703cb161d46768b48e2090606e10461ef7e6a2a5571060f70bacfd", "code": "# THOUGHT: {auto}\ndef phi(state):\n    coords = state.all_node_coords()  # [B,N,2]\n    unvisited = state.unvisited_mask()  # [B,N]\n    start_idx = state.first_node_index()  # [B]\n    B, N, _ = coords.shape\n    \n    # Compute pairwise distances\n    delta = coords.unsqueeze(2) - coords.unsqueeze(1)  # [B,N,N,2]\n    dist = torch.norm(delta, dim=-1)  # [B,N,N]\n    \n    # Mask out visited nodes and self-loops (set large distance)\n    mask = unvisited.unsqueeze(1) & (torch.arange(N, device=coords.device) != torch.arange(N, device=coords.device).view(1, N, 1))\n    masked_dist = torch.where(mask, dist, torch.full_like(dist, 1e8))\n    \n    # Nearest unvisited neighbor per node (only among unvisited)\n    nearest_dist, _ = masked_dist.min(dim=-1)  # [B,N]\n    # Only consider unvisited nodes\n    nearest_unvisited = torch.where(unvisited, nearest_dist, torch.zeros_like(nearest_dist))\n    avg_nearest = nearest_unvisited.sum(dim=1) / unvisited.sum(dim=1).clamp(min=1)  # [B]\n    \n    # Distance from current node to start (for return leg)\n    cur_idx = state.current_node_index()  # [B]\n    batch_idx = torch.arange(B, device=coords.device)\n    cur2start = dist[batch_idx, cur_idx, start_idx]  # [B]\n    \n    # Estimate remaining tour: unvisited nodes * avg step + return\n    remain = unvisited.sum(dim=1).float() * avg_nearest + cur2start  # [B]\n    return remain.unsqueeze(1)  # [B,1]", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": -0.1, "algorithm": "auto", "thought": "auto", "code_hash": "0ce4ba3937139f8ee01f1be0ad36944ebf755767eb5c8084fb39248672b83fba", "code": "# THOUGHT: {auto}\ndef phi(state):\n    # Coordinates and masks\n    coords = state.all_node_coords()  # [B,N,2]\n    unvisited = state.unvisited_mask()  # [B,N]\n    current_idx = state.current_node_index()  # [B]\n    B, N, _ = coords.shape\n\n    # Current location\n    cur_loc = coords[torch.arange(B), current_idx, :]  # [B,2]\n\n    # Distance to all nodes from current\n    cur_to_all = torch.linalg.norm(coords - cur_loc.unsqueeze(1), dim=2)  # [B,N]\n\n    # Nearest unvisited distance\n    cur_to_unvisited = torch.where(unvisited, cur_to_all, torch.inf)\n    nearest_dist = torch.min(cur_to_unvisited, dim=1).values  # [B]\n\n    # Pairwise distances among unvisited nodes\n    diff = coords.unsqueeze(2) - coords.unsqueeze(1)  # [B,N,N,2]\n    dist_mat = torch.linalg.norm(diff, dim=3)  # [B,N,N]\n\n    # Mask to unvisited pairs\n    unvisited_pair = unvisited.unsqueeze(1) & unvisited.unsqueeze(2)  # [B,N,N]\n    unvisited_pair = unvisited_pair & ~torch.eye(N, dtype=torch.bool, device=coords.device).unsqueeze(0)\n\n    # Mean distance among unvisiteds (MST proxy)\n    unvisited_dists = torch.where(unvisited_pair, dist_mat, torch.nan)\n    mean_unvisited_dist = torch.nanmean(unvisited_dists, dim=(1, 2))  # [B]\n\n    # Estimate: nearest + (num_unvisited - 1) * mean_unvisited_dist\n    num_unvisited = unvisited.sum(dim=1).float()  # [B]\n    estimate = nearest_dist + torch.maximum(num_unvisited - 1, torch.tensor(0.0)) * mean_unvisited_dist  # [B]\n\n    # Normalize by average pairwise distance in instance for scale invariance\n    avg_instance_dist = dist_mat.mean(dim=(1, 2))  # [B]\n    avg_instance_dist = torch.where(avg_instance_dist > 0, avg_instance_dist, torch.tensor(1.0))\n    normalized = estimate / avg_instance_dist  # [B]\n\n    # Return as [B,1]\n    return normalized.unsqueeze(1)", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": 0.1, "algorithm": "auto", "thought": "auto", "code_hash": "4b539f497329650ce2ddd42da04ec72d3d5110269a8cdd1799541927e804e755", "code": "# THOUGHT: {auto}\ndef phi(state):\n    unvisited = state.unvisited_mask().float()                       # [B,N]\n    num_unvisited = unvisited.sum(dim=1, keepdim=True)             # [B,1]\n    D = state.distance_matrix()                                    # [B,N,N]\n    # average distance from each node to all others (mask self-distance=0)\n    avg_dist = (D.sum(dim=2) / (D.size(1) - 1)).unsqueeze(2)       # [B,N,1]\n    # pick unvisited nodes' avg distances\n    unvisited_avg = (unvisited.unsqueeze(2) * avg_dist).sum(dim=1)  # [B,1]\n    # reduce over batch to keep node-count invariance\n    est = unvisited_avg * num_unvisited * 0.05                     # [B,1]\n    return est.clamp(min=0.0)", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": 0.1, "algorithm": "auto", "thought": "auto", "code_hash": "fe575c25bebfa742a8461c7e957d1e5f05b9b4b400f63a67bfec97d5a5414434", "code": "# THOUGHT: {auto}\ndef phi(state):\n    # Get coordinates and masks\n    coords = state.all_node_coords()  # [B,N,2]\n    unvis = state.unvisited_mask()    # [B,N]\n    cur_idx = state.current_node_index()  # [B]\n    batch, N, _ = coords.size()\n    \n    # Coordinates of visited nodes are masked to zero so they don't affect reductions\n    coords_unvis = coords * unvis.unsqueeze(-1)  # [B,N,2]\n    \n    # Pairwise distances among unvisited nodes\n    # Compute pairwise differences\n    dx = coords_unvis.unsqueeze(2) - coords_unvis.unsqueeze(1)  # [B,N,N,2]\n    dist_mat = torch.norm(dx, p=2, dim=-1)  # [B,N,N]\n    # Zero out diagonal and pairs involving visited nodes\n    unvis_pair = unvis.unsqueeze(1) * unvis.unsqueeze(2)  # [B,N,N]\n    dist_mat = dist_mat * unvis_pair\n    # Count of unvisited nodes per batch\n    n_unvis = unvis.sum(dim=1, keepdim=True).clamp(min=1)  # [B,1]\n    # Average pairwise distance among unvisited\n    avg_pair_dist = dist_mat.sum(dim=(1,2), keepdim=True) / (n_unvis * (n_unvis - 1)).clamp(min=1)\n    \n    # Distance from current node to nearest unvisited\n    cur_coord = coords[torch.arange(batch), cur_idx, :]  # [B,2]\n    dist_to_cur = torch.norm(coords_unvis - cur_coord.unsqueeze(1), p=2, dim=-1)  # [B,N]\n    dist_to_cur = dist_to_cur * unvis  # mask visited\n    min_dist_to_cur, _ = dist_to_cur.min(dim=1, keepdim=True)  # [B,1]\n    \n    # Combine: avg pairwise distance + nearest distance as heuristic for remaining tour\n    heuristic = avg_pair_dist + min_dist_to_cur\n    return heuristic", "stats": null, "stats_text": null}
{"score": 0.0, "gamma": 1.0, "algorithm": "auto", "thought": "auto", "code_hash": "b1a801b755d1cf440bedb80ef5f35e4d97f998f8ecfd3daf568f4932ae8511ba", "code": "# THOUGHT: {auto}\ndef phi(state):\n    unvisited = state.unvisited_mask()                       # [B,N]\n    coords = state.all_node_coords()                         # [B,N,2]\n    B, N, _ = coords.shape\n\n    # pairwise distances\n    d = torch.cdist(coords, coords, p=2)                     # [B,N,N]\n\n    # mask self and visited\n    d = d.masked_fill(~unvisited.unsqueeze(1), 1e8)          # mask visited rows\n    d = d.masked_fill(~unvisited.unsqueeze(2), 1e8)          # mask visited cols\n\n    # nearest unvisited neighbor per node (still unvisited)\n    nn, _ = d.min(dim=-1)                                    # [B,N]\n    nn = nn.masked_fill(~unvisited, 0.0)                     # zero for visited\n\n    # avg nearest-neighbor distance among unvisited\n    avg_nn = nn.sum(dim=-1) / unvisited.sum(dim=-1).clamp(min=1)  # [B]\n\n    # distance back to start\n    start_idx = state.first_node_index()                     # [B]\n    start_coord = coords[torch.arange(B), start_idx]         # [B,2]\n    cur_idx = state.current_node_index()                     # [B]\n    cur_coord = coords[torch.arange(B), cur_idx]             # [B,2]\n    return_to_start = (cur_coord - start_coord).norm(p=2, dim=-1)  # [B]\n\n    # remaining nodes\n    rem = unvisited.sum(dim=-1).float()                      # [B]\n\n    # heuristic: rem * avg_nn + return leg\n    est = rem * avg_nn + return_to_start                     # [B]\n    return est.unsqueeze(-1)                                 # [B,1]", "stats": null, "stats_text": null}
