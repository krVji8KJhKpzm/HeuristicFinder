{"score": 2.1666411957501115, "gamma": 1.0, "algorithm": "auto", "code_hash": "215a9bb222ba5cb837cab1ca242841eb364c178adfc78eeff4dc565d3e0b0870", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for a TSP state.\n\n    The potential is calculated as the sum of two components:\n    1. The cost to travel from the current node to the nearest unvisited node.\n    2. An estimate of the cost to complete the tour through the remaining unvisited nodes.\n       This is approximated by summing, for each unvisited node, the minimum distance\n       to any *other* unvisited node. This serves as a rough lower bound on the\n       remaining tour length, similar to an MST-based heuristic but simpler to compute\n       and differentiable.\n\n    Args:\n        state: A TSPStateView object providing access to the environment state.\n\n    Returns:\n        A tensor of shape [B, 1] representing the estimated future cost for each state in the batch.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n\n    # Create a mask for valid destinations: must be unvisited.\n    # [B, N] -> [B, 1, N]\n    unvisited_mask_from = unvisited_mask.unsqueeze(1)\n    # [B, N] -> [B, N, 1]\n    unvisited_mask_to = unvisited_mask.unsqueeze(2)\n\n    # Component 1: Distance from the current node to the nearest unvisited node.\n    # Get distances from the current node: [B, N]\n    current_dists = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    # Apply mask to consider only unvisited destinations\n    current_dists_masked = torch.where(unvisited_mask, current_dists, torch.full_like(current_dists, float('inf')))\n    # Find the minimum distance to an unvisited node.\n    # If no nodes are unvisited (terminal state), this will be inf, which we handle.\n    min_dist_to_unvisited = torch.min(current_dists_masked, dim=1, keepdim=True).values\n\n    # Component 2: Estimated cost for the remaining tour of unvisited nodes.\n    # Create a distance matrix containing only edges between unvisited nodes.\n    # [B, N, N]\n    unvisited_dist_matrix = dist_matrix.where(unvisited_mask_from & unvisited_mask_to, torch.full_like(dist_matrix, float('inf')))\n    # To prevent a node from connecting to itself, set the diagonal to infinity.\n    # This is crucial for finding the minimum distance to *another* unvisited node.\n    # This is redundant since dist_matrix diagonal is 0, but good for clarity.\n    unvisited_dist_matrix.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n\n    # For each unvisited node (row), find the minimum distance to any other unvisited node (column).\n    # [B, N]\n    min_dists_from_unvisited, _ = torch.min(unvisited_dist_matrix, dim=2)\n    # Zero out the values for nodes that have already been visited.\n    min_dists_from_unvisited = torch.where(unvisited_mask, min_dists_from_unvisited, 0.0)\n    # Sum these minimum distances to get an estimate of the remaining tour cost.\n    # [B, 1]\n    remaining_tour_cost_estimate = min_dists_from_unvisited.sum(dim=1, keepdim=True)\n\n    # Total potential is the sum of the two components.\n    # For terminal states, unvisited_mask is all False.\n    # min_dist_to_unvisited will be inf, and remaining_tour_cost_estimate will be 0.\n    # We want phi to be 0 at terminal states.\n    value = min_dist_to_unvisited + remaining_tour_cost_estimate\n\n    # Handle terminal states: if there are no unvisited nodes, the potential should be 0.\n    # `torch.any(unvisited_mask, dim=1)` is True if there's at least one unvisited node.\n    is_not_terminal = torch.any(unvisited_mask, dim=1, keepdim=True)\n    value = torch.where(is_not_terminal, value, 0.0)\n\n    return value", "stats": {"mse": 0.46154388735961915, "rmse": 0.6793702137712686, "mse_tsp20": 0.46154388735961915, "rmse_tsp20": 0.6793702137712686, "mse_tsp50": 1.1061160279785156, "rmse_tsp50": 1.0517205084900245, "mse_tsp100": 2.0727887998291017, "rmse_tsp100": 1.4397183057213316}, "stats_text": "mse=0.461544; rmse=0.67937; mse_tsp100=2.07279; mse_tsp20=0.461544; mse_tsp50=1.10612; rmse_tsp100=1.43972; rmse_tsp20=0.67937; rmse_tsp50=1.05172"}
{"score": 0.18060325893333726, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" {Estimate future tour length by finding the minimum distance from each unvisited node to any other available node (unvisited or current), summing these minimums, and scaling by the log of remaining nodes.", "code_hash": "f4046de7de2b1d04b827c811d4bd9c27f6c48154a814762acb33f2134cabbab6", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimate future tour length by finding the minimum distance from each unvisited node to any other available node (unvisited or current), summing these minimums, and scaling by the log of remaining nodes.}\n    Args:\n        state: TSPStateView with batch dimension B and N nodes.\n    Returns:\n        A tensor of shape [B, 1] representing the estimated future cost (negative value).\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, 1, N]\n    unvisited_mask_from = unvisited_mask.unsqueeze(1)\n    # [B, N, 1]\n    unvisited_mask_to = unvisited_mask.unsqueeze(2)\n    # [B, N]\n    current_node = state.current_node_index()\n    # [B, N]\n    current_mask = torch.zeros_like(unvisited_mask).scatter_(1, current_node.unsqueeze(1), 1)\n    # [B, N, 1]\n    current_mask_to = current_mask.unsqueeze(2)\n    \n    # [B, N, 1] mask for valid 'to' nodes (unvisited or current)\n    # This allows connecting from an unvisited node to any other unvisited node or back to the current one.\n    available_to_mask = unvisited_mask_to | current_mask_to\n    \n    # [B, N, N] mask for valid connections: from unvisited to available\n    valid_connections_mask = unvisited_mask_from & available_to_mask\n    \n    # Set distances for invalid connections to a large value\n    large_value = 1e9\n    masked_dist = torch.where(valid_connections_mask, dist_matrix, large_value)\n    \n    # For each unvisited node ('from' node), find the minimum distance to any available 'to' node\n    # [B, N]\n    min_dist_from_unvisited, _ = torch.min(masked_dist, dim=2)\n    \n    # Sum these minimum distances, but only for the unvisited nodes.\n    # We set the distances for already visited nodes to 0 so they don't contribute to the sum.\n    min_dist_from_unvisited = torch.where(unvisited_mask, min_dist_from_unvisited, 0.0)\n    # [B]\n    sum_of_min_dists = torch.sum(min_dist_from_unvisited, dim=1)\n    \n    # [B]\n    num_unvisited = torch.sum(unvisited_mask, dim=1, dtype=torch.float32)\n    \n    # Scale the sum by a factor related to the number of remaining nodes.\n    # Using log helps to moderate the scaling effect as the tour progresses.\n    # Add 1.0 to avoid log(0) and log(1)=0 which would zero out the potential.\n    # Adding 1.0 to num_unvisited ensures the scaler is > 0.\n    scaler = torch.log1p(num_unvisited)\n    \n    # The potential is the scaled sum of minimum distances.\n    # It represents an optimistic estimate of the remaining path length.\n    # [B]\n    potential = sum_of_min_dists * scaler\n    \n    # The value function V is the negative of the cost-to-go.\n    # Since phi approximates cost-to-go, we return its negative.\n    # [B, 1]\n    value = -potential.unsqueeze(1)\n    \n    return value", "stats": {"mse": 5.536998645019532, "rmse": 2.353082796040023, "mse_tsp20": 5.536998645019532, "rmse_tsp20": 2.353082796040023, "mse_tsp50": 11.536133884179687, "rmse_tsp50": 3.3964884637195056, "mse_tsp100": 21.014083251171876, "rmse_tsp100": 4.584112046097028}, "stats_text": "mse=5.537; rmse=2.35308; mse_tsp100=21.0141; mse_tsp20=5.537; mse_tsp50=11.5361; rmse_tsp100=4.58411; rmse_tsp20=2.35308; rmse_tsp50=3.39649"}
{"score": 0.16859126129448987, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" {My algorithm estimates the future tour length by combining the average distance from the current node to all unvisited nodes with the average pairwise distance among all unvisited nodes, scaled by the number of remaining nodes.", "code_hash": "c0011dfdd305034a0384e65a10dd8a1d5dee9f227e2038e32c18321acaf3c85d", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {My algorithm estimates the future tour length by combining the average distance from the current node to all unvisited nodes with the average pairwise distance among all unvisited nodes, scaled by the number of remaining nodes.}\n    Args:\n        state: A TSPStateView object with batch-friendly helpers.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B, 1]\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True).float()\n\n    # Create a mask for visited nodes to handle the terminal state gracefully\n    # [B, N]\n    visited_mask = ~unvisited_mask\n    # [B, 1]\n    is_terminal = (num_unvisited == 0)\n\n    # 1. Average distance from the current node to all unvisited nodes\n    # [B, 1, N]\n    current_node_exp = current_node.unsqueeze(1).unsqueeze(2).expand(-1, 1, dist_matrix.shape[2])\n    # [B, N]\n    dist_from_current = dist_matrix.gather(1, current_node_exp).squeeze(1)\n    \n    # Apply mask and sum\n    # [B]\n    sum_dist_from_current_to_unvisited = (dist_from_current * unvisited_mask).sum(dim=1)\n    # [B, 1]\n    avg_dist_from_current_to_unvisited = sum_dist_from_current_to_unvisited.unsqueeze(1) / torch.max(torch.ones_like(num_unvisited), num_unvisited)\n\n    # 2. Average pairwise distance among all unvisited nodes\n    # [B, N, N]\n    unvisited_pairwise_mask = unvisited_mask.unsqueeze(2) * unvisited_mask.unsqueeze(1)\n    # Set diagonal to False to avoid self-distances\n    unvisited_pairwise_mask.diagonal(dim1=-2, dim2=-1).fill_(False)\n    \n    # [B]\n    sum_dist_unvisited = (dist_matrix * unvisited_pairwise_mask).sum(dim=[1, 2])\n    # [B, 1]\n    num_pairs = num_unvisited * (num_unvisited - 1)\n    # [B, 1]\n    avg_dist_unvisited = sum_dist_unvisited.unsqueeze(1) / torch.max(torch.ones_like(num_pairs), num_pairs)\n\n    # 3. Combine heuristics\n    # The expected length of a path through N points is roughly (N-1) * avg_edge_length.\n    # Here, we use a combination of the 'entry cost' (from current to the unvisited set)\n    # and the 'internal cost' (path within the unvisited set).\n    # A simple heuristic is: cost_to_enter + (num_unvisited - 1) * avg_internal_dist\n    # Using average distances helps with node-count invariance and scaling.\n    # We use num_unvisited as a scaling factor.\n    estimated_future_length = avg_dist_from_current_to_unvisited + (num_unvisited - 1).clamp(min=0) * avg_dist_unvisited\n\n    # Get coordinates to calculate a bounding box diagonal as a scaling factor\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, 2]\n    min_coords, _ = coords.min(dim=1)\n    max_coords, _ = coords.max(dim=1)\n    # [B, 1]\n    diag = (max_coords - min_coords).norm(dim=1, keepdim=True)\n    \n    # Scale the estimate by the bounding box diagonal to normalize across different map scales\n    # Add a small epsilon to diag to prevent division by zero for single-node cases\n    scaled_estimate = estimated_future_length / (diag + 1e-6)\n\n    # For terminal states (all nodes visited), the future length is 0.\n    # This ensures Phi(s_T) = 0.\n    value = torch.where(is_terminal, torch.zeros_like(scaled_estimate), scaled_estimate)\n\n    return value", "stats": {"mse": 5.9315055378417965, "rmse": 2.43546823790453, "mse_tsp20": 5.9315055378417965, "rmse_tsp20": 2.43546823790453, "mse_tsp50": 55.612522440625, "rmse_tsp50": 7.457380400691989, "mse_tsp100": 258.231142884375, "rmse_tsp100": 16.069571957098763}, "stats_text": "mse=5.93151; rmse=2.43547; mse_tsp100=258.231; mse_tsp20=5.93151; mse_tsp50=55.6125; rmse_tsp100=16.0696; rmse_tsp20=2.43547; rmse_tsp50=7.45738"}
{"score": 0.08689774196943903, "gamma": 0.1, "algorithm": "auto", "code_hash": "3950d9c6da72e659adae9f19c68687de8d0537a62b1013f7f4b9931199242483", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for a Traveling Salesperson Problem (TSP) state.\n\n    This function calculates a potential value (phi) for a given state, which serves as an\n    approximation of the expected future cost (remaining tour length). The potential is\n    composed of two main components:\n    1. The cost to travel from the current node to the \"center\" of the remaining unvisited nodes.\n    2. The estimated cost to traverse the remaining unvisited nodes, modeled as the product of\n       the number of remaining edges and the average distance between unvisited nodes.\n\n    Args:\n        state (TSPStateView): A view of the current state of the TSP environment, providing\n                              access to information like node coordinates, distance matrix,\n                              and visited/unvisited masks for a batch of instances.\n\n    Returns:\n        torch.Tensor: A scalar tensor for each state in the batch, representing the\n                      estimated future tour length. The shape is broadcastable to [B, 1].\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N], boolean\n    unvisited_mask = state.unvisited_mask()\n    # [B], long\n    current_node_idx = state.current_node_index()\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # Create a safe mask for division, preventing division by zero when n_unvisited is 0 or 1.\n    # [B]\n    safe_mask = n_unvisited > 1.0\n    # [B, N]\n    safe_unvisited_mask = unvisited_mask & safe_mask.unsqueeze(-1)\n    # [B]\n    safe_n_unvisited = safe_unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # 1. Average distance from the current node to all unvisited nodes.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    # [B]\n    sum_dist_to_unvisited = (dist_from_current * unvisited_mask).sum(dim=1)\n    # [B]\n    avg_dist_to_unvisited = sum_dist_to_unvisited / torch.clamp(n_unvisited, min=1.0)\n\n    # 2. Average distance between all pairs of unvisited nodes.\n    # [B, N, N]\n    unvisited_from = safe_unvisited_mask.unsqueeze(2)\n    unvisited_to = safe_unvisited_mask.unsqueeze(1)\n    # [B, N, N], mask for pairs of unvisited nodes\n    unvisited_pair_mask = unvisited_from & unvisited_to\n    # [B]\n    sum_inter_unvisited_dist = (dist_matrix * unvisited_pair_mask).sum(dim=(1, 2))\n    # [B], number of pairs is roughly n_unvisited^2\n    num_pairs = safe_n_unvisited * safe_n_unvisited\n    # [B]\n    avg_inter_unvisited_dist = sum_inter_unvisited_dist / torch.clamp(num_pairs, min=1.0)\n\n    # Estimate remaining tour length\n    # The number of remaining edges to form a tour is n_unvisited.\n    # We use (n_unvisited - 1) as a heuristic for the number of connections needed.\n    remaining_edges = n_unvisited - 1.0\n    estimated_remaining_tour = remaining_edges * avg_inter_unvisited_dist\n\n    # Combine the two components.\n    # The final potential is the sum of the cost to get to the next node (approximated\n    # by avg_dist_to_unvisited) and the cost to tour the rest (estimated_remaining_tour).\n    value = avg_dist_to_unvisited + estimated_remaining_tour\n    \n    # Handle terminal states where n_unvisited is 0 or 1.\n    # The logic above with safe_mask handles n_unvisited <= 1 by making the second term zero.\n    # For n_unvisited == 0, avg_dist_to_unvisited is also 0.\n    # For n_unvisited == 1, avg_dist_to_unvisited is the distance to the last node.\n    # We explicitly set phi to 0 for terminal states (n_unvisited <= 1) for consistency.\n    is_terminal = n_unvisited <= 1.0\n    final_value = torch.where(is_terminal, torch.zeros_like(value), value)\n\n    return final_value.unsqueeze(-1)", "stats": {"mse": 11.5077788828125, "rmse": 3.3923117313732387, "mse_tsp20": 11.5077788828125, "rmse_tsp20": 3.3923117313732387, "mse_tsp50": 120.0043581875, "rmse_tsp50": 10.954650071430853, "mse_tsp100": 559.0822268375, "rmse_tsp100": 23.644919683464774}, "stats_text": "mse=11.5078; rmse=3.39231; mse_tsp100=559.082; mse_tsp20=11.5078; mse_tsp50=120.004; rmse_tsp100=23.6449; rmse_tsp20=3.39231; rmse_tsp50=10.9547"}
{"score": 0.07074120520662076, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {Algorithm: Calculate the expected cost by summing two components: (1) the average distance from the current node to all unvisited nodes, representing the next step's cost, and (2) the expected cost to traverse the remaining unvisited nodes, approximated by multiplying the number of remaining steps (num_unvisited - 1) by the average pairwise distance among all unvisited nodes.", "code_hash": "6237d31dbca11f5a5ae019268f650c373ab5374f87f40f348a0668cf45d19af3", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {Algorithm: Calculate the expected cost by summing two components: (1) the average distance from the current node to all unvisited nodes, representing the next step's cost, and (2) the expected cost to traverse the remaining unvisited nodes, approximated by multiplying the number of remaining steps (num_unvisited - 1) by the average pairwise distance among all unvisited nodes.}\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    num_unvisited = unvisited.float().sum(dim=1)\n    # A small epsilon to prevent division by zero when num_unvisited is 0 or 1\n    epsilon = 1e-9\n\n    # --- Component 1: Expected cost of the next step ---\n    # Gather distances from the current node: [B, N]\n    current_node_dists = dist_matrix.gather(1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    # Mask to keep only distances to unvisited nodes\n    current_to_unvisited_dists = current_node_dists * unvisited.float()\n    # Average distance from current to unvisited nodes: [B]\n    avg_dist_to_unvisited = current_to_unvisited_dists.sum(dim=1) / (num_unvisited + epsilon)\n\n    # --- Component 2: Expected cost of the remaining tour among unvisited nodes ---\n    # Create a mask for unvisited-to-unvisited pairs: [B, N, N]\n    unvisited_mask_2d = unvisited.unsqueeze(2) & unvisited.unsqueeze(1)\n    # Sum of distances between all pairs of unvisited nodes: [B]\n    total_unvisited_dist = (dist_matrix * unvisited_mask_2d.float()).sum(dim=[1, 2])\n    # Number of pairs of unvisited nodes (N * (N-1)): [B]\n    num_pairs = num_unvisited * (num_unvisited - 1)\n    # Average pairwise distance among unvisited nodes: [B]\n    avg_pairwise_dist = total_unvisited_dist / (num_pairs + epsilon)\n\n    # The number of edges remaining in the sub-tour of unvisited nodes is (num_unvisited - 1)\n    # This is because we need to connect all unvisited nodes, and then one more edge to connect back to start (handled by the environment reward)\n    # We approximate the sub-tour length with (num_unvisited - 1) * avg_pairwise_dist\n    remaining_steps = torch.clamp(num_unvisited - 1, min=0)\n    remaining_tour_cost = remaining_steps * avg_pairwise_dist\n\n    # --- Total Estimated Future Cost ---\n    # The total cost is the cost to take the next step plus the cost of the remaining sub-tour.\n    # We use a mask to set the value to 0 for terminal states (num_unvisited == 0).\n    is_not_done = (num_unvisited > 0).float()\n    value = (avg_dist_to_unvisited + remaining_tour_cost) * is_not_done\n\n    # Ensure the output shape is [B, 1]\n    return value.unsqueeze(1)", "stats": {"mse": 14.136032840820313, "rmse": 3.7597915953973184, "mse_tsp20": 14.136032840820313, "rmse_tsp20": 3.7597915953973184, "mse_tsp50": 128.437446275, "rmse_tsp50": 11.333024586358224, "mse_tsp100": 577.30365394375, "rmse_tsp100": 24.027144107108317}, "stats_text": "mse=14.136; rmse=3.75979; mse_tsp100=577.304; mse_tsp20=14.136; mse_tsp50=128.437; rmse_tsp100=24.0271; rmse_tsp20=3.75979; rmse_tsp50=11.333"}
{"score": 0.058655099719394976, "gamma": 0.1, "algorithm": "auto", "code_hash": "96a3268ca8160de2abf7f460fdd4d377097764d1be30329281e8e28d935ecc7a", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for a TSP state.\n\n    Args:\n        state: A TSPStateView object with helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, 1]\n    num_unvisited = unvisited_mask.float().sum(dim=1, keepdim=True)\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    first_node = state.first_node_index()\n\n    # Create a mask for valid distances to avoid division by zero when no nodes are unvisited\n    is_not_done = num_unvisited > 0\n    num_unvisited_safe = num_unvisited.clamp(min=1.0)\n\n    # 1. Average distance from the current node to all unvisited nodes.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    # [B, N] -> [B]\n    dist_from_current_to_unvisited = (dist_from_current * unvisited_mask.float()).sum(dim=1)\n    # [B]\n    avg_dist_to_unvisited = dist_from_current_to_unvisited / num_unvisited_safe.squeeze(1)\n\n    # 2. Average inter-node distance among unvisited nodes, scaled by the remaining tour length.\n    # Create a mask for pairs of unvisited nodes: [B, N, 1] * [B, 1, N] -> [B, N, N]\n    unvisited_pairs_mask = unvisited_mask.unsqueeze(2) * unvisited_mask.unsqueeze(1)\n    # [B, N, N] -> [B]\n    sum_inter_unvisited_dist = (dist_matrix * unvisited_pairs_mask.float()).sum(dim=[1, 2])\n    # [B]\n    num_unvisited_pairs = num_unvisited.squeeze(1) * (num_unvisited.squeeze(1) - 1)\n    # [B]\n    avg_inter_unvisited_dist = sum_inter_unvisited_dist / num_unvisited_pairs.clamp(min=1.0)\n    # [B]\n    estimated_unvisited_path_len = avg_inter_unvisited_dist * (num_unvisited.squeeze(1) - 1).clamp(min=0.0)\n\n    # 3. Distance from the current node back to the start node (approximates closing the loop).\n    # [B]\n    dist_to_start = torch.gather(dist_from_current, 1, first_node.unsqueeze(1)).squeeze(1)\n\n    # Combine the components. The final value is the sum of these estimations.\n    # We only consider these costs if the tour is not done.\n    value = (avg_dist_to_unvisited + estimated_unvisited_path_len + dist_to_start) * is_not_done.squeeze(1)\n    \n    # Ensure the output is broadcastable to [B, 1]\n    return value.unsqueeze(1)", "stats": {"mse": 17.04881595605469, "rmse": 4.129021186195911, "mse_tsp20": 17.04881595605469, "rmse_tsp20": 4.129021186195911, "mse_tsp50": 137.4622821390625, "rmse_tsp50": 11.724430994255648, "mse_tsp100": 597.1803999125, "rmse_tsp100": 24.437274805356264}, "stats_text": "mse=17.0488; rmse=4.12902; mse_tsp100=597.18; mse_tsp20=17.0488; mse_tsp50=137.462; rmse_tsp100=24.4373; rmse_tsp20=4.12902; rmse_tsp50=11.7244"}
{"score": 0.05770406997688174, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The algorithm estimates the future tour length by combining the expected distance to the next node (average distance from current to unvisited) with the estimated cost of the remaining sub-tour (average inter-node distance for unvisited nodes scaled by the number of remaining nodes).", "code_hash": "c6e9e810e91f1fd5f94481e92b67367e5e737df98b41d0d6f3a71ee61d93e325", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The algorithm estimates the future tour length by combining the expected distance to the next node (average distance from current to unvisited) with the estimated cost of the remaining sub-tour (average inter-node distance for unvisited nodes scaled by the number of remaining nodes).}\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B]\n    current_node = state.current_node_index()\n\n    # Number of unvisited nodes, [B]\n    num_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # Create a mask for terminal states (num_unvisited == 0)\n    # [B]\n    is_terminal = (num_unvisited == 0)\n\n    # 1. Estimate cost of the remaining sub-tour among unvisited nodes\n    # Mask for pairs of unvisited nodes: [B, N, 1] * [B, 1, N] -> [B, N, N]\n    unvisited_pair_mask = unvisited_mask.unsqueeze(2) & unvisited_mask.unsqueeze(1)\n    # Zero out diagonal to avoid counting self-distances\n    unvisited_pair_mask.diagonal(dim1=-2, dim2=-1).fill_(False)\n\n    # Sum of distances between all pairs of unvisited nodes, [B]\n    sum_dist_unvisited = (dist_matrix * unvisited_pair_mask).sum(dim=(1, 2)) / 2.0\n\n    # Average distance between unvisited nodes\n    # Number of pairs: N_unvisited * (N_unvisited - 1) / 2\n    num_pairs = num_unvisited * (num_unvisited - 1) / 2.0\n    # Avoid division by zero when num_unvisited <= 1, [B]\n    avg_dist_unvisited = torch.nan_to_num(sum_dist_unvisited / (num_pairs + 1e-9))\n\n    # Estimated cost of the sub-tour is (num_unvisited) * avg_dist_unvisited\n    # When num_unvisited is 1, this is 0. When 0, also 0.\n    subtour_cost = (num_unvisited) * avg_dist_unvisited\n\n    # 2. Estimate cost to connect current tour to the remaining sub-tour\n    # [B, N]\n    current_idx_expanded = current_node.unsqueeze(1)\n    # [B, N]\n    dist_from_current = dist_matrix.gather(1, current_idx_expanded.unsqueeze(2).expand(-1, -1, dist_matrix.size(2))).squeeze(1)\n\n    # Sum of distances from current node to all unvisited nodes, [B]\n    sum_dist_from_current_to_unvisited = (dist_from_current * unvisited_mask).sum(dim=1)\n    # Average distance, avoiding division by zero, [B]\n    avg_dist_to_next = torch.nan_to_num(sum_dist_from_current_to_unvisited / (num_unvisited + 1e-9))\n\n    # 3. Combine costs\n    # Total estimated future cost, [B]\n    future_cost = subtour_cost + avg_dist_to_next\n\n    # For terminal states, the future cost is exactly 0.\n    # This handles the case where the tour is complete but not returned to start.\n    # The environment reward will handle the final edge cost.\n    value = torch.where(is_terminal, torch.zeros_like(future_cost), future_cost)\n\n    return value.unsqueeze(1)", "stats": {"mse": 17.329800140625, "rmse": 4.162907654587716, "mse_tsp20": 17.329800140625, "rmse_tsp20": 4.162907654587716, "mse_tsp50": 137.470576159375, "rmse_tsp50": 11.724784695651133, "mse_tsp100": 596.15406229375, "rmse_tsp100": 24.4162663463059}, "stats_text": "mse=17.3298; rmse=4.16291; mse_tsp100=596.154; mse_tsp20=17.3298; mse_tsp50=137.471; rmse_tsp100=24.4163; rmse_tsp20=4.16291; rmse_tsp50=11.7248"}
{"score": 0.04812838813494761, "gamma": 1.0, "algorithm": "auto", "code_hash": "50dcd093dd12b92fd0b2636561caf4c7da89b61f13eef279de583aec6eb021ac", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (negative value) for the TSP environment.\n    The value is estimated based on the connectivity of the remaining unvisited nodes\n    and the distance to the next likely node.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n\n    Returns:\n        torch.Tensor: A scalar potential value for each state in the batch, shape [B, 1].\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, N, 1]\n    unvisited_mask_from = unvisited_mask.unsqueeze(2)\n    # [B, 1, N]\n    unvisited_mask_to = unvisited_mask.unsqueeze(1)\n    # [B, N, N], boolean mask for edges between unvisited nodes\n    unvisited_to_unvisited_mask = unvisited_mask_from & unvisited_mask_to\n\n    # Set distances for invalid (visited-involved) connections to a large value\n    # so they are ignored by the min operation.\n    large_value = 1e9\n    # [B, N, N]\n    dists_unvisited = torch.where(\n        unvisited_to_unvisited_mask,\n        dist_matrix,\n        torch.full_like(dist_matrix, large_value)\n    )\n\n    # For each unvisited node, find the minimum distance to another unvisited node.\n    # We set the diagonal to a large value to avoid picking the node itself (dist=0).\n    # [B, N]\n    diag_mask = torch.eye(dist_matrix.size(1), device=dist_matrix.device).unsqueeze(0)\n    dists_unvisited = torch.where(diag_mask, large_value, dists_unvisited)\n    # [B, N], min dist from each node `i` to any other unvisited node `j`\n    min_dists, _ = torch.min(dists_unvisited, dim=2)\n\n    # Sum these minimum distances only for the unvisited nodes.\n    # [B]\n    sum_min_dists = torch.sum(min_dists * unvisited_mask, dim=1)\n\n    # Get the number of unvisited nodes. Add a small epsilon to avoid division by zero.\n    # [B]\n    n_unvisited = torch.sum(unvisited_mask, dim=1).float()\n    \n    # Calculate the average minimum distance between unvisited nodes.\n    # This represents the expected cost per hop in the remainder of the tour.\n    # [B]\n    avg_min_dist = sum_min_dists / torch.clamp(n_unvisited, min=1.0)\n    \n    # Estimate the total remaining path length based on this average.\n    # [B]\n    remaining_path_estimate = avg_min_dist * n_unvisited\n\n    # Add the cost to get from the current node to the nearest unvisited node.\n    # [B]\n    current_node = state.current_node_index()\n    # [B, N]\n    dists_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    # [B, N]\n    dists_from_current_to_unvisited = torch.where(\n        unvisited_mask,\n        dists_from_current,\n        torch.full_like(dists_from_current, large_value)\n    )\n    # [B]\n    min_dist_to_next, _ = torch.min(dists_from_current_to_unvisited, dim=1)\n    \n    # If there are no unvisited nodes, this distance is inf. Set it to 0.\n    # [B]\n    is_done = (n_unvisited == 0)\n    min_dist_to_next = torch.where(is_done, 0.0, min_dist_to_next)\n\n    # The final potential is the sum of the estimated remaining path and the immediate next step.\n    # The negative sign is because rewards are negative distances.\n    # [B]\n    value = -(remaining_path_estimate + min_dist_to_next)\n    \n    # Ensure terminal states (and states with 1 unvisited node, which is the last step) have a potential of 0.\n    # This helps with terminal consistency.\n    is_terminal_or_near_terminal = (n_unvisited <= 1)\n    value = torch.where(is_terminal_or_near_terminal, 0.0, value)\n\n    return value.unsqueeze(1)", "stats": {"mse": 20.777757966796877, "rmse": 4.558262603974992, "mse_tsp20": 20.777757966796877, "rmse_tsp20": 4.558262603974992, "mse_tsp50": 40.76918255703125, "rmse_tsp50": 6.385074984448597, "mse_tsp100": 73.389741278125, "rmse_tsp100": 8.566781267087716}, "stats_text": "mse=20.7778; rmse=4.55826; mse_tsp100=73.3897; mse_tsp20=20.7778; mse_tsp50=40.7692; rmse_tsp100=8.56678; rmse_tsp20=4.55826; rmse_tsp50=6.38507"}
{"score": 0.012843472926228384, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (Monte Carlo value V(state)) for the TSP environment. {My algorithm calculates the expected cost-to-go by summing two components: (1) the average distance from the current node to all unvisited nodes, representing the next step's expected cost, and (2) the expected cost of the remaining sub-tour, approximated by the number of remaining edges multiplied by the average pairwise distance between all unvisited nodes.", "code_hash": "fb7bdab678a355c5b634ad50ffb00335f41a66d8901f0875375b428e57a8e79e", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (Monte Carlo value V(state)) for the TSP environment.\n    {My algorithm calculates the expected cost-to-go by summing two components: (1) the average distance from the current node to all unvisited nodes, representing the next step's expected cost, and (2) the expected cost of the remaining sub-tour, approximated by the number of remaining edges multiplied by the average pairwise distance between all unvisited nodes.}\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar potential value for each state in the batch, shape [B, 1].\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B, 1, N]\n    current_node_exp = current_node.unsqueeze(-1).unsqueeze(-1).expand(-1, 1, dist_matrix.size(2))\n\n    # Number of unvisited nodes, [B]\n    num_unvisited = unvisited.sum(dim=1, dtype=torch.float32)\n\n    # Avoid division by zero for terminal states (num_unvisited can be 0 or 1)\n    # If num_unvisited is 0 or 1, the future path length is 0.\n    is_not_terminal = (num_unvisited > 1.0)\n    safe_num_unvisited = torch.where(is_not_terminal, num_unvisited, torch.ones_like(num_unvisited))\n    safe_num_unvisited_pairs = torch.where(is_not_terminal, num_unvisited * (num_unvisited - 1) / 2.0, torch.ones_like(num_unvisited))\n\n    # 1. Cost from current node to the next unvisited node (approximate)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_exp)\n    # [B, N]\n    dist_from_current_squeezed = dist_from_current.squeeze(1)\n    # Set distances to visited nodes to 0 to exclude them from the sum\n    dist_from_current_to_unvisited = dist_from_current_squeezed * unvisited\n    # [B]\n    sum_dist_to_unvisited = dist_from_current_to_unvisited.sum(dim=1)\n    # [B], average distance to an unvisited node\n    avg_dist_to_next = sum_dist_to_unvisited / safe_num_unvisited\n\n    # 2. Cost of the remaining sub-tour among unvisited nodes (approximate)\n    # Create a mask for pairs of unvisited nodes\n    # [B, N, 1] * [B, 1, N] -> [B, N, N]\n    unvisited_pair_mask = unvisited.unsqueeze(2) * unvisited.unsqueeze(1)\n    # [B, N, N], distances between unvisited nodes\n    sub_tour_dists = dist_matrix * unvisited_pair_mask\n    # [B], sum of distances between all pairs of unvisited nodes (upper triangle)\n    sum_pairwise_dist_unvisited = sub_tour_dists.sum(dim=[1, 2]) / 2.0\n    # [B], average distance between any two unvisited nodes\n    avg_pairwise_dist = sum_pairwise_dist_unvisited / safe_num_unvisited_pairs\n\n    # The number of edges in the remaining tour is (num_unvisited - 1)\n    # We add 1 to connect back to the start, but let's use num_unvisited as an approximation\n    # for the number of \"steps\" or edges remaining.\n    remaining_edges = num_unvisited - 1.0\n    \n    # Approximate cost of the remaining sub-tour\n    # Using num_unvisited instead of remaining_edges as it seems more stable\n    remaining_tour_cost = num_unvisited * avg_pairwise_dist\n\n    # Total estimated future cost\n    # We negate because the environment uses negative distances as rewards.\n    # Phi should be an estimate of V, which is the sum of future rewards (negative lengths).\n    # So, V is negative. We return a negative value.\n    value = -(avg_dist_to_next + remaining_tour_cost)\n\n    # For terminal states, future cost is 0.\n    final_value = torch.where(is_not_terminal, value, torch.zeros_like(value))\n\n    return final_value.unsqueeze(-1)", "stats": {"mse": 77.8605604375, "rmse": 8.823863124363386, "mse_tsp20": 77.8605604375, "rmse_tsp20": 8.823863124363386, "mse_tsp50": 340.59652695625, "rmse_tsp50": 18.455257434028116, "mse_tsp100": 1123.295391975, "rmse_tsp100": 33.51559923341667}, "stats_text": "mse=77.8606; rmse=8.82386; mse_tsp100=1123.3; mse_tsp20=77.8606; mse_tsp50=340.597; rmse_tsp100=33.5156; rmse_tsp20=8.82386; rmse_tsp50=18.4553"}
{"score": 0.006395243986950299, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The potential is estimated by summing two components: the average distance from the current node to all unvisited nodes, and the average distance from all unvisited nodes back to the start node, with both components scaled by the number of remaining nodes to approximate the total path length of the remaining sub-tour.", "code_hash": "098cffc5646f2d78d70fba303d3a95ed9104ca4e1798e43c3f466db5b2b1130c", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The potential is estimated by summing two components: the average distance from the current node to all unvisited nodes, and the average distance from all unvisited nodes back to the start node, with both components scaled by the number of remaining nodes to approximate the total path length of the remaining sub-tour.}\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # Get batch size and number of nodes\n    B, N, _ = state.distance_matrix().shape\n\n    # Get masks for unvisited nodes\n    unvisited_mask = state.unvisited_mask() # [B, N]\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True).float() # [B, 1]\n\n    # Get distance matrix\n    dist_matrix = state.distance_matrix() # [B, N, N]\n\n    # Get current and start node indices\n    current_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N) # [B, 1, N]\n    start_idx = state.first_node_index().view(B, 1, 1).expand(-1, N, 1) # [B, N, 1]\n\n    # Component 1: Average distance from current node to all unvisited nodes\n    # dist_from_current is [B, N], representing dist(current, i) for all i\n    dist_from_current = torch.gather(dist_matrix, 1, current_idx).squeeze(1) # [B, N]\n    # Mask out visited nodes and sum distances to unvisited nodes\n    sum_dist_from_current_to_unvisited = (dist_from_current * unvisited_mask).sum(dim=1, keepdim=True) # [B, 1]\n    # Avoid division by zero when all nodes are visited\n    safe_num_unvisited = num_unvisited.clamp(min=1.0)\n    avg_dist_from_current = sum_dist_from_current_to_unvisited / safe_num_unvisited # [B, 1]\n\n    # Component 2: Average distance from all unvisited nodes to the start node\n    # dist_to_start is [B, N], representing dist(i, start) for all i\n    dist_to_start = torch.gather(dist_matrix, 2, start_idx).squeeze(2) # [B, N]\n    # Mask out visited nodes and sum distances from unvisited nodes\n    sum_dist_from_unvisited_to_start = (dist_to_start * unvisited_mask).sum(dim=1, keepdim=True) # [B, 1]\n    avg_dist_to_start = sum_dist_from_unvisited_to_start / safe_num_unvisited # [B, 1]\n\n    # Estimate future path length. The number of remaining edges is (num_unvisited + 1).\n    # We use num_unvisited as a simpler scaling factor.\n    # The logic is: (avg cost from current to next) + (num_unvisited-1)*(avg cost between unvisited) + (avg cost from last to start)\n    # This is approximated by scaling the average distances.\n    # The scaling factor `num_unvisited` represents the number of remaining \"steps\" or edges.\n    # The first term represents the cost of the next step, and the second represents the cost of returning home eventually.\n    # We use all_node_coords() to get N for scaling, making it more robust.\n    # A small constant is added to the scaling to prevent the potential from being exactly zero when only one node is left.\n    tour_length_scale = (state.all_node_coords().shape[1] / 20.0).sqrt() # Heuristic scale based on N\n    \n    # The potential is the sum of the scaled average distances.\n    # The first term estimates the cost of visiting all unvisited nodes from the current location.\n    # The second term estimates the cost of returning from the \"center of mass\" of unvisited nodes to the start.\n    # Multiplying by num_unvisited approximates the total length of these remaining segments.\n    # Adding 1 to num_unvisited accounts for the final edge back to the start.\n    remaining_edges = num_unvisited\n    \n    # We use a simpler heuristic: cost is proportional to the number of remaining nodes\n    # and the average distance to them from current and from them to start.\n    potential = (avg_dist_from_current + avg_dist_to_start) * remaining_edges * tour_length_scale\n\n    # The potential should be zero when the tour is complete (num_unvisited == 0).\n    # The calculation naturally handles this as num_unvisited becomes 0.\n    return potential.detach()", "stats": {"mse": 156.36619995117186, "rmse": 12.504647134212618, "mse_tsp20": 156.36619995117186, "rmse_tsp20": 12.504647134212618, "mse_tsp50": 2104.049633679883, "rmse_tsp50": 45.86992079434935, "mse_tsp100": 16240.498291789843, "rmse_tsp100": 127.43821362444564}, "stats_text": "mse=156.366; rmse=12.5046; mse_tsp100=16240.5; mse_tsp20=156.366; mse_tsp50=2104.05; rmse_tsp100=127.438; rmse_tsp20=12.5046; rmse_tsp50=45.8699"}
{"score": 2.1666411957501115, "gamma": 1.0, "algorithm": "auto", "code_hash": "215a9bb222ba5cb837cab1ca242841eb364c178adfc78eeff4dc565d3e0b0870", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for a TSP state.\n\n    The potential is calculated as the sum of two components:\n    1. The cost to travel from the current node to the nearest unvisited node.\n    2. An estimate of the cost to complete the tour through the remaining unvisited nodes.\n       This is approximated by summing, for each unvisited node, the minimum distance\n       to any *other* unvisited node. This serves as a rough lower bound on the\n       remaining tour length, similar to an MST-based heuristic but simpler to compute\n       and differentiable.\n\n    Args:\n        state: A TSPStateView object providing access to the environment state.\n\n    Returns:\n        A tensor of shape [B, 1] representing the estimated future cost for each state in the batch.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n\n    # Create a mask for valid destinations: must be unvisited.\n    # [B, N] -> [B, 1, N]\n    unvisited_mask_from = unvisited_mask.unsqueeze(1)\n    # [B, N] -> [B, N, 1]\n    unvisited_mask_to = unvisited_mask.unsqueeze(2)\n\n    # Component 1: Distance from the current node to the nearest unvisited node.\n    # Get distances from the current node: [B, N]\n    current_dists = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    # Apply mask to consider only unvisited destinations\n    current_dists_masked = torch.where(unvisited_mask, current_dists, torch.full_like(current_dists, float('inf')))\n    # Find the minimum distance to an unvisited node.\n    # If no nodes are unvisited (terminal state), this will be inf, which we handle.\n    min_dist_to_unvisited = torch.min(current_dists_masked, dim=1, keepdim=True).values\n\n    # Component 2: Estimated cost for the remaining tour of unvisited nodes.\n    # Create a distance matrix containing only edges between unvisited nodes.\n    # [B, N, N]\n    unvisited_dist_matrix = dist_matrix.where(unvisited_mask_from & unvisited_mask_to, torch.full_like(dist_matrix, float('inf')))\n    # To prevent a node from connecting to itself, set the diagonal to infinity.\n    # This is crucial for finding the minimum distance to *another* unvisited node.\n    # This is redundant since dist_matrix diagonal is 0, but good for clarity.\n    unvisited_dist_matrix.diagonal(dim1=-2, dim2=-1).fill_(float('inf'))\n\n    # For each unvisited node (row), find the minimum distance to any other unvisited node (column).\n    # [B, N]\n    min_dists_from_unvisited, _ = torch.min(unvisited_dist_matrix, dim=2)\n    # Zero out the values for nodes that have already been visited.\n    min_dists_from_unvisited = torch.where(unvisited_mask, min_dists_from_unvisited, 0.0)\n    # Sum these minimum distances to get an estimate of the remaining tour cost.\n    # [B, 1]\n    remaining_tour_cost_estimate = min_dists_from_unvisited.sum(dim=1, keepdim=True)\n\n    # Total potential is the sum of the two components.\n    # For terminal states, unvisited_mask is all False.\n    # min_dist_to_unvisited will be inf, and remaining_tour_cost_estimate will be 0.\n    # We want phi to be 0 at terminal states.\n    value = min_dist_to_unvisited + remaining_tour_cost_estimate\n\n    # Handle terminal states: if there are no unvisited nodes, the potential should be 0.\n    # `torch.any(unvisited_mask, dim=1)` is True if there's at least one unvisited node.\n    is_not_terminal = torch.any(unvisited_mask, dim=1, keepdim=True)\n    value = torch.where(is_not_terminal, value, 0.0)\n\n    return value", "stats": {"mse": 0.46154388735961915, "rmse": 0.6793702137712686, "mse_tsp20": 0.46154388735961915, "rmse_tsp20": 0.6793702137712686, "mse_tsp50": 1.1061160279785156, "rmse_tsp50": 1.0517205084900245, "mse_tsp100": 2.0727887998291017, "rmse_tsp100": 1.4397183057213316}, "stats_text": "mse=0.461544; rmse=0.67937; mse_tsp100=2.07279; mse_tsp20=0.461544; mse_tsp50=1.10612; rmse_tsp100=1.43972; rmse_tsp20=0.67937; rmse_tsp50=1.05172"}
{"score": 0.18060325893333726, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" {Estimate future tour length by finding the minimum distance from each unvisited node to any other available node (unvisited or current), summing these minimums, and scaling by the log of remaining nodes.", "code_hash": "f4046de7de2b1d04b827c811d4bd9c27f6c48154a814762acb33f2134cabbab6", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {Estimate future tour length by finding the minimum distance from each unvisited node to any other available node (unvisited or current), summing these minimums, and scaling by the log of remaining nodes.}\n    Args:\n        state: TSPStateView with batch dimension B and N nodes.\n    Returns:\n        A tensor of shape [B, 1] representing the estimated future cost (negative value).\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, 1, N]\n    unvisited_mask_from = unvisited_mask.unsqueeze(1)\n    # [B, N, 1]\n    unvisited_mask_to = unvisited_mask.unsqueeze(2)\n    # [B, N]\n    current_node = state.current_node_index()\n    # [B, N]\n    current_mask = torch.zeros_like(unvisited_mask).scatter_(1, current_node.unsqueeze(1), 1)\n    # [B, N, 1]\n    current_mask_to = current_mask.unsqueeze(2)\n    \n    # [B, N, 1] mask for valid 'to' nodes (unvisited or current)\n    # This allows connecting from an unvisited node to any other unvisited node or back to the current one.\n    available_to_mask = unvisited_mask_to | current_mask_to\n    \n    # [B, N, N] mask for valid connections: from unvisited to available\n    valid_connections_mask = unvisited_mask_from & available_to_mask\n    \n    # Set distances for invalid connections to a large value\n    large_value = 1e9\n    masked_dist = torch.where(valid_connections_mask, dist_matrix, large_value)\n    \n    # For each unvisited node ('from' node), find the minimum distance to any available 'to' node\n    # [B, N]\n    min_dist_from_unvisited, _ = torch.min(masked_dist, dim=2)\n    \n    # Sum these minimum distances, but only for the unvisited nodes.\n    # We set the distances for already visited nodes to 0 so they don't contribute to the sum.\n    min_dist_from_unvisited = torch.where(unvisited_mask, min_dist_from_unvisited, 0.0)\n    # [B]\n    sum_of_min_dists = torch.sum(min_dist_from_unvisited, dim=1)\n    \n    # [B]\n    num_unvisited = torch.sum(unvisited_mask, dim=1, dtype=torch.float32)\n    \n    # Scale the sum by a factor related to the number of remaining nodes.\n    # Using log helps to moderate the scaling effect as the tour progresses.\n    # Add 1.0 to avoid log(0) and log(1)=0 which would zero out the potential.\n    # Adding 1.0 to num_unvisited ensures the scaler is > 0.\n    scaler = torch.log1p(num_unvisited)\n    \n    # The potential is the scaled sum of minimum distances.\n    # It represents an optimistic estimate of the remaining path length.\n    # [B]\n    potential = sum_of_min_dists * scaler\n    \n    # The value function V is the negative of the cost-to-go.\n    # Since phi approximates cost-to-go, we return its negative.\n    # [B, 1]\n    value = -potential.unsqueeze(1)\n    \n    return value", "stats": {"mse": 5.536998645019532, "rmse": 2.353082796040023, "mse_tsp20": 5.536998645019532, "rmse_tsp20": 2.353082796040023, "mse_tsp50": 11.536133884179687, "rmse_tsp50": 3.3964884637195056, "mse_tsp100": 21.014083251171876, "rmse_tsp100": 4.584112046097028}, "stats_text": "mse=5.537; rmse=2.35308; mse_tsp100=21.0141; mse_tsp20=5.537; mse_tsp50=11.5361; rmse_tsp100=4.58411; rmse_tsp20=2.35308; rmse_tsp50=3.39649"}
{"score": 0.16859126129448987, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" {My algorithm estimates the future tour length by combining the average distance from the current node to all unvisited nodes with the average pairwise distance among all unvisited nodes, scaled by the number of remaining nodes.", "code_hash": "c0011dfdd305034a0384e65a10dd8a1d5dee9f227e2038e32c18321acaf3c85d", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    {My algorithm estimates the future tour length by combining the average distance from the current node to all unvisited nodes with the average pairwise distance among all unvisited nodes, scaled by the number of remaining nodes.}\n    Args:\n        state: A TSPStateView object with batch-friendly helpers.\n    Returns:\n        value: A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B, 1]\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True).float()\n\n    # Create a mask for visited nodes to handle the terminal state gracefully\n    # [B, N]\n    visited_mask = ~unvisited_mask\n    # [B, 1]\n    is_terminal = (num_unvisited == 0)\n\n    # 1. Average distance from the current node to all unvisited nodes\n    # [B, 1, N]\n    current_node_exp = current_node.unsqueeze(1).unsqueeze(2).expand(-1, 1, dist_matrix.shape[2])\n    # [B, N]\n    dist_from_current = dist_matrix.gather(1, current_node_exp).squeeze(1)\n    \n    # Apply mask and sum\n    # [B]\n    sum_dist_from_current_to_unvisited = (dist_from_current * unvisited_mask).sum(dim=1)\n    # [B, 1]\n    avg_dist_from_current_to_unvisited = sum_dist_from_current_to_unvisited.unsqueeze(1) / torch.max(torch.ones_like(num_unvisited), num_unvisited)\n\n    # 2. Average pairwise distance among all unvisited nodes\n    # [B, N, N]\n    unvisited_pairwise_mask = unvisited_mask.unsqueeze(2) * unvisited_mask.unsqueeze(1)\n    # Set diagonal to False to avoid self-distances\n    unvisited_pairwise_mask.diagonal(dim1=-2, dim2=-1).fill_(False)\n    \n    # [B]\n    sum_dist_unvisited = (dist_matrix * unvisited_pairwise_mask).sum(dim=[1, 2])\n    # [B, 1]\n    num_pairs = num_unvisited * (num_unvisited - 1)\n    # [B, 1]\n    avg_dist_unvisited = sum_dist_unvisited.unsqueeze(1) / torch.max(torch.ones_like(num_pairs), num_pairs)\n\n    # 3. Combine heuristics\n    # The expected length of a path through N points is roughly (N-1) * avg_edge_length.\n    # Here, we use a combination of the 'entry cost' (from current to the unvisited set)\n    # and the 'internal cost' (path within the unvisited set).\n    # A simple heuristic is: cost_to_enter + (num_unvisited - 1) * avg_internal_dist\n    # Using average distances helps with node-count invariance and scaling.\n    # We use num_unvisited as a scaling factor.\n    estimated_future_length = avg_dist_from_current_to_unvisited + (num_unvisited - 1).clamp(min=0) * avg_dist_unvisited\n\n    # Get coordinates to calculate a bounding box diagonal as a scaling factor\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, 2]\n    min_coords, _ = coords.min(dim=1)\n    max_coords, _ = coords.max(dim=1)\n    # [B, 1]\n    diag = (max_coords - min_coords).norm(dim=1, keepdim=True)\n    \n    # Scale the estimate by the bounding box diagonal to normalize across different map scales\n    # Add a small epsilon to diag to prevent division by zero for single-node cases\n    scaled_estimate = estimated_future_length / (diag + 1e-6)\n\n    # For terminal states (all nodes visited), the future length is 0.\n    # This ensures Phi(s_T) = 0.\n    value = torch.where(is_terminal, torch.zeros_like(scaled_estimate), scaled_estimate)\n\n    return value", "stats": {"mse": 5.9315055378417965, "rmse": 2.43546823790453, "mse_tsp20": 5.9315055378417965, "rmse_tsp20": 2.43546823790453, "mse_tsp50": 55.612522440625, "rmse_tsp50": 7.457380400691989, "mse_tsp100": 258.231142884375, "rmse_tsp100": 16.069571957098763}, "stats_text": "mse=5.93151; rmse=2.43547; mse_tsp100=258.231; mse_tsp20=5.93151; mse_tsp50=55.6125; rmse_tsp100=16.0696; rmse_tsp20=2.43547; rmse_tsp50=7.45738"}
{"score": 0.08689774196943903, "gamma": 0.1, "algorithm": "auto", "code_hash": "3950d9c6da72e659adae9f19c68687de8d0537a62b1013f7f4b9931199242483", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length for a Traveling Salesperson Problem (TSP) state.\n\n    This function calculates a potential value (phi) for a given state, which serves as an\n    approximation of the expected future cost (remaining tour length). The potential is\n    composed of two main components:\n    1. The cost to travel from the current node to the \"center\" of the remaining unvisited nodes.\n    2. The estimated cost to traverse the remaining unvisited nodes, modeled as the product of\n       the number of remaining edges and the average distance between unvisited nodes.\n\n    Args:\n        state (TSPStateView): A view of the current state of the TSP environment, providing\n                              access to information like node coordinates, distance matrix,\n                              and visited/unvisited masks for a batch of instances.\n\n    Returns:\n        torch.Tensor: A scalar tensor for each state in the batch, representing the\n                      estimated future tour length. The shape is broadcastable to [B, 1].\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N], boolean\n    unvisited_mask = state.unvisited_mask()\n    # [B], long\n    current_node_idx = state.current_node_index()\n\n    # Number of unvisited nodes, [B]\n    n_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # Create a safe mask for division, preventing division by zero when n_unvisited is 0 or 1.\n    # [B]\n    safe_mask = n_unvisited > 1.0\n    # [B, N]\n    safe_unvisited_mask = unvisited_mask & safe_mask.unsqueeze(-1)\n    # [B]\n    safe_n_unvisited = safe_unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # 1. Average distance from the current node to all unvisited nodes.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_idx.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    # [B]\n    sum_dist_to_unvisited = (dist_from_current * unvisited_mask).sum(dim=1)\n    # [B]\n    avg_dist_to_unvisited = sum_dist_to_unvisited / torch.clamp(n_unvisited, min=1.0)\n\n    # 2. Average distance between all pairs of unvisited nodes.\n    # [B, N, N]\n    unvisited_from = safe_unvisited_mask.unsqueeze(2)\n    unvisited_to = safe_unvisited_mask.unsqueeze(1)\n    # [B, N, N], mask for pairs of unvisited nodes\n    unvisited_pair_mask = unvisited_from & unvisited_to\n    # [B]\n    sum_inter_unvisited_dist = (dist_matrix * unvisited_pair_mask).sum(dim=(1, 2))\n    # [B], number of pairs is roughly n_unvisited^2\n    num_pairs = safe_n_unvisited * safe_n_unvisited\n    # [B]\n    avg_inter_unvisited_dist = sum_inter_unvisited_dist / torch.clamp(num_pairs, min=1.0)\n\n    # Estimate remaining tour length\n    # The number of remaining edges to form a tour is n_unvisited.\n    # We use (n_unvisited - 1) as a heuristic for the number of connections needed.\n    remaining_edges = n_unvisited - 1.0\n    estimated_remaining_tour = remaining_edges * avg_inter_unvisited_dist\n\n    # Combine the two components.\n    # The final potential is the sum of the cost to get to the next node (approximated\n    # by avg_dist_to_unvisited) and the cost to tour the rest (estimated_remaining_tour).\n    value = avg_dist_to_unvisited + estimated_remaining_tour\n    \n    # Handle terminal states where n_unvisited is 0 or 1.\n    # The logic above with safe_mask handles n_unvisited <= 1 by making the second term zero.\n    # For n_unvisited == 0, avg_dist_to_unvisited is also 0.\n    # For n_unvisited == 1, avg_dist_to_unvisited is the distance to the last node.\n    # We explicitly set phi to 0 for terminal states (n_unvisited <= 1) for consistency.\n    is_terminal = n_unvisited <= 1.0\n    final_value = torch.where(is_terminal, torch.zeros_like(value), value)\n\n    return final_value.unsqueeze(-1)", "stats": {"mse": 11.5077788828125, "rmse": 3.3923117313732387, "mse_tsp20": 11.5077788828125, "rmse_tsp20": 3.3923117313732387, "mse_tsp50": 120.0043581875, "rmse_tsp50": 10.954650071430853, "mse_tsp100": 559.0822268375, "rmse_tsp100": 23.644919683464774}, "stats_text": "mse=11.5078; rmse=3.39231; mse_tsp100=559.082; mse_tsp20=11.5078; mse_tsp50=120.004; rmse_tsp100=23.6449; rmse_tsp20=3.39231; rmse_tsp50=10.9547"}
{"score": 0.07074120520662076, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {Algorithm: Calculate the expected cost by summing two components: (1) the average distance from the current node to all unvisited nodes, representing the next step's cost, and (2) the expected cost to traverse the remaining unvisited nodes, approximated by multiplying the number of remaining steps (num_unvisited - 1) by the average pairwise distance among all unvisited nodes.", "code_hash": "6237d31dbca11f5a5ae019268f650c373ab5374f87f40f348a0668cf45d19af3", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {Algorithm: Calculate the expected cost by summing two components: (1) the average distance from the current node to all unvisited nodes, representing the next step's cost, and (2) the expected cost to traverse the remaining unvisited nodes, approximated by multiplying the number of remaining steps (num_unvisited - 1) by the average pairwise distance among all unvisited nodes.}\n    Args:\n        state: A TSPStateView object with batch-friendly helper methods.\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    num_unvisited = unvisited.float().sum(dim=1)\n    # A small epsilon to prevent division by zero when num_unvisited is 0 or 1\n    epsilon = 1e-9\n\n    # --- Component 1: Expected cost of the next step ---\n    # Gather distances from the current node: [B, N]\n    current_node_dists = dist_matrix.gather(1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    # Mask to keep only distances to unvisited nodes\n    current_to_unvisited_dists = current_node_dists * unvisited.float()\n    # Average distance from current to unvisited nodes: [B]\n    avg_dist_to_unvisited = current_to_unvisited_dists.sum(dim=1) / (num_unvisited + epsilon)\n\n    # --- Component 2: Expected cost of the remaining tour among unvisited nodes ---\n    # Create a mask for unvisited-to-unvisited pairs: [B, N, N]\n    unvisited_mask_2d = unvisited.unsqueeze(2) & unvisited.unsqueeze(1)\n    # Sum of distances between all pairs of unvisited nodes: [B]\n    total_unvisited_dist = (dist_matrix * unvisited_mask_2d.float()).sum(dim=[1, 2])\n    # Number of pairs of unvisited nodes (N * (N-1)): [B]\n    num_pairs = num_unvisited * (num_unvisited - 1)\n    # Average pairwise distance among unvisited nodes: [B]\n    avg_pairwise_dist = total_unvisited_dist / (num_pairs + epsilon)\n\n    # The number of edges remaining in the sub-tour of unvisited nodes is (num_unvisited - 1)\n    # This is because we need to connect all unvisited nodes, and then one more edge to connect back to start (handled by the environment reward)\n    # We approximate the sub-tour length with (num_unvisited - 1) * avg_pairwise_dist\n    remaining_steps = torch.clamp(num_unvisited - 1, min=0)\n    remaining_tour_cost = remaining_steps * avg_pairwise_dist\n\n    # --- Total Estimated Future Cost ---\n    # The total cost is the cost to take the next step plus the cost of the remaining sub-tour.\n    # We use a mask to set the value to 0 for terminal states (num_unvisited == 0).\n    is_not_done = (num_unvisited > 0).float()\n    value = (avg_dist_to_unvisited + remaining_tour_cost) * is_not_done\n\n    # Ensure the output shape is [B, 1]\n    return value.unsqueeze(1)", "stats": {"mse": 14.136032840820313, "rmse": 3.7597915953973184, "mse_tsp20": 14.136032840820313, "rmse_tsp20": 3.7597915953973184, "mse_tsp50": 128.437446275, "rmse_tsp50": 11.333024586358224, "mse_tsp100": 577.30365394375, "rmse_tsp100": 24.027144107108317}, "stats_text": "mse=14.136; rmse=3.75979; mse_tsp100=577.304; mse_tsp20=14.136; mse_tsp50=128.437; rmse_tsp100=24.0271; rmse_tsp20=3.75979; rmse_tsp50=11.333"}
{"score": 0.058655099719394976, "gamma": 0.1, "algorithm": "auto", "code_hash": "96a3268ca8160de2abf7f460fdd4d377097764d1be30329281e8e28d935ecc7a", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for a TSP state.\n\n    Args:\n        state: A TSPStateView object with helper methods.\n\n    Returns:\n        A torch tensor of shape [B, 1] representing the estimated future cost.\n    \"\"\"\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, 1]\n    num_unvisited = unvisited_mask.float().sum(dim=1, keepdim=True)\n    # [B]\n    current_node = state.current_node_index()\n    # [B]\n    first_node = state.first_node_index()\n\n    # Create a mask for valid distances to avoid division by zero when no nodes are unvisited\n    is_not_done = num_unvisited > 0\n    num_unvisited_safe = num_unvisited.clamp(min=1.0)\n\n    # 1. Average distance from the current node to all unvisited nodes.\n    # [B, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    # [B, N] -> [B]\n    dist_from_current_to_unvisited = (dist_from_current * unvisited_mask.float()).sum(dim=1)\n    # [B]\n    avg_dist_to_unvisited = dist_from_current_to_unvisited / num_unvisited_safe.squeeze(1)\n\n    # 2. Average inter-node distance among unvisited nodes, scaled by the remaining tour length.\n    # Create a mask for pairs of unvisited nodes: [B, N, 1] * [B, 1, N] -> [B, N, N]\n    unvisited_pairs_mask = unvisited_mask.unsqueeze(2) * unvisited_mask.unsqueeze(1)\n    # [B, N, N] -> [B]\n    sum_inter_unvisited_dist = (dist_matrix * unvisited_pairs_mask.float()).sum(dim=[1, 2])\n    # [B]\n    num_unvisited_pairs = num_unvisited.squeeze(1) * (num_unvisited.squeeze(1) - 1)\n    # [B]\n    avg_inter_unvisited_dist = sum_inter_unvisited_dist / num_unvisited_pairs.clamp(min=1.0)\n    # [B]\n    estimated_unvisited_path_len = avg_inter_unvisited_dist * (num_unvisited.squeeze(1) - 1).clamp(min=0.0)\n\n    # 3. Distance from the current node back to the start node (approximates closing the loop).\n    # [B]\n    dist_to_start = torch.gather(dist_from_current, 1, first_node.unsqueeze(1)).squeeze(1)\n\n    # Combine the components. The final value is the sum of these estimations.\n    # We only consider these costs if the tour is not done.\n    value = (avg_dist_to_unvisited + estimated_unvisited_path_len + dist_to_start) * is_not_done.squeeze(1)\n    \n    # Ensure the output is broadcastable to [B, 1]\n    return value.unsqueeze(1)", "stats": {"mse": 17.04881595605469, "rmse": 4.129021186195911, "mse_tsp20": 17.04881595605469, "rmse_tsp20": 4.129021186195911, "mse_tsp50": 137.4622821390625, "rmse_tsp50": 11.724430994255648, "mse_tsp100": 597.1803999125, "rmse_tsp100": 24.437274805356264}, "stats_text": "mse=17.0488; rmse=4.12902; mse_tsp100=597.18; mse_tsp20=17.0488; mse_tsp50=137.462; rmse_tsp100=24.4373; rmse_tsp20=4.12902; rmse_tsp50=11.7244"}
{"score": 0.05770406997688174, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The algorithm estimates the future tour length by combining the expected distance to the next node (average distance from current to unvisited) with the estimated cost of the remaining sub-tour (average inter-node distance for unvisited nodes scaled by the number of remaining nodes).", "code_hash": "c6e9e810e91f1fd5f94481e92b67367e5e737df98b41d0d6f3a71ee61d93e325", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The algorithm estimates the future tour length by combining the expected distance to the next node (average distance from current to unvisited) with the estimated cost of the remaining sub-tour (average inter-node distance for unvisited nodes scaled by the number of remaining nodes).}\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, N, 2]\n    coords = state.all_node_coords()\n    # [B]\n    current_node = state.current_node_index()\n\n    # Number of unvisited nodes, [B]\n    num_unvisited = unvisited_mask.sum(dim=1, dtype=torch.float32)\n\n    # Create a mask for terminal states (num_unvisited == 0)\n    # [B]\n    is_terminal = (num_unvisited == 0)\n\n    # 1. Estimate cost of the remaining sub-tour among unvisited nodes\n    # Mask for pairs of unvisited nodes: [B, N, 1] * [B, 1, N] -> [B, N, N]\n    unvisited_pair_mask = unvisited_mask.unsqueeze(2) & unvisited_mask.unsqueeze(1)\n    # Zero out diagonal to avoid counting self-distances\n    unvisited_pair_mask.diagonal(dim1=-2, dim2=-1).fill_(False)\n\n    # Sum of distances between all pairs of unvisited nodes, [B]\n    sum_dist_unvisited = (dist_matrix * unvisited_pair_mask).sum(dim=(1, 2)) / 2.0\n\n    # Average distance between unvisited nodes\n    # Number of pairs: N_unvisited * (N_unvisited - 1) / 2\n    num_pairs = num_unvisited * (num_unvisited - 1) / 2.0\n    # Avoid division by zero when num_unvisited <= 1, [B]\n    avg_dist_unvisited = torch.nan_to_num(sum_dist_unvisited / (num_pairs + 1e-9))\n\n    # Estimated cost of the sub-tour is (num_unvisited) * avg_dist_unvisited\n    # When num_unvisited is 1, this is 0. When 0, also 0.\n    subtour_cost = (num_unvisited) * avg_dist_unvisited\n\n    # 2. Estimate cost to connect current tour to the remaining sub-tour\n    # [B, N]\n    current_idx_expanded = current_node.unsqueeze(1)\n    # [B, N]\n    dist_from_current = dist_matrix.gather(1, current_idx_expanded.unsqueeze(2).expand(-1, -1, dist_matrix.size(2))).squeeze(1)\n\n    # Sum of distances from current node to all unvisited nodes, [B]\n    sum_dist_from_current_to_unvisited = (dist_from_current * unvisited_mask).sum(dim=1)\n    # Average distance, avoiding division by zero, [B]\n    avg_dist_to_next = torch.nan_to_num(sum_dist_from_current_to_unvisited / (num_unvisited + 1e-9))\n\n    # 3. Combine costs\n    # Total estimated future cost, [B]\n    future_cost = subtour_cost + avg_dist_to_next\n\n    # For terminal states, the future cost is exactly 0.\n    # This handles the case where the tour is complete but not returned to start.\n    # The environment reward will handle the final edge cost.\n    value = torch.where(is_terminal, torch.zeros_like(future_cost), future_cost)\n\n    return value.unsqueeze(1)", "stats": {"mse": 17.329800140625, "rmse": 4.162907654587716, "mse_tsp20": 17.329800140625, "rmse_tsp20": 4.162907654587716, "mse_tsp50": 137.470576159375, "rmse_tsp50": 11.724784695651133, "mse_tsp100": 596.15406229375, "rmse_tsp100": 24.4162663463059}, "stats_text": "mse=17.3298; rmse=4.16291; mse_tsp100=596.154; mse_tsp20=17.3298; mse_tsp50=137.471; rmse_tsp100=24.4163; rmse_tsp20=4.16291; rmse_tsp50=11.7248"}
{"score": 0.04812838813494761, "gamma": 1.0, "algorithm": "auto", "code_hash": "50dcd093dd12b92fd0b2636561caf4c7da89b61f13eef279de583aec6eb021ac", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (negative value) for the TSP environment.\n    The value is estimated based on the connectivity of the remaining unvisited nodes\n    and the distance to the next likely node.\n\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n\n    Returns:\n        torch.Tensor: A scalar potential value for each state in the batch, shape [B, 1].\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited_mask = state.unvisited_mask()\n    # [B, N, 1]\n    unvisited_mask_from = unvisited_mask.unsqueeze(2)\n    # [B, 1, N]\n    unvisited_mask_to = unvisited_mask.unsqueeze(1)\n    # [B, N, N], boolean mask for edges between unvisited nodes\n    unvisited_to_unvisited_mask = unvisited_mask_from & unvisited_mask_to\n\n    # Set distances for invalid (visited-involved) connections to a large value\n    # so they are ignored by the min operation.\n    large_value = 1e9\n    # [B, N, N]\n    dists_unvisited = torch.where(\n        unvisited_to_unvisited_mask,\n        dist_matrix,\n        torch.full_like(dist_matrix, large_value)\n    )\n\n    # For each unvisited node, find the minimum distance to another unvisited node.\n    # We set the diagonal to a large value to avoid picking the node itself (dist=0).\n    # [B, N]\n    diag_mask = torch.eye(dist_matrix.size(1), device=dist_matrix.device).unsqueeze(0)\n    dists_unvisited = torch.where(diag_mask, large_value, dists_unvisited)\n    # [B, N], min dist from each node `i` to any other unvisited node `j`\n    min_dists, _ = torch.min(dists_unvisited, dim=2)\n\n    # Sum these minimum distances only for the unvisited nodes.\n    # [B]\n    sum_min_dists = torch.sum(min_dists * unvisited_mask, dim=1)\n\n    # Get the number of unvisited nodes. Add a small epsilon to avoid division by zero.\n    # [B]\n    n_unvisited = torch.sum(unvisited_mask, dim=1).float()\n    \n    # Calculate the average minimum distance between unvisited nodes.\n    # This represents the expected cost per hop in the remainder of the tour.\n    # [B]\n    avg_min_dist = sum_min_dists / torch.clamp(n_unvisited, min=1.0)\n    \n    # Estimate the total remaining path length based on this average.\n    # [B]\n    remaining_path_estimate = avg_min_dist * n_unvisited\n\n    # Add the cost to get from the current node to the nearest unvisited node.\n    # [B]\n    current_node = state.current_node_index()\n    # [B, N]\n    dists_from_current = torch.gather(dist_matrix, 1, current_node.view(-1, 1, 1).expand(-1, 1, dist_matrix.size(2))).squeeze(1)\n    # [B, N]\n    dists_from_current_to_unvisited = torch.where(\n        unvisited_mask,\n        dists_from_current,\n        torch.full_like(dists_from_current, large_value)\n    )\n    # [B]\n    min_dist_to_next, _ = torch.min(dists_from_current_to_unvisited, dim=1)\n    \n    # If there are no unvisited nodes, this distance is inf. Set it to 0.\n    # [B]\n    is_done = (n_unvisited == 0)\n    min_dist_to_next = torch.where(is_done, 0.0, min_dist_to_next)\n\n    # The final potential is the sum of the estimated remaining path and the immediate next step.\n    # The negative sign is because rewards are negative distances.\n    # [B]\n    value = -(remaining_path_estimate + min_dist_to_next)\n    \n    # Ensure terminal states (and states with 1 unvisited node, which is the last step) have a potential of 0.\n    # This helps with terminal consistency.\n    is_terminal_or_near_terminal = (n_unvisited <= 1)\n    value = torch.where(is_terminal_or_near_terminal, 0.0, value)\n\n    return value.unsqueeze(1)", "stats": {"mse": 20.777757966796877, "rmse": 4.558262603974992, "mse_tsp20": 20.777757966796877, "rmse_tsp20": 4.558262603974992, "mse_tsp50": 40.76918255703125, "rmse_tsp50": 6.385074984448597, "mse_tsp100": 73.389741278125, "rmse_tsp100": 8.566781267087716}, "stats_text": "mse=20.7778; rmse=4.55826; mse_tsp100=73.3897; mse_tsp20=20.7778; mse_tsp50=40.7692; rmse_tsp100=8.56678; rmse_tsp20=4.55826; rmse_tsp50=6.38507"}
{"score": 0.012843472926228384, "gamma": -0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (Monte Carlo value V(state)) for the TSP environment. {My algorithm calculates the expected cost-to-go by summing two components: (1) the average distance from the current node to all unvisited nodes, representing the next step's expected cost, and (2) the expected cost of the remaining sub-tour, approximated by the number of remaining edges multiplied by the average pairwise distance between all unvisited nodes.", "code_hash": "fb7bdab678a355c5b634ad50ffb00335f41a66d8901f0875375b428e57a8e79e", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (Monte Carlo value V(state)) for the TSP environment.\n    {My algorithm calculates the expected cost-to-go by summing two components: (1) the average distance from the current node to all unvisited nodes, representing the next step's expected cost, and (2) the expected cost of the remaining sub-tour, approximated by the number of remaining edges multiplied by the average pairwise distance between all unvisited nodes.}\n    Args:\n        state (TSPStateView): The current state of the TSP environment.\n    Returns:\n        torch.Tensor: A scalar potential value for each state in the batch, shape [B, 1].\n    \"\"\"\n    # [B, N, N]\n    dist_matrix = state.distance_matrix()\n    # [B, N]\n    unvisited = state.unvisited_mask()\n    # [B]\n    current_node = state.current_node_index()\n    # [B, 1, N]\n    current_node_exp = current_node.unsqueeze(-1).unsqueeze(-1).expand(-1, 1, dist_matrix.size(2))\n\n    # Number of unvisited nodes, [B]\n    num_unvisited = unvisited.sum(dim=1, dtype=torch.float32)\n\n    # Avoid division by zero for terminal states (num_unvisited can be 0 or 1)\n    # If num_unvisited is 0 or 1, the future path length is 0.\n    is_not_terminal = (num_unvisited > 1.0)\n    safe_num_unvisited = torch.where(is_not_terminal, num_unvisited, torch.ones_like(num_unvisited))\n    safe_num_unvisited_pairs = torch.where(is_not_terminal, num_unvisited * (num_unvisited - 1) / 2.0, torch.ones_like(num_unvisited))\n\n    # 1. Cost from current node to the next unvisited node (approximate)\n    # [B, 1, N]\n    dist_from_current = torch.gather(dist_matrix, 1, current_node_exp)\n    # [B, N]\n    dist_from_current_squeezed = dist_from_current.squeeze(1)\n    # Set distances to visited nodes to 0 to exclude them from the sum\n    dist_from_current_to_unvisited = dist_from_current_squeezed * unvisited\n    # [B]\n    sum_dist_to_unvisited = dist_from_current_to_unvisited.sum(dim=1)\n    # [B], average distance to an unvisited node\n    avg_dist_to_next = sum_dist_to_unvisited / safe_num_unvisited\n\n    # 2. Cost of the remaining sub-tour among unvisited nodes (approximate)\n    # Create a mask for pairs of unvisited nodes\n    # [B, N, 1] * [B, 1, N] -> [B, N, N]\n    unvisited_pair_mask = unvisited.unsqueeze(2) * unvisited.unsqueeze(1)\n    # [B, N, N], distances between unvisited nodes\n    sub_tour_dists = dist_matrix * unvisited_pair_mask\n    # [B], sum of distances between all pairs of unvisited nodes (upper triangle)\n    sum_pairwise_dist_unvisited = sub_tour_dists.sum(dim=[1, 2]) / 2.0\n    # [B], average distance between any two unvisited nodes\n    avg_pairwise_dist = sum_pairwise_dist_unvisited / safe_num_unvisited_pairs\n\n    # The number of edges in the remaining tour is (num_unvisited - 1)\n    # We add 1 to connect back to the start, but let's use num_unvisited as an approximation\n    # for the number of \"steps\" or edges remaining.\n    remaining_edges = num_unvisited - 1.0\n    \n    # Approximate cost of the remaining sub-tour\n    # Using num_unvisited instead of remaining_edges as it seems more stable\n    remaining_tour_cost = num_unvisited * avg_pairwise_dist\n\n    # Total estimated future cost\n    # We negate because the environment uses negative distances as rewards.\n    # Phi should be an estimate of V, which is the sum of future rewards (negative lengths).\n    # So, V is negative. We return a negative value.\n    value = -(avg_dist_to_next + remaining_tour_cost)\n\n    # For terminal states, future cost is 0.\n    final_value = torch.where(is_not_terminal, value, torch.zeros_like(value))\n\n    return final_value.unsqueeze(-1)", "stats": {"mse": 77.8605604375, "rmse": 8.823863124363386, "mse_tsp20": 77.8605604375, "rmse_tsp20": 8.823863124363386, "mse_tsp50": 340.59652695625, "rmse_tsp50": 18.455257434028116, "mse_tsp100": 1123.295391975, "rmse_tsp100": 33.51559923341667}, "stats_text": "mse=77.8606; rmse=8.82386; mse_tsp100=1123.3; mse_tsp20=77.8606; mse_tsp50=340.597; rmse_tsp100=33.5156; rmse_tsp20=8.82386; rmse_tsp50=18.4553"}
{"score": 0.006395243986950299, "gamma": 0.1, "algorithm": "auto} def phi(state): \"\"\" Estimates the future tour length (cost-to-go) for the TSP environment. {The potential is estimated by summing two components: the average distance from the current node to all unvisited nodes, and the average distance from all unvisited nodes back to the start node, with both components scaled by the number of remaining nodes to approximate the total path length of the remaining sub-tour.", "code_hash": "098cffc5646f2d78d70fba303d3a95ed9104ca4e1798e43c3f466db5b2b1130c", "code": "# THOUGHT: {auto}\ndef phi(state):\n    \"\"\"\n    Estimates the future tour length (cost-to-go) for the TSP environment.\n    {The potential is estimated by summing two components: the average distance from the current node to all unvisited nodes, and the average distance from all unvisited nodes back to the start node, with both components scaled by the number of remaining nodes to approximate the total path length of the remaining sub-tour.}\n    Args:\n        state: A view of the current state of the TSP environment.\n    Returns:\n        A tensor of shape [B, 1] representing the estimated future tour length.\n    \"\"\"\n    # Get batch size and number of nodes\n    B, N, _ = state.distance_matrix().shape\n\n    # Get masks for unvisited nodes\n    unvisited_mask = state.unvisited_mask() # [B, N]\n    num_unvisited = unvisited_mask.sum(dim=1, keepdim=True).float() # [B, 1]\n\n    # Get distance matrix\n    dist_matrix = state.distance_matrix() # [B, N, N]\n\n    # Get current and start node indices\n    current_idx = state.current_node_index().view(B, 1, 1).expand(-1, 1, N) # [B, 1, N]\n    start_idx = state.first_node_index().view(B, 1, 1).expand(-1, N, 1) # [B, N, 1]\n\n    # Component 1: Average distance from current node to all unvisited nodes\n    # dist_from_current is [B, N], representing dist(current, i) for all i\n    dist_from_current = torch.gather(dist_matrix, 1, current_idx).squeeze(1) # [B, N]\n    # Mask out visited nodes and sum distances to unvisited nodes\n    sum_dist_from_current_to_unvisited = (dist_from_current * unvisited_mask).sum(dim=1, keepdim=True) # [B, 1]\n    # Avoid division by zero when all nodes are visited\n    safe_num_unvisited = num_unvisited.clamp(min=1.0)\n    avg_dist_from_current = sum_dist_from_current_to_unvisited / safe_num_unvisited # [B, 1]\n\n    # Component 2: Average distance from all unvisited nodes to the start node\n    # dist_to_start is [B, N], representing dist(i, start) for all i\n    dist_to_start = torch.gather(dist_matrix, 2, start_idx).squeeze(2) # [B, N]\n    # Mask out visited nodes and sum distances from unvisited nodes\n    sum_dist_from_unvisited_to_start = (dist_to_start * unvisited_mask).sum(dim=1, keepdim=True) # [B, 1]\n    avg_dist_to_start = sum_dist_from_unvisited_to_start / safe_num_unvisited # [B, 1]\n\n    # Estimate future path length. The number of remaining edges is (num_unvisited + 1).\n    # We use num_unvisited as a simpler scaling factor.\n    # The logic is: (avg cost from current to next) + (num_unvisited-1)*(avg cost between unvisited) + (avg cost from last to start)\n    # This is approximated by scaling the average distances.\n    # The scaling factor `num_unvisited` represents the number of remaining \"steps\" or edges.\n    # The first term represents the cost of the next step, and the second represents the cost of returning home eventually.\n    # We use all_node_coords() to get N for scaling, making it more robust.\n    # A small constant is added to the scaling to prevent the potential from being exactly zero when only one node is left.\n    tour_length_scale = (state.all_node_coords().shape[1] / 20.0).sqrt() # Heuristic scale based on N\n    \n    # The potential is the sum of the scaled average distances.\n    # The first term estimates the cost of visiting all unvisited nodes from the current location.\n    # The second term estimates the cost of returning from the \"center of mass\" of unvisited nodes to the start.\n    # Multiplying by num_unvisited approximates the total length of these remaining segments.\n    # Adding 1 to num_unvisited accounts for the final edge back to the start.\n    remaining_edges = num_unvisited\n    \n    # We use a simpler heuristic: cost is proportional to the number of remaining nodes\n    # and the average distance to them from current and from them to start.\n    potential = (avg_dist_from_current + avg_dist_to_start) * remaining_edges * tour_length_scale\n\n    # The potential should be zero when the tour is complete (num_unvisited == 0).\n    # The calculation naturally handles this as num_unvisited becomes 0.\n    return potential.detach()", "stats": {"mse": 156.36619995117186, "rmse": 12.504647134212618, "mse_tsp20": 156.36619995117186, "rmse_tsp20": 12.504647134212618, "mse_tsp50": 2104.049633679883, "rmse_tsp50": 45.86992079434935, "mse_tsp100": 16240.498291789843, "rmse_tsp100": 127.43821362444564}, "stats_text": "mse=156.366; rmse=12.5046; mse_tsp100=16240.5; mse_tsp20=156.366; mse_tsp50=2104.05; rmse_tsp100=127.438; rmse_tsp20=12.5046; rmse_tsp50=45.8699"}
